struct Instance
{
    idx: uint, // mesh index
    w2o: Matrix, // world to object transformation matrix
}
static Instance_SIZEOF = uint_SIZEOF + Matrix_SIZEOF;

struct Instances
{
    insts: DynArray, // of Instance
}
fn instancesInit() -> Instances
{
    Instances{ insts:@dynArray(Instance_SIZEOF, "Instances.insts") }
}

fn instancesAppend(mut insts: &Instances, idx: uint, w2o: Matrix) -> ()
{
    let mut instance = Instance{ idx:idx, w2o: w2o };
    dynArrayAppend(&insts.insts, &instance as &u8);
}

struct RTInstance
{
    idx: uint, // mesh index
    w2o: Matrix, // world to object transformation matrix
    swapsHandedness : bool, // is the determinant of the above matrix negative?
}
struct RTInstances
{
    insts: &[RTInstance],
}
fn instsBVHInterface(mut insts: &Instances, mut rtInsts: &RTInstances, boundsFn: primBoundsFn) -> (primInitFn, primBoundsFn, primCopyFn, primFinishFn)
{
    let mut curIdx = 0u;

    (   // init
        ||{
            let nInsts = @dynArraySize(&insts.insts);
            rtInsts.insts  = ~[nInsts:RTInstance];
            nInsts
        },
        // bounds: relay request, we don't know our meshes
        boundsFn,
        // copy
        |copyIdx|{
            //print_sii("Copying triangle with <id1> (that's number <id2>)", copyIdx as int, curIdx as int);
            // append instance copyIdx in insts, to the list of instances in rtInsts
            let inst = @dynArrayFetch(&insts.insts, copyIdx) as &Instance;
            rtInsts.insts(curIdx).idx = inst.idx;
            rtInsts.insts(curIdx).w2o = inst.w2o;
            rtInsts.insts(curIdx).swapsHandedness = false; // FIXME compute determinant
            // increment and return
            let idx = curIdx;
            curIdx = idx+1u;
            idx
        },
        // finish
        ||{
            @dynArrayClear(&insts.insts);
        }
    )
}
fn instsFree(mut insts: &RTInstances) -> ()
{
    thorin_free(&insts.insts as &u8);
}

fn instanceIntersectFirst(idx: uint, mut insts: &RTInstances, ray: &Ray, maxdist: float, sisec : &ShadingIntersection, subIntersectFirst: IntersectFirstFn) -> float
{
    let inst = &insts.insts(idx);
    @subIntersectFirst(inst.idx, ray, maxdist, sisec)
}


fn instanceIntersectAny(idx: uint, mut insts: &RTInstances, ray : &Ray, maxdist : float, subIntersectAny: IntersectAnyFn) -> bool
{
    let inst = &insts.insts(idx);
    @subIntersectAny(inst.idx, ray, maxdist)
}

/*


fn objIntersectFirst(objidx : uint, scene : &Scene, theRay: Ray, maxdist: float, mut sisec : &ShadingIntersection) -> float
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, theRay.o);
    let idir = @mvmul(scene.objs(objidx).w2o, theRay.d);
    let unitLen = @vlen(idir);
    let invUnitLen = 1.0f / unitLen;

    // perform intersection with new scratch space [HACK!]
    let iRay:Ray = @ray(io, @vfmul(idir, invUnitLen));
    let iMaxDist = maxdist*unitLen;
    let iNewDist = @bvhIntersectFirst(scene.objs(objidx).bvhRoot, scene, iRay, iMaxDist, sisec);
    if (iNewDist >= iMaxDist) { return(maxdist) }
    let newDist = iNewDist*invUnitLen; // this is in world units
    @assert(||newDist < maxdist, "after scaling back, we're no better than the already best hit");

    // and translate it back
    let transformNormal = |v:Vec|->Vec{
        let vT = @mmul_transposed3x3(scene.objs(objidx).w2o, v);
        @normalize(if scene.objs(objidx).swapsHandedness { @vflip(v) } else { v })
    };
    sisec.surfaceNormal = @transformNormal(sisec.surfaceNormal);
    sisec.shadingNormal = @transformNormal(sisec.shadingNormal);
    sisec.eps = sisec.eps*@max(unitLen, invUnitLen);
    return(newDist)
}

fn objIntersectAny(objidx : uint, scene : &Scene, theRay : Ray, maxdist : float) -> bool
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, theRay.o);
    let idir = @mvmul(scene.objs(objidx).w2o, theRay.d);
    let unitLen = @vlen(idir);
    let subRay = @ray(io, @vfdiv(idir, unitLen));
    bvhIntersectAny(scene.objs(objidx).bvhRoot, scene, subRay, maxdist)
}
*/
