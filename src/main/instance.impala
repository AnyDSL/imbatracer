struct Instance
{
    idx: uint, // mesh index
    o2w: Matrix, // object to world transformation matrix
}
static Instance_SIZEOF = uint_SIZEOF + Matrix_SIZEOF;

struct Instances
{
    insts: DynArray, // of Instance
}
fn instancesInit() -> Instances
{
    Instances{ insts:@dynArray(Instance_SIZEOF, "Instances.insts") }
}

fn instancesAppend(mut insts: &Instances, idx: uint, o2w: Matrix) -> ()
{
    let mut instance = Instance{ idx:idx, o2w: o2w };
    dynArrayAppend(&insts.insts, &instance as &u8);
}
fn instancesAppendI(insts: &Instances, idx: uint) -> ()
{
    @instancesAppend(insts, idx, @matrixI())
}

struct RTInstance
{
    idx: uint, // mesh index
    w2o: Matrix, // world to object transformation matrix
    swapsHandedness : bool, // is the determinant of the above matrix negative?
}
struct RTInstances
{
    insts: &[RTInstance],
}
static RTInstances_SIZEOF = pointer_SIZEOF;
// copy instances into a BVH. This expects the rtInsts to be unitialised.
fn instsBVHInterface(mut insts: &Instances, mut rtInsts: &RTInstances, boundsFn: primBoundsFn) -> (primInitFn, primBoundsFn, primCopyFn, primFinishFn)
{
    let mut curIdx = 0u;

    (   // init
        ||{
            let nInsts = @dynArraySize(&insts.insts);
            rtInsts.insts  = ~[nInsts:RTInstance];
            (nInsts, curIdx)
        },
        // bounds
        |idx|{
            let inst = @dynArrayFetch(&insts.insts, idx) as &Instance;
            let iBounds = boundsFn(inst.idx);
            let diag = @bbdiag(iBounds);
            let x = @vec(diag.x, 0.0f, 0.0f);
            let y = @vec(0.0f, diag.y, 0.0f);
            let z = @vec(0.0f, 0.0f, diag.z);
            @bbextend(@bbextend(@bbextend(@bbextend(@bbextend(@bbextend(@bbox(
                @mpmul(inst.o2w, iBounds.cmin),
                @mpmul(inst.o2w, iBounds.cmax)),
                @mpmul(inst.o2w, @pvadd(iBounds.cmin, x))),
                @mpmul(inst.o2w, @pvadd(iBounds.cmin, y))),
                @mpmul(inst.o2w, @pvadd(iBounds.cmin, z))),
                @mpmul(inst.o2w, @pvsub(iBounds.cmax, x))),
                @mpmul(inst.o2w, @pvsub(iBounds.cmax, y))),
                @mpmul(inst.o2w, @pvsub(iBounds.cmax, z)))
        },
        // copy
        |copyIdx|{
            //print_sii("Copying triangle with <id1> (that's number <id2>)", copyIdx as int, curIdx as int);
            // append instance copyIdx in insts, to the list of instances in rtInsts
            let inst = @dynArrayFetch(&insts.insts, copyIdx) as &Instance;
            rtInsts.insts(curIdx).idx = inst.idx;
            let mut det:float;
            rtInsts.insts(curIdx).w2o = @minvert(inst.o2w, &det);
            @assert(||det != 0.0f, "The matrix you gave me is not invertible");
            rtInsts.insts(curIdx).swapsHandedness = det < 0.0f;
            // increment and return
            let idx = curIdx;
            curIdx = idx+1u;
            idx
        },
        // finish
        ||{
            @dynArrayClear(&insts.insts);
        }
    )
}
fn instsFree(insts: &RTInstances) -> ()
{
    thorin_free(insts.insts as &u8);
}

fn instanceIntersectFirst(idx: uint, mut insts: &RTInstances, theRay: &Ray, maxdist: float, mut sisec : &ShadingIntersection, subIntersectFirst: IntersectFirstFn) -> float
{
    let inst = &insts.insts(idx);
    // translate world to object
    let io = @mpmul(inst.w2o, theRay.o);
    let idir = @mvmul(inst.w2o, theRay.d);
    let unitLen = @vlen(idir);
    let invUnitLen = 1.0f / unitLen;

    // perform intersection with new scratch space
    let mut iRay:Ray = @ray(io, @vfmul(idir, invUnitLen));
    let iMaxDist = maxdist*unitLen;
    let iNewDist = subIntersectFirst(inst.idx, &iRay, iMaxDist, sisec);
    if (iNewDist >= iMaxDist) { return(maxdist) }
    let newDist = iNewDist*invUnitLen; // this is in world units
    @assert(||newDist < maxdist, "after scaling back, we're no better than the already best hit");

    // and translate it back
    let transformNormal = |v:Vec|->Vec{
        let vT = @mmul_transposed3x3(inst.w2o, v);
        @normalize(if inst.swapsHandedness { @vflip(v) } else { v })
    };
    sisec.surfaceNormal = @transformNormal(sisec.surfaceNormal);
    sisec.shadingNormal = @transformNormal(sisec.shadingNormal);
    sisec.eps = sisec.eps*@max(unitLen, invUnitLen);
    return(newDist)
}


fn instanceIntersectAny(idx: uint, mut insts: &RTInstances, theRay : &Ray, maxdist : float, subIntersectAny: IntersectAnyFn) -> bool
{
    let inst = &insts.insts(idx);
    // translate world to object
    let io = @mpmul(inst.w2o, theRay.o);
    let idir = @mvmul(inst.w2o, theRay.d);
    let unitLen = @vlen(idir);
    let mut iRay = @ray(io, @vfdiv(idir, unitLen));
    let iMaxDist = maxdist*unitLen;
    subIntersectAny(inst.idx, &iRay, iMaxDist)
}
