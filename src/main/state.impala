

struct State
{
    time : float,
    cam : Cam,
    integrator : Integrator,
    scene : RTScene,

    // Pointers for specific parts of the tracer
    meshIdxs: &u8, // used by interface_loc
    pixelBuffer : &u8, // used by mapping_cpu for subsampling
    camctrl : &u8, // used by camcontrol

    paused : int,
}
static State_SIZEOF = float_SIZEOF + Cam_SIZEOF + Integrator_SIZEOF + RTScene_SIZEOF + 3u*pointer_SIZEOF + 4u;

fn stateInit() -> &State
{
    let mut state = ~[1:State] as &State;
    // set it all to zero, and check that this worked
    print_si("It seems that states have size",State_SIZEOF as int);
    @assert(||State_SIZEOF % pointer_SIZEOF == 0u, "State_SIZEOF is not pointer-aligned");
    state.camctrl = state as &u8;
    memset(state as &u8, 0, State_SIZEOF as size_t);
    @assert(||state.camctrl == (0 as &u8), "State_SIZEOF is wrong!");
    state.paused = 0;
    return(state)
}

fn stateFree(mut state: &State) -> ()
{
    sceneFree(&state.scene);
    thorin_free(state.meshIdxs as &u8);
    thorin_free(state.pixelBuffer as &u8);
    thorin_free(state.camctrl as &u8);
    thorin_free(state as &u8);
}

struct RTState
{
    cam : Cam,
    integrator : Integrator,
    scene : RTScene,
}
