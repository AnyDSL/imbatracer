/*
struct Object
{
    bvhRoot : uint,
    //o2w : Matrix, // object to world
	w2o : Matrix, // world to object
	swapsHandedness : bool, // is the determinant of the above matrices negative?
}

fn objIntersectFirst(objidx : uint, scene : &Scene, theRay: Ray, maxdist: float, mut sisec : &ShadingIntersection) -> float
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, theRay.o);
    let idir = @mvmul(scene.objs(objidx).w2o, theRay.d);
    let unitLen = @vlen(idir);
    let invUnitLen = 1.0f / unitLen;

    // perform intersection with new scratch space [HACK!]
    let iRay:Ray = @ray(io, @vfmul(idir, invUnitLen));
    let iMaxDist = maxdist*unitLen;
    let iNewDist = @bvhIntersectFirst(scene.objs(objidx).bvhRoot, scene, iRay, iMaxDist, sisec);
    if (iNewDist >= iMaxDist) { return(maxdist) }
    let newDist = iNewDist*invUnitLen; // this is in world units
    @assert(||newDist < maxdist, "after scaling back, we're no better than the already best hit");

    // and translate it back
    let transformNormal = |v:Vec|->Vec{
        let vT = @mmul_transposed3x3(scene.objs(objidx).w2o, v);
        @normalize(if scene.objs(objidx).swapsHandedness { @vflip(v) } else { v })
    };
    sisec.surfaceNormal = @transformNormal(sisec.surfaceNormal);
    sisec.shadingNormal = @transformNormal(sisec.shadingNormal);
    sisec.eps = sisec.eps*@max(unitLen, invUnitLen);
    return(newDist)
}

fn objIntersectAny(objidx : uint, scene : &Scene, theRay : Ray, maxdist : float) -> bool
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, theRay.o);
    let idir = @mvmul(scene.objs(objidx).w2o, theRay.d);
    let unitLen = @vlen(idir);
    let subRay = @ray(io, @vfdiv(idir, unitLen));
    bvhIntersectAny(scene.objs(objidx).bvhRoot, scene, subRay, maxdist)
}
*/
