
struct Object
{
    bvhRoot : uint,
    //o2w : Matrix, // object to world
	w2o : Matrix, // world to object
	swapsHandedness : bool, // is the determinant of the above matrices negative?
}

fn objIntersectFirst(objidx : uint, scene : &Scene, mut isec : &Intersection) -> ()
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, isec.ray.o);
    let idir = @mvmul(scene.objs(objidx).w2o, isec.ray.d);
    let unitLen = @vlen(idir);
    let invUnitLen = 1.0f / unitLen;

    // perform intersection with new scratch space [HACK!]
    let mut tmpIsec = @intersection(@ray(io, @vfmul(idir, invUnitLen)), isec.dist*unitLen);
    @bvhIntersectFirst(scene.objs(objidx).bvhRoot, scene, &tmpIsec);
    if (tmpIsec.tri == @noObj()) { return() }
    let newDist = tmpIsec.dist*invUnitLen; // this is in world units
    if (newDist >= isec.dist) { return () } // after scaling back, we're no better than the alreaady best hit

    @improveIntersection(isec, newDist);
    isec.b = tmpIsec.b;
    isec.tri = tmpIsec.tri;
    isec.obj = objidx;
}

fn objIntersectAny(objidx : uint, scene : &Scene, theRay : Ray, maxdist : float) -> bool
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, theRay.o);
    let idir = @mvmul(scene.objs(objidx).w2o, theRay.d);
    let unitLen = @vlen(idir);
    let subRay = ray(io, vfdiv(idir, unitLen));
    bvhIntersectAny(scene.objs(objidx).bvhRoot, scene, subRay, maxdist)
}

fn objShadeIntersection(objidx: uint, scene: &Scene, isec: &Intersection) -> ShadingIntersection
{
    triShadeIntersection(isec.tri, scene, isec) // FIXME transform

/*
// and translate it back
let transformNormal = |v:Vec|->Vec{
    let vT = @mmul_transposed3x3(scene.objs(objidx).w2o, v);
    @normalize(if scene.objs(objidx).swapsHandedness { @vflip(v) } else { v })
};
let surfaceNormal = @transformNormal(tmpIsec.surfaceNormal);
let epsilonFactor = @max(unitLen, invUnitLen);*/
}
