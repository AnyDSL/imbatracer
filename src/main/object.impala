
struct Object
{
    bvhRoot : uint,
    //o2w : Matrix, // object to world
	w2o : Matrix, // world to object
	swapsHandedness : bool, // is the determinant of the above matrices negative?
}

fn objIntersectFirst(objidx : uint, scene : &Scene, isec : &Intersection) -> ()
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, isec.ray.o);
    let idir = @mvmul(scene.objs(objidx).w2o, isec.ray.d);
    let unitLen = @vlen(idir);
    let invUnitLen = 1.0f / unitLen;

    // perform intersection with new scratch space [HACK!]
    let mut tmpIsec = @intersection(@ray(io, @vfmul(idir, invUnitLen)), isec.dist*unitLen);
    @bvhIntersectFirst(scene.objs(objidx).bvhRoot, scene, &tmpIsec);
    if (tmpIsec.obj == @noObj()) { return() }
    let newDist = tmpIsec.dist*invUnitLen; // this is in world units
    if (newDist >= isec.dist) { return () } // after scaling back, we're no better than the alreaady best hit

    // and translate it back
    let transformNormal = |v:Vec|->Vec{
        let vT = @mmul_transposed3x3(scene.objs(objidx).w2o, v);
        @normalize(if scene.objs(objidx).swapsHandedness { @vflip(v) } else { v })
    };
    let surfaceNormal = @transformNormal(tmpIsec.surfaceNormal);
    let epsilonFactor = @max(unitLen, invUnitLen);
    @improveIntersection(isec, newDist, tmpIsec.obj, surfaceNormal, tmpIsec.b, tmpIsec.eps*epsilonFactor)
}

fn objIntersectAny(objidx : uint, scene : &Scene, theRay : Ray, maxdist : float) -> bool
{
    // translate world to object
    let io = @mpmul(scene.objs(objidx).w2o, theRay.o);
    let idir = @mvmul(scene.objs(objidx).w2o, theRay.d);
    let unitLen = @vlen(idir);
    let subRay = ray(io, vfdiv(idir, unitLen));
    bvhIntersectAny(scene.objs(objidx).bvhRoot, scene, subRay, maxdist)
}
