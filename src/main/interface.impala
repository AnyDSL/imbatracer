
struct SceneMgr {} // opaque pointer, C++ puts stuff here


struct State
{
    time : float,
    cam : Cam,
    integrator : Integrator,
    scene : Scene,

    sceneMgr : &SceneMgr
}

struct RTState
{
    cam : Cam,
    integrator : Integrator,
    scene : Scene,
}
struct RTScratch
{
    isec : Intersection,
    bvh  : BVHTraversal,
}
fn emptyScratch() -> RTScratch
{
    @RTScratch{ isec:emptyIntersection(), bvh:emptyBVHTraversal() }
}

extern fn impala_init(mut state : &State) -> ()
{
    (*state).time = 0.0f;
    (*state).integrator.itype = 0;

    scene_add_cube(state, 40.0f);
    scene_add_file(state, 3);
    scene_build(state);
}

extern fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = (*state).time;
    (*state).time = time + dt;
    let scale = 80.0f;
    let pos = point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = point0();
    let up = vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi() / 4.0f;
    let vertOpenAngle = pi() / 3.0f;
    (*state).cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);
}

extern fn impala_init_bench1(mut state : &State) -> ()
{
    (*state).integrator.itype = 0;

    scene_add_file(state, 3);
    scene_build(state);

    let scale = 40.0f;
    let pos = point(-3.5f*scale, 1.2f*scale, 3.7f*scale);
    let at = point0();
    let up = vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi() / 4.0f;
    let vertOpenAngle = pi() / 3.0f;
    (*state).cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);
}

fn renderImage(mut buf : &[u32], width : int, height : int, measureTime : bool, state : &State, body : fn(float, float, RTState, &RTScratch) -> Color) -> ()
{
    let wf = width as float;
    let hf = height as float;
    for x, y, state, scratch in renderIteration(width, height, measureTime, state)
    {
        // render in the center of the pixel
        let nx = (x as float + 0.5f) / wf;
        let ny = (y as float + 0.5f) / hf;
        // convert to screen coordinates (remember to swap y axis)
        let sx =  (nx - 0.5f) * 2.0f;
        let sy = -(ny - 0.5f) * 2.0f;
        // put color into index
        let idx = y*width+x;
        buf(idx) = col_rgb2int(body(sx, sy, state, scratch));
    }
}

extern fn impala_render(buf : &[u32], width : int, height : int, measureTime : bool, state : &State) -> ()
{
    @renderImage(buf, width, height, measureTime, state, |x, y, state, scratch|{
        runIntegrator(state.integrator, state.scene, runCamera(state.cam, x, y), scratch)
    });
}
