
struct State
{
    time : float,
    cam : Cam,
    integrator : Integrator,
    scene : Scene,

}

extern fn impala_init(mut state : &State) -> ()
{
    (*state).time = 0.0f;
    scene_load_cube(&(*state).scene);

    impala_update(state, 0.0f); // force first update cycle to init camera values and everything
}

extern fn impala_deinit(mut state : &State) -> ()
{
    scene_free(&(*state).scene);
}

fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = (*state).time;
    (*state).time = time + dt;
    let pos = point(-3.5f*sinf(time), 1.2f*sinf(0.2f*time), 3.7f*cosf(time));
    let at = point0();
    let up = vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = M_PI() / 4.0f;
    let vertOpenAngle = M_PI() / 3.0f;
    camInitPerspectiveLookAt(&(*state).cam, pos, at, up, horzOpenAngle, vertOpenAngle);

    (*state).integrator.itype = 0;
}

extern fn impala_render(buf : &[u32], width : int, height : int, mut state : &State, dt : float)
-> ()
{
    @impala_update(state, dt);
    let camera = @compileCamera(&(*state).cam);
    let scene = @compileScene(&(*state).scene);
    let integrator = @compileIntegrator(&(*state).integrator, scene);

    renderImage(buf, width, height, |x, y| { integrator(camera(x, y)) } )
}
