
struct State
{
    time : float,
    cam : Cam,
    integrator : Integrator,
    scene : Scene,

}

extern fn impala_init(mut state : &State) -> ()
{
    (*state).time = 0.0f;
    (*state).integrator.itype = 0;

    let scene = &(*state).scene;
    scene_add_cube(scene, 40.0f);
    scene_add_file(scene, 3);
    scene_build(scene);
}

extern fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = (*state).time;
    (*state).time = time + dt;
    let scale = 80.0f;
    let pos = point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = point0();
    let up = vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi() / 4.0f;
    let vertOpenAngle = pi() / 3.0f;
    (*state).cam = camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);
}

extern fn impala_init_bench1(mut state : &State) -> ()
{
    (*state).integrator.itype = 0;

    let scene = &(*state).scene;
    scene_add_file(scene, 3);
    scene_build(scene);

    let scale = 40.0f;
    let pos = point(-3.5f*scale, 1.2f*scale, 3.7f*scale);
    let at = point0();
    let up = vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi() / 4.0f;
    let vertOpenAngle = pi() / 3.0f;
    (*state).cam = camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);
}

fn renderImage(mut buf : &[u32], width : int, height : int, measureTime : bool, body : fn(float, float, &Intersection) -> Color) -> ()
{
    let wf = width as float;
    let hf = height as float;
    for x, y, isec in iteration(width, height, measureTime)
    {
        // render in the center of the pixel
        let nx = (x as float + 0.5f) / wf;
        let ny = (y as float + 0.5f) / hf;
        // convert to screen coordinates (remember to swap y axis)
        let sx =  (nx - 0.5f) * 2.0f;
        let sy = -(ny - 0.5f) * 2.0f;
        // put color into index
        let idx = y*width+x;
        buf(idx) = col_rgb2int(body(sx, sy, isec));
    }
}

extern fn impala_render(buf : &[u32], width : int, height : int, measureTime : bool, statep : &State) -> ()
{
    let state = *statep;
            let camera = @compileCamera(state.cam);
        let scene = @compileScene(state.scene);
        let integrator = @compileIntegrator(state.integrator, scene);
    renderImage(buf, width, height, measureTime, |x, y, isec| {
        // FIXME maybe closures aren't the best idea, after all...


        integrator(camera(x, y), isec)
    } )
}
