
extern "C"
{
    fn callbackTest(x : int, y : int) -> ();
    fn c_rand() -> (int);
}

fn setpixel(mut buf : &[u32], width : int, height : int, state : &[float], x : int, y : int)
-> ()
{
    buf(x + width*y) = (state(0) * 5000.0f) as u32;
}

fn wat(x : u32) -> u32
{
    x + 1u32
}



// TODO: passed state should be a struct
extern fn impala_render(mut buf : &[u32], width : int, height : int, state : &[float])
-> ()
{
    for x, y in iteration(width, height)
    {
        if x > 30 && y > 30
        {
            buf(y*width + x) = (state(0) * 10.0f) as u32;
        }
    }

    for x in range(0, width)
    {
         buf(20*width + x) = 4278255360 as u32; // green line: ok!

         buf(22*width + x) = 0xff as u32; // red line: ok!

         let v = (state(0) * 1000.0f) as int;
         buf(24*width + x) = ((v<<24) | v) as u32; // <-- ehh what. won't compile this

         //callbackTest(x, 0xffffffff); // COMMENT THIS IN TO MAKE LINES APPEAR
    }

    // DOES NOT WORK
    // should display single pixel at (15, 15) with changing color
    setpixel(buf, width, height, state, 15, 15);


    // WORKS!
    // displays single pixel at (10, 10) with rapidly changing color
    buf(10 + width*10) = state(0) * 10000.0f as u32;

    let t = state(0) as int;
    for x, y in iteration(width, height)
    {
        let c = (0
            | 0xff000000 //(0x80 << 24) // alpha // FIXME: shift term still generates invalid code
            | (t+(x^y^(rand()&0x40)) << 16) // blue
            | (y << 8) // green
            | x // red
            );

        buf(y*width+x) = c as u32;
    }
}

