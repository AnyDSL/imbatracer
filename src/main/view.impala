struct View
{
    origin : Point,
    forward : Vec,
    up : Vec,
    right : Vec,
    originalUp : Vec,
    rightFactor : float,
    upFactor : float
}

fn viewEx(origin : Point, forward : Vec, up : Vec, upFactor : float, rightFactor : float) -> View
{
    let mut v = View{ origin : origin, forward : forward, up : up, upFactor : upFactor, rightFactor : rightFactor,
        right : vec0(), originalUp : up
    };
    @viewNormalize(&v);
    v
}

fn view(origin : Point, forward : Vec, up : Vec) -> View
{
    @viewEx(origin, forward, up, 1.0f, 1.0f)
}

fn view1(pos : Point) -> View
{
    @view(pos, vec(0.0f, 0.0f, 1.0f), vec(0.0f, 1.0f, 0.0f))
}

fn view0() -> View
{
    @view1(point0())
}

// re-establish the invariants of the view, by computing the up and right vector appropriately
fn viewNormalize(mut v : &View) -> ()
{
    let u = v.originalUp;
    let fnorm = @normalize(v.forward);
    v.forward = fnorm;

    let t = @orthogonalize(fnorm, u); // (ortho, third)
    v.up = @vfmul(t(0), v.upFactor);
    v.right = @vfmul(t(1), v.rightFactor);
}

fn viewSetForward(mut v : &View, f : Vec) -> ()
{
    v.forward = f;
    @viewNormalize(v)
}

fn viewSetLookAt(v : &View, at : Point) -> ()
{
    @viewSetForward(v, to(v.origin, at))
}

fn viewSetUp(mut v : &View, up : Vec) -> ()
{
    v.originalUp = up;
    @viewNormalize(v)
}

fn viewSetScale(mut v : &View, upFactor : float, rightFactor : float) -> ()
{
    v.rightFactor = rightFactor;
    v.upFactor = upFactor;
    @viewNormalize(v);
}

fn viewSetOpeningAngle(v : &View, vertical : float, horiz : float) -> ()
{
    @viewSetScale(v, tanf(vertical / 2.0f), tanf(horiz / 2.0f));
}

fn viewSetOpeningAngleWithAspectRatio(v : &View, vertical : float, aspect : float) -> ()
{
    let a = tanf(vertical / 2.0f);
    @viewSetScale(v, a, a*aspect);
}


