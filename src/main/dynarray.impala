
struct DynArray {
    data: &[u8],
    name: &[u8],
    elemSize: uint,
    size: uint,
    capacity: uint,
}
static DynArray_SIZEOF = 2u*pointer_SIZEOF + 3u*uint_SIZEOF + 4u; // omg padding...

fn dynArray(elemSize: uint, name: &[u8]) -> DynArray
{
    @dynArrayInit(elemSize, 0u, name)
}
fn dynArrayInit(elemSize : uint, initialCap : uint, name: &[u8]) -> DynArray
{
    let mut a:DynArray;
    dynArrayInitInplace(&a, elemSize, initialCap, name);
    a
}

fn dynArrayLoad(elemSize : uint, ptr : &u8, size : uint, name: &[u8]) -> DynArray
{
    let mut a:DynArray;
    dynArrayLoadInplace(&a, elemSize, ptr, size, name);
    a
}

fn dynArrayInitInplace(mut a : &DynArray, elemSize : uint, initialCap : uint, name: &[u8]) -> ()
{
    @assert(||{elemSize > 0u}, "dynArrayInitInplace: Can't store objects with size 0");
    a.elemSize = elemSize;
    a.data = (0 as &[u8]);
    a.name = name;
    a.size = 0u;
    a.capacity = 0u;
    _dynArrayEnsureCapacity(a, initialCap);
}

fn dynArrayLoadInplace(mut a : &DynArray, elemSize : uint, ptr : &u8, size : uint, name: &[u8]) -> ()
{
    @assert(||{elemSize > 0u}, "dynArrayLoadInplace: Can't load array with objects of size 0");
    a.elemSize = elemSize;
    a.data = (ptr as &[u8]);
    a.name = name;
    a.size = size;
    a.capacity = size;
}

fn dynArrayClear(mut a : &DynArray) -> ()
{
    thorin_free(a.data as &u8);
    a.data = (0 as &[u8]);
    a.size = 0u;
    a.capacity = 0u;
}

fn _dynArrayEnsureCapacity(a : &DynArray, cap : uint) -> ()
{
    if(a.capacity < cap)
    {
        let newCap = 10u + umax(a.capacity + a.capacity / 2u, cap + cap / 4u); // heuristics
        _dynArrayExpand(a, newCap);
    }
}

fn _dynArrayExpand(mut a : &DynArray, newCap : uint) -> ()
{
    let newBytes = newCap * a.elemSize;
    let newData = ~[newBytes:u8];
    memcpy(newData as &u8, a.data as &u8, (a.size * a.elemSize) as size_t);
    thorin_free(a.data as &u8);
    a.data = newData;
    a.capacity = newCap;
}

fn dynArrayReserve(a : &DynArray, cap : uint) -> ()
{
    _dynArrayEnsureCapacity(a, cap);
}

fn dynArrayResize(mut a : &DynArray, newSize : uint) -> ()
{
    _dynArrayEnsureCapacity(a, newSize);
    a.size = newSize;
}

fn dynArraySize(a : &DynArray) -> uint
{
    a.size
}
fn dynArrayData(a: &DynArray) -> &[u8]
{
    a.data
}

// append an entry to the array, return its index
fn dynArrayAppend(mut a: &DynArray, obj: &u8) -> uint
{
    let newSize = a.size + 1u;
    $_dynArrayEnsureCapacity(a, newSize);

    let wpos = a.size * a.elemSize;
    memcpy(&a.data(wpos) as &u8, obj as &u8, a.elemSize as size_t);
    a.size = newSize;
    newSize-1u
}

fn dynArrayFetch(mut a: &DynArray, idx: uint) -> &u8
{
    //print_ssi("Accessing <name> at <pos>: ", a.name, idx as int);
    @assert(||{idx < a.size}, "dynArrayFetch: DynArray out of bounds!");
    &a.data(idx*a.elemSize)
}



// specialized helper functions
fn dynArrayAppendUint(a: &DynArray, mut u: uint) -> uint
{
    @dynArrayAppend(a, &u as &u8)
}
fn dynArrayFetchUint(a: &DynArray, idx: uint) -> uint
{
    *(@dynArrayFetch(a, idx) as &uint)
}
