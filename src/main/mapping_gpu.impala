extern "C" {
    // HACK
    fn magic_uint_array_id(&[uint]) -> &[uint];
}

fn renderIteration(width : int, height : int, measureTime : bool, state : &State, setcolor: SetColorFn, getcolor: GetColorIFn ) -> ()
{
    let unroll = 1;
    let block  = (32, 4, 1);
    let grid   = (@round_up(width, block(0)), @round_up(div_round_up(height, unroll), block(1)), 1);

    // extract the stuff we need
    let cam:Cam = (*state).cam;
    let integrator:Integrator = (*state).integrator;

    let verts = (*state).scene.verts;
    let triVerts = (*state).scene.triVerts;

    let normals = (*state).scene.normals;
    let texcoords = (*state).scene.texcoords;
    let materials = (*state).scene.materials;
    let textures = (*state).scene.textures;
    let triData = (*state).scene.triData;

    let bvhNodes = (*state).scene.bvhNodes;

    let objs = (*state).scene.objs;
    let nObjs = (*state).scene.nObjs;

    let lights = (*state).scene.lights;
    let nLights = (*state).scene.nLights;

    // FIXME measure rendering time
    acc(@acc_dev(), grid, block, || -> () {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let mut scratch = @emptyScratch(); // scratch space for the current intersection
        let mut rtstate = RTState { cam:cam, integrator:integrator,
                                    scene:Scene { verts:verts, triVerts:magic_uint_array_id(triVerts),
                                                  normals:normals, texcoords:texcoords, materials:materials, textures:textures, triData:magic_uint_array_id(triData),
                                                  bvhNodes:bvhNodes, objs:objs, nObjs:nObjs,
                                                  lights:lights, nLights:nLights} };

        for i in @range(0, unroll) {
            let x = gid_x;
            let y = gid_y + i * acc_bdimy();
            if x < width && y < height {
                @setcolor(x, y, @getcolor(x, y, &rtstate, &scratch));
            }
        }
    });
}

fn assert(f : fn() -> bool, msg : &[u8]) -> ()
{
}
