fn renderIteration(width : int, height : int, measureTime : bool, state : &State, body : fn(int, int, &RTState, &RTScratch) -> () ) -> ()
{
    let unroll = 1;
    let block = (32, 4, 1);
    let dim = (@round_up(width, block(0)), @round_up(div_round_up(height, unroll), block(1)), 1);

    // extract the stuff we need
    let cam = (*state).cam;
    let integrator = (*state).integrator;
    let verts = (*state).scene.verts;
    let normals = (*state).scene.normals;
    let triVerts = (*state).scene.triVerts;
    let triNormals = (*state).scene.triNormals;
    let bvhNodes = (*state).scene.bvhNodes;
    let objs = (*state).scene.objs;
    let nObjs = (*state).scene.nObjs;

    // FIXME measure rendering time
    acc(@acc_dev(), dim, block, || -> () {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let mut scratch = @emptyScratch(); // scratch space for the current intersection
        let mut rtstate = RTState { cam:cam, integrator:integrator,
                                    scene:Scene { verts:verts, normals:normals, triVerts:triVerts, triNormals:triNormals, bvhNodes:bvhNodes, objs:objs, nObjs:nObjs } };

        for i in @range(0, unroll) {
            let x = gid_x;
            let y = gid_y + i * acc_bdimy();
            if x < width && y < height {
                @body(x, y, &rtstate, &scratch);
            }
        }
    });
}

fn assert(f : fn() -> bool, i : int) -> ()
{
}
