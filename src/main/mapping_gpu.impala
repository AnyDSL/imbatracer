fn renderIteration(width : int, height : int, measureTime : bool, state : &State, body : fn(int, int, &RTState, &RTScratch) -> () ) -> ()
{
    let unroll = 1;
    let block = (32, 4, 1);
    let dim = (@round_up(width, block(0)), @round_up(div_round_up(height, unroll), block(1)), 1);

    // extract the stuff we need
    let cam:Cam = (*state).cam;
    let integrator:Integrator = (*state).integrator;

    let verts = (*state).scene.verts;
    let triVerts = (*state).scene.triVerts;

    let normals = (*state).scene.normals;
    let texcoords = (*state).scene.texcoords;
    let materials = (*state).scene.materials;
    let triData = (*state).scene.triData;

    let bvhNodes = (*state).scene.bvhNodes;

    let objs = (*state).scene.objs;
    let nObjs = (*state).scene.nObjs;

    let lights = (*state).scene.lights;
    let nLights = (*state).scene.nLights;

    // FIXME measure rendering time
    acc(@acc_dev(), dim, block, || -> () {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let mut scratch = @emptyScratch(); // scratch space for the current intersection
        let mut rtstate = RTState { cam:cam, integrator:integrator,
                                    scene:Scene { verts:verts, triVerts:triVerts,
                                                  normals:normals, texcoords:texcoords, materials:materials, triData:triData,
                                                  bvhNodes:bvhNodes, objs:objs, nObjs:nObjs,
                                                  lights:lights, nLights:nLights} };

        for i in @range(0, unroll) {
            let x = gid_x;
            let y = gid_y + i * acc_bdimy();
            if x < width && y < height {
                @body(x, y, &rtstate, &scratch);
            }
        }
    });
}

fn assert(f : fn() -> bool, i : int) -> ()
{
}
