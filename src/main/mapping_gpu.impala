extern "C" {
    // HACK to prevent thorin from assembling the structs already on the CPU
    fn magic_uint_array_id(&[uint]) -> &[uint];
    fn magic_instance_array_id(&[RTInstance]) -> &[RTInstance];
    fn magic_light_array_id(&[Light]) -> &[Light];
}

fn renderIteration(width: int, height: int, measureTime: bool, state: &State, setcolor: SetColorFn, getcolor: GetColorIFn) -> () {
    let unroll = 1;
    let block  = (32, 4, 1);
    let grid   = (round_up(width as uint, block(0) as uint) as int, round_up(div_round_up(height as uint, unroll as uint), block(1) as uint) as int, 1); // casts curtsey to Max... :P

    // extract the stuff we need. This is a HACK, it breaks all the abstraction - but it's necessary to make thorin copy the stuff to the GPU correctly.
    let cam: Cam = state.cam;
    let integrator: Integrator = state.integrator;

    let verts = state.scene.meshes.verts;
    let triVerts = state.scene.meshes.triVerts;
    let normals = state.scene.meshes.normals;
    let texCoords = state.scene.meshes.texCoords;
    let triData = state.scene.meshes.triData;

    let bvhMeshesRoots = state.scene.bvhMeshes.roots;
    let bvhMeshesNodes = state.scene.bvhMeshes.nodes;

    let objects = state.scene.objects.insts;

    let bvhOuterRoots = state.scene.bvhOuter.roots;
    let bvhOuterNodes = state.scene.bvhOuter.nodes;

    let materials = state.scene.shadingData.materials;
    let textures = state.scene.shadingData.textures;
    let lights = state.scene.shadingData.lights;
    let nLights = state.scene.shadingData.nLights;

    // TODO measure rendering time
    acc(acc_dev(), grid, block, || -> () @{
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        // re-assemble everything
        let scene = RTScene { meshes : RTTris { verts : verts, triVerts : magic_uint_array_id(triVerts), normals : normals, texCoords : texCoords, triData : triData },
                              bvhMeshes : RTBVHTrees { roots : magic_uint_array_id(bvhMeshesRoots), nodes : bvhMeshesNodes },
                              objects : RTInstances { insts : magic_instance_array_id(objects) },
                              bvhOuter : RTBVHTrees { roots : magic_uint_array_id(bvhOuterRoots), nodes : bvhOuterNodes },
                              shadingData : RTShadingData { materials : materials, textures : textures, lights : magic_light_array_id(lights), nLights : nLights },
                            };
        let mut rtstate = RTState { cam : cam, integrator : integrator, scene : scene };

        for i in range(0, unroll) {
            let x = gid_x;
            let y = gid_y + i * acc_bdimy();
            if x < width && y < height @{
                setcolor(x, y, getcolor(x, y, &rtstate));
            }
        }
    });
}
