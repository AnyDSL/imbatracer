struct BBox
{
    cmin : Point,
    cmax : Point
}
static BBox_SIZEOF = 2u*Point_SIZEOF;

fn bboxUnsafe(a : Point, b : Point) -> BBox
{
    BBox{ cmin:a, cmax:b }
}

fn bbox(a : Point, b : Point) -> BBox
{
    bboxUnsafe(@ppmin(a, b), @ppmax(a, b))
}

fn bboxEmpty() -> BBox
{
    BBox{ cmin:@point1(FLT_MAX), cmax:@point1(-FLT_MAX) }
}

fn bbextend(bb : BBox, p : Point) -> BBox
{
    @bbox(@ppmin(bb.cmin, p), @ppmax(bb.cmax, p))
}

fn bbextendb(bb : BBox, bb2 : BBox) -> BBox
{
    @bbextend(@bbextend(bb, bb2.cmin), bb2.cmax)
}

fn bboxCentroid(bb: BBox) -> Point
{
    @ppapply2(bb.cmin, bb.cmax, |a, b|(a+b)/2.0f)
}

fn bboxLongestAxis(bb: BBox) -> uint
{
    @vecLongestAxis(@bbdiag(bb))
}

fn bbsurface(bb: BBox) -> float
{
    let xlen = bb.cmax.x-bb.cmin.x;
    let ylen = bb.cmax.y-bb.cmin.y;
    let zlen = bb.cmax.z-bb.cmin.z;
    2.0f*(xlen*ylen + xlen*zlen + ylen*zlen)
}
fn bbdiag(bb: BBox) -> Vec
{
    @to(bb.cmin, bb.cmax)
}
