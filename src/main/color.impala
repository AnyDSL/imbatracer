struct Color
{
    r : float,
    g : float,
    b : float
}

struct XYZ
{
    x : float,
    y : float,
    z : float,
}

fn color(r : float, g : float, b : float) -> Color
{
    Color{ r:r, g:g, b:b }
}

fn color1(c : float) -> Color
{
    color(c, c, c)
}

fn color0() -> Color
{
    color1(0.0f)
}

fn capply1(c: Color, f: fn(float) -> float) -> Color
{
    color(f(c.r), f(c.g), f(c.b))
}

fn cfapply2(c: Color, v : float, f: fn(float, float) -> float) -> Color
{
    color(f(c.r, v), f(c.g, v), f(c.b, v))
}

fn ccapply2(c: Color, d : Color, f: fn(float, float) -> float) -> Color
{
    color(f(c.r, d.r), f(c.g, d.g), f(c.b, d.b))
}

fn cmul(a : Color, v : float) -> Color { cfapply2(a, v, mul) }
fn cdiv(a : Color, v : float) -> Color { cfapply2(a, v, div) }
fn cadd(a : Color, v : float) -> Color { cfapply2(a, v, add) }
fn ccadd(a : Color, b : Color) -> Color { ccapply2(a, b, add) }

fn clerp(c1 : Color, c2 : Color, t : float) -> Color
{
    color(lerp(c1.r, c2.r, t),
          lerp(c1.g, c2.g, t),
          lerp(c1.b, c2.b, t))
}

fn cAny(c : Color, f : fn(float) -> bool) -> bool
{
    f(c.r) || f(c.g) || f(c.b) // FIXME: the sequential-or semantics might be a problem here. Maybe faster if just evaluating all.
}

fn cclamp01(c : Color) -> Color
{
    @capply1(c, clamp01f)
}

fn col_rgb2int(c : Color) -> u32
{
     0xff000000u32
     | ((((clamp01f(c.b)*255.0f) as int) as u32)<< 16u32)
     | ((((clamp01f(c.g)*255.0f) as int) as u32)<< 8u32 )
     | ((((clamp01f(c.r)*255.0f) as int) as u32)        )
}

fn col_toXYZ(c : Color) -> XYZ
{
    let cv = @vec(c.r, c.g, c.b);
    XYZ{
        x: @dot(cv, vec(0.412453f, 0.357580f, 0.180423f)),
        y: @dot(cv, vec(0.212671f, 0.715160f, 0.072169f)),
        z: @dot(cv, vec(0.019334f, 0.119193f, 0.950227f))
    }
}

fn colorDistXYZ(a : XYZ, b : XYZ) -> float
{
    let dx = fabsf(a.x - b.x);
    let dy = fabsf(a.y - b.y);
    let dz = fabsf(a.z - b.z);
    dx + dy + dz
}
