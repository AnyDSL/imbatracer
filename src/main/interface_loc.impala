// provide some APIs to C
extern fn impala_noIdx() -> uint
{
    noIdx
}
extern fn impala_constantTexture(mut tex: &Texture, r: float, g: float, b: float) -> ()
{
    *tex = constantTexture(@color(r, g, b));
}
extern fn impala_dummyMaterial(mut mat: &Material) -> ()
{
    *mat = dummyMaterial();
}
extern fn impala_sceneAddTexture(scene: &Scene, tex: &Texture) -> uint
{
    sceneAddTexture(scene, tex)
}
extern fn impala_sceneAddMaterial(scene: &Scene, mat: &Material) -> uint
{
    sceneAddMaterial(scene, mat)
}

extern fn impala_trisAppendVertex(tris: &Tris, x: float, y: float, z: float) -> uint
{
    trisAddVertex(tris, @point(x, y, z))
}
extern fn impala_trisNumVertices(tris: &Tris) -> uint
{
    trisNumVertices(tris)
}
extern fn impala_trisAppendNormal(tris: &Tris, x: float, y: float, z: float) -> uint
{
    trisAddNormal(tris, @vec(x, y, z))
}
extern fn impala_trisNumNormals(tris: &Tris) -> uint
{
    trisNumNormals(tris)
}
extern fn impala_trisAppendTexCoord(tris: &Tris,x: float, y: float) -> uint
{
    trisAddTexCoord(tris, @texCoord(x, y))
}
extern fn impala_trisNumTexCoords(tris: &Tris) -> uint
{
    trisNumTexCoords(tris)
}
extern fn impala_trisAppendTriangle(tris: &Tris, p1: uint, p2: uint, p3: uint, n1: uint, n2: uint, n3: uint, t1: uint, t2: uint, t3: uint, mat: uint) -> ()
{
    trisAddTri(tris, p1, p2, p3, n1, n2, n3, t1, t2, t3, mat)
}

// initialize the scene, return an opaque pointer
extern fn impala_init() -> &State
{
    let mut state = stateInit();

    // initialise integrator
    state.integrator.itype = 1; //4:debug, 2:recraytrace, 1:raytrace, 0:cosine
    state.integrator.mode = 1;
    state.integrator.minDist = 0.0f;
    state.integrator.maxDist = 1.0f;
    state.integrator.maxRecDepth = 6u;

    // initialise scene
    let mut scene = @sceneInit();

    let mut cxtex = checkerboardTexture2D(color0(), color1(1.0f));

    let turbnoise = Noise{ ty:2, octaves:3u, amplitude:0.8f, freq:0.6f, persistence:0.8f };
    let slownoise = Noise{ ty:1, octaves:2u, amplitude:0.6f, freq:0.14f, persistence:0.5f };
    let mut turbtex = noiseTexture(color(0.0f, 0.3f, 0.6f), color(0.8f, 1.0f, 0.7f), turbnoise);
    let mut slowtex = noiseTexture(color(0.2f, 0.0f, 0.0f), color(0.7f, 0.3f, 0.0f), slownoise);
    let mut phongtex = constantTexture(color(1.0f, 0.1f, 0.2f));

    let turbtexID = sceneAddTexture(&scene, &turbtex);
    let slowtexID = sceneAddTexture(&scene, &slowtex);
    let cxtexID = sceneAddTexture(&scene, &cxtex);
    let phtexID = sceneAddTexture(&scene, &phongtex);

    let mut cxmat = Material{ diffuse:cxtexID, specular:0u, emissive:0u, specExp:-1.0f, sampling:SAMPLING_NOT_NEEDED, eta:0.0f, etaSqrKappaSqr:0.0f };
    let mut turbmat = Material{ diffuse:turbtexID, specular:phtexID, emissive:0u, specExp:1.6f,  sampling:SAMPLING_NOT_NEEDED, eta:0.0f, etaSqrKappaSqr:0.0f };
    let mut mirrormat = silverMirrorMaterial();
    mirrormat.sampling = SAMPLING_SECONDARY;
    mirrormat.specular = phtexID;
    mirrormat.diffuse = slowtexID;

    let turbmatID = sceneAddMaterial(&scene, &turbmat);
    let mut matOverrides = @dynArray(Material_SIZEOF, "matOverrides");
    dynArrayAppend(&matOverrides, &turbmat as &u8);
    dynArrayAppend(&matOverrides, &cxmat as &u8);

    /*let mut mats = [
        turbmat,
        cxmat,
    ];

    scene_add_cube(state, 120.0f, &mirrormat);

    scene_add_file_mat(state, 2, 0, &mats, 2u);
    scene_build(state);

    */

    //let mut cube = trisCreateCube(10.0f, turbmatID);
    //let cubeIdx = sceneAddMesh(&scene, &cube);
    print_s("Adding a mesh now");
    let revisionIdx = sceneAddMeshFromFile(&scene, "models/", "teapot.obj", /*Flags*/0u, /*Materials*/&matOverrides);
    sceneAddObjectSimple(&scene, revisionIdx);

    @dynArrayClear(&matOverrides);

    // add some light
    let intens = 4.1f;
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*500.0f)));
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*100.0f)));
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*300.0f, intens*300.0f, intens*300.0f)));

    // finalize scene
    sceneCompile(&scene, &state.scene);
    print_s("Your state is ready!");
    return(state)
}

// update the scene, based on the opaque pointer returned by impala_init
extern fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = state.time;
    state.time = time + dt;

    // initialise camera
    let scale = 10.0f;
    let pos = @point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);


    // put light right where the cam was shortly ago, and on the other side
    state.scene.shadingData.lights(0).pos = @point(-3.5f*scale*sinf(time-0.5f), +1.2f*scale*sinf(0.2f*time-0.5f), +3.7f*scale*cosf(time-0.5f));
    state.scene.shadingData.lights(1).pos = @point(-3.5f*scale*sinf(time+0.5f), +1.9f*scale*sinf(0.2f*time+0.5f), +3.7f*scale*cosf(time+0.5f));
    state.scene.shadingData.lights(2).pos = @point(-3.5f*scale*sinf(time+0.5f+pi), +2.2f*scale*sinf(0.2f*time+0.5f+pi), +3.7f*scale*cosf(time+0.5f+pi));

    // scale our teapot
    /*let potScale = (fabsf(sinf(0.8f*time))/2.0f+0.5f);
    state.scene.objs(0).w2o = @matrix_scalingv(@vec(potScale, 1.0f, 1.2f*potScale));
    state.scene.objs(0).swapsHandedness = false;*/
}

extern fn impala_init_bench1() -> &State
{
    let mut state = ~[1:State] as &State;
    state.integrator.itype = 0;

    /*scene_add_file(state, 3, /*IgnoreTexCoord | IgnoreNormals | IgnoreMatLibs* /7);
    scene_build(state);

    let scale = 40.0f;
    let pos = @point(-3.5f*scale, 1.2f*scale, 3.7f*scale);
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);*/

    return(state)
}

extern fn impala_init_bench2() -> &State
{
    let mut state = ~[1:State] as &State;
    state.integrator.itype = 1;

    //scene_add_file(state, 2, 0);
    //scene_build(state);

    // add point lights
    /*let mut lights = ~[3:Light];
    let intens = 4.1f;
    lights(0) = @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*500.0f));
    lights(1) = @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*100.0f));
    lights(2) = @pointLight(point0(), color(intens*300.0f, intens*300.0f, intens*300.0f));
    state.scene.nLights = 3u;
    state.scene.lights = lights;

    let time = 44.05f;
    let scale = 8.0f;
    let pos = @point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);

    // put light right where the cam was shortly ago, and on the other side
    state.scene.lights(0).pos = @point(-3.5f*scale*sinf(time-0.5f), +1.2f*scale*sinf(0.2f*time-0.5f), +3.7f*scale*cosf(time-0.5f));
    state.scene.lights(1).pos = @point(-3.5f*scale*sinf(time+0.5f), +1.9f*scale*sinf(0.2f*time+0.5f), +3.7f*scale*cosf(time+0.5f));
    state.scene.lights(2).pos = @point(-3.5f*scale*sinf(time+0.5f+pi), +2.2f*scale*sinf(0.2f*time+0.5f+pi), +3.7f*scale*cosf(time+0.5f+pi));*/

    return(state)
}

extern fn impala_finish(mut state: &State) -> ()
{
    @sceneFree(&state.scene);
    thorin_free(state as &u8);
}
