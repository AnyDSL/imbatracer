// provide some APIs to C
extern fn impala_noIdx() -> uint
{
    noIdx
}
extern fn impala_constantTexture(mut tex: &Texture, r: float, g: float, b: float) -> ()
{
    *tex = constantTexture(@color(r, g, b));
}
extern fn impala_dummyMaterial(mut mat: &Material) -> ()
{
    *mat = dummyMaterial();
}
extern fn impala_sceneAddTexture(scene: &Scene, tex: &Texture) -> uint
{
    sceneAddTexture(scene, tex)
}
extern fn impala_sceneAddMaterial(scene: &Scene, mat: &Material) -> uint
{
    sceneAddMaterial(scene, mat)
}

extern fn impala_trisAppendVertex(tris: &Tris, x: float, y: float, z: float) -> uint
{
    trisAddVertex(tris, @point(x, y, z))
}
extern fn impala_trisNumVertices(tris: &Tris) -> uint
{
    trisNumVertices(tris)
}
extern fn impala_trisAppendNormal(tris: &Tris, x: float, y: float, z: float) -> uint
{
    trisAddNormal(tris, @vec(x, y, z))
}
extern fn impala_trisNumNormals(tris: &Tris) -> uint
{
    trisNumNormals(tris)
}
extern fn impala_trisAppendTexCoord(tris: &Tris,x: float, y: float) -> uint
{
    trisAddTexCoord(tris, @texCoord(x, y))
}
extern fn impala_trisNumTexCoords(tris: &Tris) -> uint
{
    trisNumTexCoords(tris)
}
extern fn impala_trisAppendTriangle(tris: &Tris, p1: uint, p2: uint, p3: uint, n1: uint, n2: uint, n3: uint, t1: uint, t2: uint, t3: uint, mat: uint) -> ()
{
    trisAddTri(tris, p1, p2, p3, n1, n2, n3, t1, t2, t3, mat)
}

static EVT_KEY = 0u;
static EVT_MOUSEMOVE = 1u;
static EVT_MOUSEBUTTON = 2u;
static EVT_MOUSEWHEEL = 3u;

extern fn impala_event(state : &State, grabbed : bool, evt : uint, down : bool, key : int, x : float, y : float) -> ()
{
    if !grabbed
    {
        return()
    }

    let cc = state.camctrl as &CamController;

    if evt == EVT_KEY
    {
        camControllerKeyInput(cc, key, down);
    }
    else if evt == EVT_MOUSEMOVE
    {
        camControllerMouseMove(cc, x, y);
    }
    else if evt == EVT_MOUSEBUTTON
    {
        camControllerMouseButton(cc, key, down);
    }
    // TODO: wheel?

}

// initialize the scene, return an opaque pointer
struct MeshIdxs
{
    cube: uint,
    teapot: uint,
}

extern fn impala_init() -> &State
{
    let mut state = stateInit();

    // initialise integrator
    state.integrator.itype = 2; //4:debug, 2:recraytrace, 1:raytrace, 0:cosine
    state.integrator.mode = 1;
    state.integrator.minDist = 0.0f;
    state.integrator.maxDist = 1.0f;
    state.integrator.maxRecDepth = 3u;

    // initial camera placement
    camControllerInit(state, @point(-50.0f, 0.0f, 15.0f), @vec(0.0f, 1.0f, 0.0f), pi / 4.0f, pi / 3.0f);

    // initialise scene
    let mut scene = @sceneInit();

    let mut cxtex = checkerboardTexture2D(color0(), color1(1.0f));

    let turbnoise = Noise{ ty:2, octaves:3u, amplitude:0.8f, freq:0.6f, persistence:0.8f };
    let slownoise = Noise{ ty:1, octaves:2u, amplitude:0.6f, freq:0.14f, persistence:0.5f };
    let mut turbtex = noiseTexture(color(0.0f, 0.3f, 0.6f), color(0.8f, 1.0f, 0.7f), turbnoise);
    let mut slowtex = noiseTexture(color(0.2f, 0.0f, 0.0f), color(0.7f, 0.3f, 0.0f), slownoise);
    let mut phongtex = constantTexture(color(1.0f, 0.1f, 0.2f));

    let turbtexID = sceneAddTexture(&scene, &turbtex);
    let slowtexID = sceneAddTexture(&scene, &slowtex);
    let cxtexID = sceneAddTexture(&scene, &cxtex);
    let phtexID = sceneAddTexture(&scene, &phongtex);

    let cxmat = Material{ diffuse:cxtexID, specular:0u, emissive:0u, specExp:-1.0f, sampling:SAMPLING_NOT_NEEDED, eta:0.0f, etaSqrKappaSqr:0.0f };
    let mut turbmat = Material{ diffuse:turbtexID, specular:phtexID, emissive:0u, specExp:1.6f,  sampling:SAMPLING_NOT_NEEDED, eta:0.0f, etaSqrKappaSqr:0.0f };
    let mut mirrormat = silverMirrorMaterial();
    mirrormat.sampling = SAMPLING_SECONDARY;
    mirrormat.specular = phtexID;
    mirrormat.diffuse = slowtexID;
    let mut steelmirrormat = steelMirrorMaterial();

    let mirrormatID = sceneAddMaterial(&scene, &mirrormat);
    let steelmirrormatID = sceneAddMaterial(&scene, &steelmirrormat);
    let turbmatID = sceneAddMaterial(&scene, &turbmat);

    // a cube
    let mut cube = trisCreateCube(120.0f, mirrormatID);
    let cubeIdx = sceneAddMesh(&scene, &cube);

    // and a teapot
    let mut matOverrides = [turbmatID, steelmirrormatID, noIdx];
    let teapotIdx = sceneAddMeshFromFileO(&scene, "models/", "teapot.obj", /*Flags*/0u, /*Materials*/&matOverrides);

    // store mesh indices
    state.meshIdxs = ~MeshIdxs{ cube:cubeIdx, teapot:teapotIdx } as &u8;

    // add some light
    let intens = 4.1f;
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*500.0f)));
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*100.0f)));
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*300.0f, intens*300.0f, intens*300.0f)));

    // finalize scene
    sceneCompileMeshes(&scene, &state.scene);
    print_s("Your state is ready!");
    return(state)
}

extern fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = state.time;
    state.time = time + dt;

    // put light right where the cam was shortly ago, and on the other side
    let lightScale = 10.0f;
    state.scene.shadingData.lights(0).pos = @point(-3.5f*lightScale*sinf(time-0.5f), +1.2f*lightScale*sinf(0.2f*time-0.5f), +3.7f*lightScale*cosf(time-0.5f));
    state.scene.shadingData.lights(1).pos = @point(-3.5f*lightScale*sinf(time+0.5f), +1.9f*lightScale*sinf(0.2f*time+0.5f), +3.7f*lightScale*cosf(time+0.5f));
    state.scene.shadingData.lights(2).pos = @point(-3.5f*lightScale*sinf(time+0.5f+pi), +2.2f*lightScale*sinf(0.2f*time+0.5f+pi), +3.7f*lightScale*cosf(time+0.5f+pi));

    // compose scene with the scaling we want
    let meshIdxs = state.meshIdxs as &MeshIdxs;
    let mut objects = instancesInit();
    instancesAppendI(&objects, meshIdxs.cube);
    let potScale = 1.0f/(fabsf(sinf(0.8f*time))/2.0f+0.5f);
    let potSccaleM = @matrixScaling(@vec(potScale, 1.0f, 1.2f*potScale));
    instancesAppend(&objects, meshIdxs.teapot, potSccaleM);
    instancesAppend(&objects, meshIdxs.teapot, @matrixTranslation(@vec(10.0f, 10.0f, -30.0f)));
    instancesAppend(&objects, meshIdxs.teapot, @matrixTranslation(@vec(40.0f, 15.0f*sinf(0.2f*time), 20.0f)));
    sceneCompileObjects(&state.scene, &objects);

    // update camera
    let cc = state.camctrl as &CamController;
    camControllerUpdate(cc, &state.cam, dt);
}

extern fn impala_init_bench1() -> &State
{
    let mut state = stateInit();
    state.integrator.itype = 0;
    let mut scene = @sceneInit();

    // build scene
    let revIdx = sceneAddMeshFromFile(&scene, "models/", "revision.obj", /*Flags: IgnoreTexCoord | IgnoreNormals | IgnoreMatLibs*/7u);
    sceneCompileMeshes(&scene, &state.scene);
    let mut objects = instancesInit();
    instancesAppendI(&objects, revIdx);
    sceneCompileObjects(&state.scene, &objects);

    // init camera
    let scale = 40.0f;
    let pos = @point(-3.5f*scale, 1.2f*scale, 3.7f*scale);
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);

    return(state)
}

extern fn impala_init_bench2() -> &State
{
    let mut state = stateInit();
    state.integrator.itype = 1;
    let mut scene = @sceneInit();

    // add point lights
    let intens = 4.1f;
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*500.0f)));
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*100.0f)));
    sceneAddLightV(&scene, @pointLight(point0(), color(intens*300.0f, intens*300.0f, intens*300.0f)));

    // build scene
    let teapotIdx = sceneAddMeshFromFile(&scene, "models/", "teapot.obj", /*Flags*/0u);
    sceneCompileMeshes(&scene, &state.scene);
    let mut objects = instancesInit();
    instancesAppendI(&objects, teapotIdx);
    sceneCompileObjects(&state.scene, &objects);

    // init camera
    let time = 44.05f;
    let scale = 8.0f;
    let pos = @point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);

    // put light right where the cam was shortly ago, and on the other side
    state.scene.shadingData.lights(0).pos = @point(-3.5f*scale*sinf(time-0.5f), +1.2f*scale*sinf(0.2f*time-0.5f), +3.7f*scale*cosf(time-0.5f));
    state.scene.shadingData.lights(1).pos = @point(-3.5f*scale*sinf(time+0.5f), +1.9f*scale*sinf(0.2f*time+0.5f), +3.7f*scale*cosf(time+0.5f));
    state.scene.shadingData.lights(2).pos = @point(-3.5f*scale*sinf(time+0.5f+pi), +2.2f*scale*sinf(0.2f*time+0.5f+pi), +3.7f*scale*cosf(time+0.5f+pi));

    return(state)
}

extern fn impala_finish(state: &State) -> ()
{
    @stateFree(state);
}
