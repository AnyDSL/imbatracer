

extern fn impala_init(mut state : &State) -> ()
{
    (*state).time = 0.0f;
    (*state).integrator.itype = 1; //4:debug, 1:raytrace
    (*state).integrator.mode = 1;
    (*state).integrator.minDist = 0.0f;
    (*state).integrator.maxDist = 0.0f;

    //scene_add_cube(state, 40.0f);
    scene_add_file(state, 2, 0);
    scene_build(state);

    // add point light
    let mut lights = ~[2:Light];
    let intens = 1.0f;
    lights(0) = @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*400.0f));
    lights(1) = @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*300.0f));
    (*state).scene.nLights = 2u;
    (*state).scene.lights = lights;

}

extern fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = (*state).time;
    (*state).time = time + dt;
    let scale = 10.0f;
    let pos = @point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = @pi() / 4.0f;
    let vertOpenAngle = @pi() / 3.0f;
    (*state).cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);

    // put light right where the cam was shortly ago, and on the other side
    (*state).scene.lights(0).pos = @point(-3.5f*scale*sinf(time-0.5f), +1.2f*scale*sinf(0.2f*time-0.5f), +3.7f*scale*cosf(time-0.5f));
    (*state).scene.lights(1).pos = @point(-3.5f*scale*sinf(time+0.5f), +1.2f*scale*sinf(0.2f*time+0.5f), +3.7f*scale*cosf(time+0.5f));
}

extern fn impala_init_bench1(mut state : &State) -> ()
{
    (*state).integrator.itype = 0;

    scene_add_file(state, 3, /*IgnoreTexCoord | IgnoreNormals | IgnoreMatLibs*/7);
    scene_build(state);

    let scale = 40.0f;
    let pos = @point(-3.5f*scale, 1.2f*scale, 3.7f*scale);
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = @pi() / 4.0f;
    let vertOpenAngle = @pi() / 3.0f;
    (*state).cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);
}
