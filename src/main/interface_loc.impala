extern fn impala_object_init(mut obj : &Object, root : uint) -> ()
{
    obj.bvhRoot = root;
    obj.w2o = @matrix0();
    obj.swapsHandedness = false;
}

extern fn impala_init(mut state : &State) -> ()
{
    state.time = 0.0f;
    state.integrator.itype = 1; //4:debug, 1:raytrace, 0:cosine
    state.integrator.mode = 1;
    state.integrator.minDist = 0.0f;
    state.integrator.maxDist = 1.0f;

    //scene_add_cube(state, 40.0f);

    let mut cxtex = checkerboardTexture2D(color0(), color1(1.0f));

    let turbnoise = Noise{ ty:2, octaves:3u, amplitude:0.8f, freq:0.6f, persistence:0.8f };
    let mut turbtex = noiseTexture(color(0.0f, 0.3f, 0.6f), color(0.8f, 1.0f, 0.7f), turbnoise);
    let mut phongtex = constantTexture(color(1.0f, 0.1f, 0.2f));

    let turbtexID = scene_add_texture(state, &turbtex);
    let cxtexID = scene_add_texture(state, &cxtex);
    let phtexID = scene_add_texture(state, &phongtex);

    let cxmat = Material{ diffuse:cxtexID, specular:0u, emissive:0u, specExp:-1.0f };
    let turbmat = Material{ diffuse:turbtexID, specular:phtexID, emissive:0u, specExp:1.6f};

    let mut mats = [
        turbmat,
        cxmat
    ];

    scene_add_file_mat(state, 2, 0, &mats, 2u);
    scene_build(state);

    // add point light
    let mut lights = ~[3:Light];
    let intens = 4.1f;
    lights(0) = @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*500.0f));
    lights(1) = @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*100.0f));
    lights(2) = @pointLight(point0(), color(intens*300.0f, intens*300.0f, intens*300.0f));
    state.scene.nLights = 3u;
    state.scene.lights = lights;

    state.user1 = (0 as &u8);
}

extern fn impala_update(mut state : &State, dt : float) -> ()
{
    let time = state.time;
    state.time = time + dt;
    let scale = 10.0f;
    let pos = @point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);

    // put light right where the cam was shortly ago, and on the other side
    state.scene.lights(0).pos = @point(-3.5f*scale*sinf(time-0.5f), +1.2f*scale*sinf(0.2f*time-0.5f), +3.7f*scale*cosf(time-0.5f));
    state.scene.lights(1).pos = @point(-3.5f*scale*sinf(time+0.5f), +1.9f*scale*sinf(0.2f*time+0.5f), +3.7f*scale*cosf(time+0.5f));
    state.scene.lights(2).pos = @point(-3.5f*scale*sinf(time+0.5f+pi), +2.2f*scale*sinf(0.2f*time+0.5f+pi), +3.7f*scale*cosf(time+0.5f+pi));

    // scale our teapot
    let potScale = (fabsf(sinf(0.8f*time))/2.0f+0.5f);
    state.scene.objs(0).w2o = @matrix_scalingv(@vec(potScale, 1.0f, 1.2f*potScale));
    state.scene.objs(0).swapsHandedness = false;
}

extern fn impala_init_bench1(mut state : &State) -> ()
{
    state.integrator.itype = 0;

    scene_add_file(state, 3, /*IgnoreTexCoord | IgnoreNormals | IgnoreMatLibs*/7);
    scene_build(state);

    let scale = 40.0f;
    let pos = @point(-3.5f*scale, 1.2f*scale, 3.7f*scale);
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);
}

extern fn impala_init_bench2(mut state : &State) -> ()
{
    state.integrator.itype = 1;

    scene_add_file(state, 2, 0);
    scene_build(state);

    // add point lights
    let mut lights = ~[3:Light];
    let intens = 4.1f;
    lights(0) = @pointLight(point0(), color(intens*500.0f, intens*500.0f, intens*500.0f));
    lights(1) = @pointLight(point0(), color(intens*100.0f, intens*100.0f, intens*100.0f));
    lights(2) = @pointLight(point0(), color(intens*300.0f, intens*300.0f, intens*300.0f));
    state.scene.nLights = 3u;
    state.scene.lights = lights;

    let time = 44.05f;
    let scale = 8.0f;
    let pos = @point(-3.5f*scale*sinf(time), 1.2f*scale*sinf(0.2f*time), 3.7f*scale*cosf(time));
    let at = @point0();
    let up = @vec(0.0f, 1.0f, 0.0f);
    let horzOpenAngle = pi / 4.0f;
    let vertOpenAngle = pi / 3.0f;
    state.cam = @camPerspectiveLookAt(pos, at, up, horzOpenAngle, vertOpenAngle);

    // put light right where the cam was shortly ago, and on the other side
    state.scene.lights(0).pos = @point(-3.5f*scale*sinf(time-0.5f), +1.2f*scale*sinf(0.2f*time-0.5f), +3.7f*scale*cosf(time-0.5f));
    state.scene.lights(1).pos = @point(-3.5f*scale*sinf(time+0.5f), +1.9f*scale*sinf(0.2f*time+0.5f), +3.7f*scale*cosf(time+0.5f));
    state.scene.lights(2).pos = @point(-3.5f*scale*sinf(time+0.5f+pi), +2.2f*scale*sinf(0.2f*time+0.5f+pi), +3.7f*scale*cosf(time+0.5f+pi));
}
