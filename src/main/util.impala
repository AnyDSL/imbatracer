

fn range(a : int, b : int, yield : fn(int, fn()))
-> ()
{
    if a < b {
        yield(a);
        range(a+1, b, yield, return)
    }
}

fn urange(a : uint, b : uint, yield : fn(uint, fn()))
-> ()
{
    if a < b {
        yield(a);
        urange(a+1u, b, yield, return)
    }
}

fn fwhile(yield: fn() -> bool) -> ()
{
    if yield() {
        fwhile(yield, return)
    }
}

fn min(a : float, b : float) -> float
{
    if a < b { a } else { b }
}

fn max(a : float, b : float) -> float
{
    if a < b { b } else { a }
}

fn clamp(lower : float, val : float, upper : float) -> float
{
    min(upper, max(lower, val))
}

fn clamp01f(val : float) -> float
{
    @clamp(0.0f, val, 1.0f)
}


fn mul(a : float, b : float) -> float { a * b }
fn div(a : float, b : float) -> float { a / b }
fn add(a : float, b : float) -> float { a + b }
fn sub(a : float, b : float) -> float { a - b }
fn less(a : float, b : float) -> bool { a < b }

fn almost(a : float, b : float) -> bool
{
    fabsf(a - b) < 0.00001f
}

fn lerp(a : float, b : float, t : float) -> float
{
    a * (1.0f - t) + b * t
}

// Scale a range to a range, linearly
fn scaleLin(v : float, vMin : float, vMax : float, targetMin : float, targetMax : float) -> float
{
	let f = clamp(vMin, v, vMax);
	let d = vMax-vMin;
	if d == 0.0f { vMin } else { lerp((f-vMin)/d, targetMin, targetMax) }
}

/*
fn pos_infinity() -> float
{
    1.0f/0.0f
}

fn neg_infinity() -> float
{
    -1.0f/0.0f
}
*/

fn M_PI() -> float
{
    3.141592653589793f
}





