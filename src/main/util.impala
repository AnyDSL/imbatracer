
fn rangestep(a : int, b : int, step : int, yield : fn(int, fn()))
-> ()
{
    if a < b {
        yield(a); // TODO adding an @ here OR below makes stuff go SLOWER! ?!?
        rangestep(a+step, b, step, yield, return)
    }
}


fn range(a : int, b : int, yield : fn(int, fn()))
-> ()
{
    if a < b {
        yield(a); // TODO adding an @ here OR below makes stuff go SLOWER! ?!?
        range(a+1, b, yield, return)
    }
}


fn urangestep(a : uint, b : uint, step : uint, yield : fn(uint, fn()))
-> ()
{
    if a < b {
        yield(a); // TODO adding an @ here OR below makes stuff go SLOWER! ?!?
        urangestep(a+step, b, step, yield, return)
    }
}

fn urange(a : uint, b : uint, yield : fn(uint, fn()))
-> ()
{
    if a < b {
        yield(a); // TODO adding an @ here OR above makes stuff go SLOWER! ?!?
        urange(a+1u, b, yield, return)
    }
}

fn ever1(a : uint, yield: fn(uint) -> uint) -> uint
{
    let b = @yield(a);
    ever1(b, yield, return)
}

fn imin(a : int, b : int) -> int
{
    if a < b { a } else { b }
}

fn imax(a : int, b : int) -> int
{
    if a < b { b } else { a }
}

fn umin(a : uint, b : uint) -> uint
{
    if a < b { a } else { b }
}

fn umax(a : uint, b : uint) -> uint
{
    if a < b { b } else { a }
}

fn min(a : float, b : float) -> float
{
    if a < b { a } else { b }
}

fn max(a : float, b : float) -> float
{
    if a < b { b } else { a }
}

fn clamp(lower : float, val : float, upper : float) -> float
{
    min(upper, max(lower, val))
}

fn clamp01f(val : float) -> float
{
    @clamp(0.0f, val, 1.0f)
}


fn mul(a : float, b : float) -> float { a * b }
fn div(a : float, b : float) -> float { a / b }
fn add(a : float, b : float) -> float { a + b }
fn sub(a : float, b : float) -> float { a - b }
fn less(a : float, b : float) -> bool { a < b }
fn neg(a : float) -> float { -a }
fn sqr(a : float) -> float { a*a }
fn isneg(a : float) -> bool { a < 0.0f }
fn isstrictpos(a : float) -> bool { a > 0.0f }

fn almost(a : float, b : float) -> bool
{
    fabsf(a - b) < epsilon
}

fn lerp(a : float, b : float, t : float) -> float
{
    a * (1.0f - t) + b * t
}

fn lerp2d(px0y0 : float, px1y0 : float, px0y1 : float, px1y1 : float, xWeight : float, yWeight : float) -> float
{
	let a = @lerp(px0y0, px1y0, xWeight);
	let b = @lerp(px0y1, px1y1, xWeight);
	@lerp(a, b, yWeight)
}

fn lerp3d(px0y0z0 : float, px1y0z0 : float, px0y1z0 : float, px1y1z0 : float, px0y0z1 : float, px1y0z1 : float, px0y1z1 : float, px1y1z1 : float,
	xPoint : float, yPoint : float, zPoint : float) -> float
{
    let a = @lerp2d(px0y0z0, px1y0z0, px0y1z0, px1y1z0, xPoint, yPoint);
    let b = @lerp2d(px0y0z1, px1y0z1, px0y1z1, px1y1z1, xPoint, yPoint);
    @lerp(a, b, zPoint)
}

// Scale a range to a range, linearly
fn scaleLin(v : float, vMin : float, vMax : float, targetMin : float, targetMax : float) -> float
{
	let d = vMax-vMin;
	if d == 0.0f { vMin } else { @lerp(targetMin, targetMax, (@clamp(vMin, v, vMax)-vMin)/d) }
}

fn fractional(v : float) -> float
{
    v - floorf(v)
}

fn absfractional(v : float) -> float
{
    @fabsf(fractional(v))
}

/*
fn pos_infinity() -> float
{
    1.0f/0.0f
}

fn neg_infinity() -> float
{
    -1.0f/0.0f
}
*/

static pi:float = 3.141592653589793f;
static epsilon:float = 1e-5f;
static FLT_MAX:float = 3.402823e+38f;


fn isDebug() -> bool
{
    false || true
}


fn bool2int(b : bool) -> int
{
    if b {1} else {0}
}

fn bool2uint(b : bool) -> uint
{
    if b {1u} else {0u}
}

// only works for positive numbers!
fn div_round_up(a : uint, b : uint) -> uint
{
    (a+b-1u)/b
}

// only works for positive numbers!
fn round_up(a : uint, b : uint) -> uint
{
    div_round_up(a, b)*b
}
