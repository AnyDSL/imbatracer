

fn range(a : int, b : int, yield : fn(int, fn()))
-> ()
{
    if a < b {
        yield(a); // TODO adding an @ here OR below makes stuff go SLOWER! ?!?
        range(a+1, b, yield, return)
    }
}

fn urange(a : uint, b : uint, yield : fn(uint, fn()))
-> ()
{
    if a < b {
        yield(a); // TODO adding an @ here OR above makes stuff go SLOWER! ?!?
        urange(a+1u, b, yield, return)
    }
}

fn ever(yield: fn() -> () ) -> ()
{
    @yield();
    ever(yield, return)
}

fn ever1(a : uint, yield: fn(uint) -> uint) -> uint
{
    let b = @yield(a);
    ever1(b, yield, return)
}

fn min(a : float, b : float) -> float
{
    if a < b { a } else { b }
}

fn max(a : float, b : float) -> float
{
    if a < b { b } else { a }
}

fn clamp(lower : float, val : float, upper : float) -> float
{
    min(upper, max(lower, val))
}

fn clamp01f(val : float) -> float
{
    @clamp(0.0f, val, 1.0f)
}


fn mul(a : float, b : float) -> float { a * b }
fn div(a : float, b : float) -> float { a / b }
fn add(a : float, b : float) -> float { a + b }
fn sub(a : float, b : float) -> float { a - b }
fn less(a : float, b : float) -> bool { a < b }
fn neg(a : float) -> float { -a }
fn sqr(a : float) -> float { a*a }
fn isneg(a : float) -> bool { a < 0.0f }
fn isstrictpos(a : float) -> bool { a > 0.0f }

fn almost(a : float, b : float) -> bool
{
    fabsf(a - b) < epsilon()
}

fn lerp(a : float, b : float, t : float) -> float
{
    a * (1.0f - t) + b * t
}

// Scale a range to a range, linearly
fn scaleLin(v : float, vMin : float, vMax : float, targetMin : float, targetMax : float) -> float
{
	let d = vMax-vMin;
	if d == 0.0f { vMin } else { @lerp(targetMin, targetMax, (@clamp(vMin, v, vMax)-vMin)/d) }
}

/*
fn pos_infinity() -> float
{
    1.0f/0.0f
}

fn neg_infinity() -> float
{
    -1.0f/0.0f
}
*/

fn pi() -> float
{
    3.141592653589793f
}

fn epsilon() -> float
{
    1e-5f
}


fn isDebug() -> bool
{
    false
}


fn bool2int(b : bool) -> int
{
    if b {1} else {0}
}

fn bool2uint(b : bool) -> uint
{
    if b {1u} else {0u}
}

// only works for positive numbers!
fn div_round_up(a : int, b : int) -> int
{
    (a+b-1)/b
}

// only works for positive numbers!
fn round_up(a : int, b : int) -> int
{
    div_round_up(a, b)*b
}
