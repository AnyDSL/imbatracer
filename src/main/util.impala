

fn range(a : int, b : int, yield : fn(int, fn()))
-> ()
{
    if a < b {
        yield(a);
        range(a+1, b, yield, return)
    }
}

fn iteration(width : int, height : int, body : fn(int, int) -> () )
-> ()
{
    for y in $range(0, height) {
        for x in $range(0, width) {
            body(x, y);
        }
    }
}

fn min(a : float, b : float) -> float
{
    if a < b { a } else { b }
}

fn max(a : float, b : float) -> float
{
    if a < b { b } else { a }
}


fn clamp(lower : float, val : float, upper : float) -> float
{
    min(upper, max(lower, val))
}

fn clamp01f(val : float) -> float
{
    @clamp(0.0f, val, 1.0f)
}


fn mul(a : float, b : float) -> float { a * b }
fn div(a : float, b : float) -> float { a / b }
fn add(a : float, b : float) -> float { a + b }
fn sub(a : float, b : float) -> float { a - b }
fn less(a : float, b : float) -> bool { a < b }

fn almost(a : float, b : float) -> bool
{
    fabsf(a - b) < 0.00001f
}

fn lerp(a : float, b : float, t : float) -> float
{
    a * (1.0f - t) + b * t
}

// Scale a range to a range, linearly
fn scaleLin(v : float, vMin : float, vMax : float, targetMin : float, targetMax : float) -> float
{
	let f = clamp(vMin, v, vMax);
	let d = vMax-vMin;
	if d == 0.0f { vMin } else { lerp((f-vMin)/d, targetMin, targetMax) }
}


