struct Matrix  {
    rows : [Float4*4],
}
static Matrix_SIZEOF = 4u*Float4_SIZEOF;

fn matrix4(r1 : Float4, r2 : Float4, r3 : Float4, r4 : Float4) -> Matrix
{
    Matrix { rows:[r1, r2, r3, r4] }
}

fn matrixZero() -> Matrix
{
    @matrix4(@float4(0.0f, 0.0f, 0.0f, 0.0f),
             @float4(0.0f, 0.0f, 0.0f, 0.0f),
             @float4(0.0f, 0.0f, 0.0f, 0.0f),
             @float4(0.0f, 0.0f, 0.0f, 0.0f))
}

fn matrixI() -> Matrix
{
    @matrix4(@float4(1.0f, 0.0f, 0.0f, 0.0f),
             @float4(0.0f, 1.0f, 0.0f, 0.0f),
             @float4(0.0f, 0.0f, 1.0f, 0.0f),
             @float4(0.0f, 0.0f, 0.0f, 1.0f))
}

fn matrixScaling(v : Vec) -> Matrix
{
    @matrix4(@float4(v.x,  0.0f, 0.0f, 0.0f),
             @float4(0.0f, v.y,  0.0f, 0.0f),
             @float4(0.0f, 0.0f, v.z,  0.0f),
             @float4(0.0f, 0.0f, 0.0f, 1.0f))
}


fn matrixRotationX(a : float) -> Matrix
{
	let c = @cosf(a);
	let s = @sinf(a);
	@matrix4(
		@float4(1.0f, 0.0f, 0.0f, 0.0f),
		@float4(0.0f, c,    -s,   0.0f),
		@float4(0.0f, s,     c,   0.0f),
		@float4(0.0f, 0.0f, 0.0f, 1.0f)
	)
}
fn matrixRotationY(a : float) -> Matrix
{
	let c = @cosf(a);
	let s = @sinf(a);
    @matrix4(
		@float4(c,    0.0f, s,    0.0f),
		@float4(0.0f, 1.0f, 0.0f, 0.0f),
		@float4(-s,   0.0f, c,    0.0f),
		@float4(0.0f, 0.0f, 0.0f, 1.0f)
	)
}

fn matrixRotationZ(a : float) -> Matrix
{
	let c = @cosf(a);
	let s = @sinf(a);
	@matrix4(
		@float4(c,   -s,    0.0f, 0.0f),
		@float4(s,    c,    0.0f, 0.0f),
		@float4(0.0f, 0.0f, 1.0f, 0.0f),
		@float4(0.0f, 0.0f, 0.0f, 1.0f)
	)
}
fn matrixRotation(uo : Vec, a : float) -> Matrix
{
	// https://en.wikipedia.org/wiki/Rotation_matrix#Axis_and_angle
	let u = @float4_v(@normalize(uo));
	let c = @cosf(a);
	let s = @sinf(a);
	let C = 1.0f - c;
	let uC = @f4scale(u, C);
	let q = @f4mul(u, uC);          // xxC, yyC, zzC
	let S = @f4scale(u, s);

	let v = @f4mul(uC , float4(u.z, u.x, u.y, u.w)); // xzC, yxC, zyC

	@matrix4(
		@float4(q.x+c  , v.y-S.z, v.x+S.y, 0.0f),
		@float4(v.x+S.z, q.y+c  , v.z-S.x, 0.0f),
		@float4(v.x-S.y, v.z+S.x, q.z+c  , 0.0f),
		@float4(0.0f   ,  0.0f  ,  0.0f  , 1.0f)
	)
}

fn matrixTranslation(t : Vec) -> Matrix
{
	@matrix4(
		@float4(1.0f, 0.0f, 0.0f, t.x),
		@float4(0.0f, 1.0f, 0.0f, t.y),
		@float4(0.0f, 0.0f, 1.0f, t.z),
		@float4(0.0f, 0.0f, 0.0f, 1.0f)
	)
}

fn mf4mul(m : Matrix, f : Float4) -> Float4
{
    @float4(@f4dot(m.rows(0),f), @f4dot(m.rows(1),f), @f4dot(m.rows(2),f), @f4dot(m.rows(3),f))
}

fn mpmul(m : Matrix, p : Point) -> Point
{
    let f = @mf4mul(m, @float4_p(p));
    @point_f4(f)
}

fn mvmul(m : Matrix, v : Vec) -> Vec
{
    let f = @mf4mul(m, @float4_v(v));
    @vec_f4(f)
}

fn mmul_transposed3x3(m : Matrix, n : Vec) -> Vec
{
    @vec(@dot(@vec(m.rows(0).x, m.rows(1).x, m.rows(2).x), n),
         @dot(@vec(m.rows(0).y, m.rows(1).y, m.rows(2).y), n),
         @dot(@vec(m.rows(0).z, m.rows(1).z, m.rows(2).z), n))
}

fn mmul(a : Matrix, b : Matrix) -> Matrix
{
    let mut r:Matrix;
    for i in @urange(0u, 4u)
    {
		r.rows(i) = @f4add(
            @f4add(@f4scale(b.rows(0), a.rows(i).x),
                   @f4scale(b.rows(1), a.rows(i).y)),
            @f4add(@f4scale(b.rows(2), a.rows(i).z),
                   @f4scale(b.rows(3), a.rows(i).w)));
    }
    r
}

// http://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix/23806710#23806710
fn _minvertf(ii : int, jj : int, m : Matrix) -> float
{
    let o = 2+(jj-ii);
    let i = ii + 4+o;
    let j = jj + 4-o;

    fn e(a : int, b : int) -> float
    {
        f4Axis(m.rows((j+b)%4), (i+a)%4 as uint)
    }

    let inv =
     + e(+1,-1)*e(+0,+0)*e(-1,+1)
     + e(+1,+1)*e(+0,-1)*e(-1,+0)
     + e(-1,-1)*e(+1,+0)*e(+0,+1)
     - e(-1,-1)*e(+0,+0)*e(+1,+1)
     - e(-1,+1)*e(+0,-1)*e(+1,+0)
     - e(+1,-1)*e(-1,+0)*e(+0,+1);

     if o%2 != 0 { inv } else { -inv }
}

fn minvert(m : Matrix, mut detp : &float) -> Matrix
{
    let mut inv : Matrix;

    for i in @range(0, 4)
    {
        for j in @range(0, 4)
        {
            @f4SetAxis(&inv.rows(j), i as uint, @_minvertf(i,j,m));
        }
    }

    let mut D = 0.0f;

    for k in @urange(0u, 4u)
    {
        D = D + f4Axis(m.rows(0), k) * inv.rows(k).x;
    }

    if(detp != (0 as &float))
    {
        *detp = D;
    }

    if (D == 0.0f)
    {
        @matrixZero()
    }
    else
    {
        D = 1.0f / D;

        for i in @urange(0u, 4u)
        {
            inv.rows(i) = f4scale(inv.rows(i), D);
        }
        inv
    }
}
