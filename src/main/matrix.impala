struct Matrix  {
    rows : [Float4*4],
}
static Matrix_SIZEOF = 4u*Float4_SIZEOF;

fn matrix4(r1 : Float4, r2 : Float4, r3 : Float4, r4 : Float4) -> Matrix
{
    Matrix { rows:[r1, r2, r3, r4] }
}

fn matrix0() -> Matrix
{
    @matrix4(float4(1.0f, 0.0f, 0.0f, 0.0f),
             float4(0.0f, 1.0f, 0.0f, 0.0f),
             float4(0.0f, 0.0f, 1.0f, 0.0f),
             float4(0.0f, 0.0f, 0.0f, 1.0f))
}

fn matrix_scalingv(v : Vec) -> Matrix
{
    @matrix4(@float4(v.x,  0.0f, 0.0f, 0.0f),
             @float4(0.0f, v.y,  0.0f, 0.0f),
             @float4(0.0f, 0.0f, v.z,  0.0f),
             @float4(0.0f, 0.0f, 0.0f, 1.0f))
}

fn mf4mul(m : Matrix, f : Float4) -> Float4
{
    @float4(f4dot(m.rows(0),f), f4dot(m.rows(1),f), f4dot(m.rows(2),f), f4dot(m.rows(3),f))
}

fn mpmul(m : Matrix, p : Point) -> Point
{
    let f = @mf4mul(m, float4_p(p));
    @point_f4(f)
}

fn mvmul(m : Matrix, v : Vec) -> Vec
{
    let f = @mf4mul(m, float4_v(v));
    @vec_f4(f)
}

fn mmul_transposed3x3(m : Matrix, n : Vec) -> Vec
{
    @vec(@dot(@vec(m.rows(0).x, m.rows(1).x, m.rows(2).x), n),
         @dot(@vec(m.rows(0).y, m.rows(1).y, m.rows(2).y), n),
         @dot(@vec(m.rows(0).z, m.rows(1).z, m.rows(2).z), n))
}
