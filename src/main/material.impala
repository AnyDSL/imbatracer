
// Indices into scene texture array
struct Material
{
    // diffuse
    diffuse : uint,
    // specular (phong)
    specular : uint,
    specExp : float,
    // ambient / emissive
    emissive : uint,
}

// assumes two default textures at index 0 (white) and 1 (black)
fn dummyMaterial() -> Material
{
    Material {
        diffuse:1u,
        specular:0u,
        specExp:-1.0f,
        emissive:0u
    }
}

fn phongFactor(normal:Vec, outDir:Vec, inDir:Vec, exponent:float) -> float
{
    // compute cos with the reflected out dir
    let mirroredOut = vsub(fvmul((2.0f * @dot(normal, outDir)), normal), outDir); // this works no matter how the normal is swapped
    let cosReflIn = @dot(inDir, mirroredOut);
    if (cosReflIn <= 0.0f) { return(0.0f) }
    // use this to compute the final factor applied to the texture
    powf(cosReflIn, exponent)*(exponent+2.0f)/(2.0f*pi()) // TODO don't compute normalisation factor all the time
}

fn evalMaterialReflectance(texPoint:TexCoord, local:Point, normal:Vec, outDir:Vec, inDir:Vec, mat : &Material, mut scene : &Scene) -> Color
{
    let diffuse = evalTexture(texPoint, local, &scene.textures(mat.diffuse));

    let lambertian = @cdiv(diffuse, @pi());
    let phong = if mat.specExp > 0.0f {
            @cmul(evalTexture(texPoint, local, &scene.textures(mat.specular))
                , @phongFactor(normal, outDir, inDir, mat.specExp)
            )
        } else { @color0() };
    let renderCos = @absdot(inDir, normal);
    @cmul(@ccadd(lambertian, phong), renderCos)
}

fn evalMaterialEmission(texPoint:TexCoord, local:Point, normal:Vec, outDir:Vec, mat : &Material, mut scene : &Scene) -> Color
{
    // texture material
    evalTexture(texPoint, local, &scene.textures(mat.emissive))

    // TODO: other materials (glass etc)
}
