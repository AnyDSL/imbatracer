
// Indices into scene texture array
struct Material
{
    // diffuse
    diffuse : uint,
    // specular (phong)
    specular : uint,
    specExp : float,
    // ambient / emissive
    emissive : uint,
}

// assumes two default textures at index 0 (white) and 1 (black)
fn dummyMaterial() -> Material
{
    Material {
        diffuse:1u,
        specular:0u,
        specExp:-1.0f,
        emissive:0u
    }
}

fn phongFactor(normal:Vec, outDir:Vec, inDir:Vec, exponent:float) -> float
{
    // compute cos with the reflected out dir
    let mirroredOut = vsub(fvmul((2.0f * @dot(normal, outDir)), normal), outDir); // this works no matter how the normal is swapped
    let cosReflIn = @dot(inDir, mirroredOut);
    if (cosReflIn <= 0.0f) { return(0.0f) }
    // use this to compute the final factor applied to the texture
    cpu_powf(cosReflIn, exponent)*(exponent+2.0f)/(2.0f*pi()) // TODO don't compute normalisation factor all the time
}

type ReflectanceFn = fn(TexCoord, Point, Vec, Vec, Vec) -> Color;
type EmissionFn = fn(TexCoord, Point, Vec, Vec) -> Color;

fn buildMaterial(mat : Material, scene : &Scene) -> (ReflectanceFn, EmissionFn)
{
    let diffuseFn = buildTextureFn(scene.textures(mat.diffuse));
    let specularFn = buildTextureFn(scene.textures(mat.specular));
    let emissiveFn = buildTextureFn(scene.textures(mat.emissive));

    let reflectance = |texPoint:TexCoord, local:Point, normal:Vec, outDir:Vec, inDir:Vec| -> Color
    {
        let lambertian = @cdiv(diffuseFn(texPoint, local), pi());
        let phong = if mat.specExp > 0.0f { @cmul(specularFn(texPoint, local), @phongFactor(normal, outDir, inDir, mat.specExp)) } else { @color0() };
        let renderCos = @absdot(inDir, normal);
        @cmul(@ccadd(lambertian, phong), renderCos)
    };

    let emission = |texPoint:TexCoord, local:Point, normal:Vec, outDir:Vec| -> Color
    {
        emissiveFn(texPoint, local)
    };

    (reflectance, emission)
}
