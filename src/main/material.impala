struct Material
{
    // diffuse
    diffuse : Color,
    // specular (phong)
    specular : Color,
    specExp : float,
    // ambient / emissive
    emissive : Color,
}

fn dummyMaterial() -> Material
{
    Material {
        diffuse:color1(1.0f),
        specular:color1(0.0f),
        specExp:-1.0f,
        emissive:color1(0.0f)
    }
}

fn phongFactor(normal:Vec, outDir:Vec, inDir:Vec, exponent:float) -> float
{
    // compute cos with the reflected out dir
    let mirroredOut = vsub(fvmul((2.0f * @dot(normal, outDir)), normal), outDir); // this works no matter how the normal is swapped
    let cosReflIn = @dot(inDir, mirroredOut);
    if (cosReflIn <= 0.0f) { return(0.0f) }
    // use this to compute the final factor applied to the texture
    powf(cosReflIn, exponent)*(exponent+2.0f)/(2.0f*pi()) // TODO don't compute normalisation factor all the time
}

fn buildMaterial(mat : Material) -> (fn(TexCoord, Vec, Vec, Vec) -> Color, fn(TexCoord, Vec, Vec) -> Color)
{
    let reflectance = |texPoint:TexCoord, normal:Vec, outDir:Vec, inDir:Vec| -> Color
    {
        let renderCos = @absdot(inDir, normal);
        let lambertian = @cdiv(mat.diffuse, pi());
        let phong = if mat.specExp >= 0.0f { @cmul(mat.specular, @phongFactor(normal, outDir, inDir, mat.specExp)) } else { color0() };
        @cmul(@ccadd(lambertian, phong), renderCos)
    };

    let emission = |texPoint:TexCoord, normal:Vec, outDir:Vec| -> Color
    {
        mat.emissive
    };

    (reflectance, emission)
}
