
// Cheap replacement for enums
type Sampling = uint;
static SAMPLING_NOT_NEEDED = 0u; // the material can be rendered by iterating over the light sources
static SAMPLING_SECONDARY = 1u; // you should iterate over the light sources, but also do sampling
static SAMPLING_ALL = 2u; // iterating over the light sources is unproductive and you should sample the material directly


// Indices into scene texture array
struct Material
{
    // diffuse
    diffuse : uint,
    // specular (phong)
    specular : uint,
    specExp : float,
    // ambient / emissive
    emissive : uint,
    // mirror
    sampling : Sampling, // FIXME can't this be determined based on the other parameters?
    eta :float, // used by mirror, glass
    etaSqrKappaSqr : float,
    nSamples : uint,
    // glass
    refract : uint, // used as bool
}
static Material_SIZEOF = 9u*uint_SIZEOF;

struct SampleReflectance
{
    reflectance : Color,
    direction : Vec,
}

// assumes two default textures at index 0 (white) and 1 (black)
fn dummyMaterial() -> Material
{
    Material {
        diffuse:1u,
        specular:0u,
        specExp:-1.0f,
        emissive:0u,
        eta:0.0f,
        etaSqrKappaSqr:0.0f,
        sampling:SAMPLING_NOT_NEEDED,
        nSamples:1u,
        refract:0u,
    }
}

fn mirrorMaterial(eta : float, kappa : float) -> Material
{
    Material {
        diffuse:1u,
        specular:0u,
        specExp:-1.0f,
        emissive:0u,
        eta:eta,
        etaSqrKappaSqr:(eta*eta + kappa*kappa),
        sampling:SAMPLING_ALL,
        nSamples:1u,
        refract:0u,
    }
}

fn glassMaterial(eta : float) -> Material
{
    Material {
        diffuse:1u,
        specular:0u,
        specExp:-1.0f,
        emissive:0u,
        eta:eta,
        etaSqrKappaSqr:(eta*eta),
        sampling:SAMPLING_ALL,
        nSamples:2u,
        refract:1u,
    }
}

fn steelMirrorMaterial() -> Material
{
    mirrorMaterial(2.485f, 3.433f)
}

fn silverMirrorMaterial() -> Material
{
    mirrorMaterial(0.177f, 3.638f)
}

fn fresnelFactor(m : &Material, cosOut : float) -> float
{
    assert(||{cosOut >= 0.0f}, "It must all be the same hemisphere");
    let etaSqrKappaSqr = m.etaSqrKappaSqr;

    let sqrSumTimesCosSqr = etaSqrKappaSqr*sqr(cosOut);
    let twoEtaCos = 2.0f*m.eta*cosOut;
    let rParallelSqr = (sqrSumTimesCosSqr + 1.0f - twoEtaCos) / (sqrSumTimesCosSqr + 1.0f + twoEtaCos);
    let rOrthoSqr = (etaSqrKappaSqr + sqr(cosOut) - twoEtaCos) / (etaSqrKappaSqr + sqr(cosOut) + twoEtaCos);
    let fr = 0.5f*(rParallelSqr + rOrthoSqr);
    assert(||{0.1f <= fr && fr <= 1.1f}, "Fresnel term out of range");
    fr
}

fn phongFactor(normal:Vec, outDir:Vec, inDir:Vec, exponent:float) -> float
{
    // compute cos with the reflected out dir
    let mirroredOut = vsub(fvmul((2.0f * @dot(normal, outDir)), normal), outDir); // this works no matter how the normal is swapped
    let cosReflIn = @dot(inDir, mirroredOut);
    if (cosReflIn <= 0.0f) { return(0.0f) }
    // use this to compute the final factor applied to the texture
    (1.0f / (2.0f * pi)) * (powf(cosReflIn, exponent)*(exponent+2.0f))
}

fn glassRefract(inDir : Vec, cosIn : float, normal : Vec, etaFromByEtaTo : float) -> (Vec, float, bool)
{
    assert(||cosIn > 0.0f && almost(dot(inDir, normal), cosIn), "glassRefract(): wrong input");
    let inPlane = @vsub(inDir, @vfmul(normal, cosIn));
    let sinInSqr = @vlensq(inPlane);
    let sinOutSqr = sinInSqr * @sqr(etaFromByEtaTo);
    let cosOutSqr = 1.0f - sinOutSqr;

    if cosOutSqr >= 0.0f
    {
        let cosOut = sqrtf(cosOutSqr);
        (vflip(vadd(vfmul(normal, cosOut), vfmul(inPlane, etaFromByEtaTo))), cosOut, false)
    }
    else
    {
        (@vec0(), 0.0f, true)
    }
}

fn evalMaterialReflectance(texPoint:TexCoord, local:Point, normal:Vec, outDir:Vec, inDir:Vec, mat : &Material, mut shadingData : &RTShadingData) -> Color
{
    let diffuse = evalTexture(texPoint, local, &shadingData.textures(mat.diffuse));

    let lambertian = @cdiv(diffuse, pi);
    let phong = if mat.specExp > 0.0f {
            @cmul(evalTexture(texPoint, local, &shadingData.textures(mat.specular))
                , @phongFactor(normal, outDir, inDir, mat.specExp)
            )
        } else { @color0() };
    let renderCos = @absdot(inDir, normal);

    @cmul(@ccadd(lambertian, phong), renderCos)
}

fn evalMaterialEmission(texPoint:TexCoord, local:Point, normal:Vec, outDir:Vec, mat : &Material, mut shadingData : &RTShadingData) -> Color
{
    // texture material
    evalTexture(texPoint, local, &shadingData.textures(mat.emissive))

    // TODO: other materials (glass etc)
}

fn evalMaterialSampleReflectance(mat : &Material, texPoint : Point, normal : Vec, outDir : Vec, sampleIdx : uint) -> SampleReflectance
{
    let mut cosOut = @dot(normal, outDir); // this can be negative!

    fn doReflectance(fresnel : float, n : Vec) -> SampleReflectance
    {
        // direction: mirror at normal (this works correctly for both signs of cosOut, it'll just swap the normal properly)
        let direction = @vsub(fvmul((2.0f * cosOut), n), outDir);
        // reflectance: Fresnel term
        let reflectance = @color1(fresnel);

        SampleReflectance { direction:direction, reflectance:reflectance}
    }

    if mat.refract == 0u
    {
        @doReflectance(fresnelFactor(mat, fabsf(cosOut)), normal)
    }
    else
    {
        let entering = cosOut < 0.0f;
        let etaIn    = if entering { 1.0f } else { mat.eta  };
        let etaTrans = if entering { mat.eta  } else { 1.0f };
        let lightwardsNormal = if entering { vflip(normal) } else { normal };

        cosOut = fabsf(cosOut);
        let etaOByI = etaTrans / etaIn;

        if (sampleIdx & 1u) == 0u // first ray does refraction, second handled reflection
        {
            // refraction
            let refracted = @glassRefract(outDir, cosOut, lightwardsNormal, etaOByI);
            let totalReflect = refracted(2);
            if totalReflect
            {
                SampleReflectance { direction:vec0(), reflectance:color0() }
            }
            else
            {
                let cosIn = refracted(1);
                let refractDir = refracted(0);
                // compute fresnel term
                let rParallel = (etaTrans*cosIn - etaIn*cosOut)/(etaTrans*cosIn + etaIn*cosOut);
                let rOrtho    = (etaIn*cosIn - etaTrans*cosOut)/(etaIn*cosIn + etaTrans*cosOut);
                let fr = 0.5f*(@sqr(rParallel) + @sqr(rOrtho));

                SampleReflectance { direction:refractDir, reflectance:color1((1.0f-fr)*2.0f*@sqr(etaOByI)) }
            }
        }
        else
        {
            // reflection
            @doReflectance(2.0f, lightwardsNormal)
        }
    }
}
