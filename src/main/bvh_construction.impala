
// abstract BVH construction functions
type primInitFn = fn() -> uint; // this is called at the beginning and returns how many objects there are
type primBoundsFn = fn(uint) -> BBox; // given an object index, return its bounds
type primCopyFn = fn(uint) -> uint; // called exactly once per object, copies the objects and return the index it finally has
type primFinishFn = fn() -> (); // called at the end, to finalzie and potentially free memory

static maxPrimsPerLeaf = 4u;

struct BVHTrees
{
    roots: DynArray, // of uint
    bvhNodes: DynArray, // of BVHNode
}
fn bvhTrees() -> BVHTrees
{
    BVHTrees{ roots: @dynArray(uint_SIZEOF, "BVHTrees.roots"), bvhNodes:@dynArray(BVHNode_SIZEOF, "BVHTrees.bvhNodes") }
}



struct PrimData
{
    bounds: BBox,
    centroid: Point,
}

struct SplitPlaneCandidate
{
    nLeft: uint,
    leftBBox: BBox,
    rightBBox: BBox,
}

struct NodeSplitInformation
{
    nLeft: uint,
    left: &[uint],
    right: &[uint],
    leftBBox: BBox,
    rightBBox: BBox,
    bestAxis: int,
    bestCost: float,
}

// BVH copying functions
fn bvhsCompile(mut bvhs: &BVHTrees, mut rtBvhs: &RTBVHTrees) -> ()
{
    rtBvhs.bvhNodes = @dynArrayData(&bvhs.bvhNodes) as &[BVHNode];
    rtBvhs.roots = @dynArrayData(&bvhs.roots) as &[uint];
}

// construct a BVH tree, adding the nodes to the vbHnodes array. Returns the index of the root.
fn bvhsAddTree(mut trees: &BVHTrees, primBVHInterface: (primInitFn, primBoundsFn, primCopyFn, primFinishFn)) -> ()
{
    // prepare object copy
    let nPrims = @primBVHInterface(0)();

    // prepare working arena and object data
    let mut totalBounds = bboxEmpty();
    let mut primData = ~[nPrims:PrimData];
    let splitPlaneCandidates = ~[nPrims:SplitPlaneCandidate];
    let leftPrims = ~[nPrims*depthLimit:uint];
    let rightPrims = ~[nPrims*depthLimit:uint];
    let mut allPrims = ~[nPrims:uint];
    let mut primFinalizeOrder = @dynArrayInit(uint_SIZEOF, nPrims, "BVH Construction: primFinalizeOrder");

    for primIdx in urange(0u, nPrims) {
        let bounds = @primBVHInterface(1)(primIdx);
        primData(primIdx) = PrimData{ bounds:bounds, centroid:@bboxCentroid(bounds) };
        totalBounds = bbextendb(totalBounds, bounds);
        allPrims(primIdx) = primIdx; // TODO get rid of this array, it's just used to pass the initial to-split-list...
    }

    let oldSize = @dynArraySize(&trees.bvhNodes);
    let root = $buildBvhNode(allPrims, nPrims, totalBounds, 0u, primData, leftPrims, rightPrims,
                             &trees.bvhNodes, &primFinalizeOrder);
    @assert(||oldSize == root, "bvhsAddTree: Someone put the root at the wrong place, and it wasn't me...");

    // do the primitive finalisation
    @assert(||@dynArraySize(&primFinalizeOrder) == nPrims, "constructBvh: Somehow we got the number of primitives wrong");
    for i in urange(0u, nPrims) {
        let idx = @primBVHInterface(2)(dynArrayFetchUint(&primFinalizeOrder, i));
        @assert(||idx == i, "constructBvh: primFinalize is misbehaving");
    }

    // clean up
    thorin_free(primData as &u8);
    thorin_free(splitPlaneCandidates as &u8);
    thorin_free(leftPrims as &u8);
    thorin_free(rightPrims as &u8);
    thorin_free(allPrims as &u8);
    @dynArrayClear(&primFinalizeOrder);

    // finish object copy
    @primBVHInterface(3)();
    @dynArrayAppendUint(&trees.roots, root);
    print_sii("Constructed a BVH tree with <num> primitives having <num> nodes:", nPrims as int, (@dynArraySize(&trees.bvhNodes)-oldSize) as int);
}

/* Build a BVH node from the primitives (in splitPrims). These are indices into the tris vector above!
 * Put primitives into triBuf (starting at offset triBufOff), and the flattened nodes into nodeBuf.
 * Return the index of the root (in nodeBuf).
 */
fn buildBvhNode(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, primData: &[PrimData], mut leftPrims: &[uint], mut rightPrims: &[uint],
        bvhNodes: &DynArray, primFinalizeOrder: &DynArray) -> uint
{
    let mut node:BVHNode;
    node.bbox = totalBounds;

    // split
    let mut splitInfo = NodeSplitInformation{ left:leftPrims, right:rightPrims, leftBBox:@bboxEmpty(), rightBBox:@bboxEmpty(), bestAxis: -1,
            nLeft: 0u, bestCost: 0.0f };
    bvhDecideSplit(prims, nPrims, totalBounds, depth, primData, &splitInfo);

    // did we get a leaf?
    if (splitInfo.bestAxis < 0) {
        // create a leaf
        node.nPrims = nPrims as u16;
        for primIdxIdx in urange(0u, nPrims) {
            let primFinalIdx = dynArrayAppendUint(primFinalizeOrder, prims(primIdxIdx));
            if primIdxIdx == 0u {
                // store the final index of the first primitive
                node.sndChildFirstPrim = primFinalIdx;
            }
        }
        return(dynArrayAppend(bvhNodes, &node as &u8))
    }

    // Create an inner node
    // node.secondChild is not yet known, will be fixed up below
    node.axis = splitInfo.bestAxis as u16;
    node.nPrims = 0u16;
    let nodeIdx = dynArrayAppend(bvhNodes, &node as &u8);

    // Process child nodes recursively, using space further down in our arrays (after the space in leftPrims, rightPrims that we needed)
    assert(||splitInfo.nLeft <= nPrims, "buildBvhNode: Keeping too many primitives");
    let firstChild =  $buildBvhNode(leftPrims , splitInfo.nLeft       , splitInfo.leftBBox , depth+1u, primData,
                                    &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32],
                                    bvhNodes, primFinalizeOrder);
    let secondChild = $buildBvhNode(rightPrims, nPrims-splitInfo.nLeft, splitInfo.rightBBox, depth+1u, primData,
                                    &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32],
                                    bvhNodes, primFinalizeOrder);

    // Make sure the children's order in the vector is as expected
    @assert(||firstChild == nodeIdx+1u, "Left child doesn't come right after me");

    // Now that the second child's index in the vector is known, fix it and be done
    let mut nodePtr = dynArrayFetch(bvhNodes, nodeIdx) as &BVHNode; nodePtr.sndChildFirstPrim = secondChild;
    return(nodeIdx)
}

fn bvhDecideSplit(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, primData: &[PrimData], mut splitInfo: &NodeSplitInformation) -> ()
{
    @assert(||splitInfo.bestAxis < 0, "bvhDecideSplit: Got incorrectly initialized stuff");
    // termination criterion
    if(nPrims <= maxPrimsPerLeaf || depth >= depthLimit) {
        //  don't do any split
        return()
    }

    let longestAxis = @bboxLongestAxis(totalBounds);
    // sort objects by centroid, along longest axis
    sort(prims, nPrims, |prim1, prim2|@pointAxis(primData(prim1).centroid, longestAxis) < @pointAxis(primData(prim2).centroid, longestAxis));

    // put first half left, second half right
    splitInfo.bestAxis = longestAxis as int;
    splitInfo.nLeft = nPrims/2u;
    for i in urange(0u, splitInfo.nLeft) {
        let primIdx = prims(i);
        splitInfo.leftBBox = bbextendb(splitInfo.leftBBox, primData(primIdx).bounds);
        splitInfo.left(i) = primIdx;
    }
    for i in urange(0u, nPrims-splitInfo.nLeft) {
        let primIdx = prims(splitInfo.nLeft+i);
        splitInfo.rightBBox = bbextendb(splitInfo.rightBBox, primData(primIdx).bounds);
        splitInfo.right(i) = primIdx;
    }

    // done!
    return;
}
