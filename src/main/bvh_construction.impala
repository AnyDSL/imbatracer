
// abstract BVH construction functions
type primInitFn = fn() -> (uint, uint); // this is called at the beginning and returns how many objects there are, and how many objects are already in the target list.
type primBoundsFn = fn(uint) -> BBox; // given an object index, return its bounds
type primCopyFn = fn(uint) -> uint; // called exactly once per object, copies the objects and return the index it finally has. this must be incrementing in steps of 1, starting at the number of objects that were already in the target list!
type primFinishFn = fn() -> (); // called at the end, to finalzie and potentially free memory

static maxPrimsPerLeaf = 4u;
static isectCost = 7.0f;
static traversalCost = 1.0f;

struct BVHTrees
{
    roots: DynArray, // of uint
    nodes: DynArray, // of BVHNode
}
fn bvhTrees() -> BVHTrees
{
    BVHTrees{ roots: @dynArray(uint_SIZEOF, "BVHTrees.roots"), nodes:@dynArray(BVHNode_SIZEOF, "BVHTrees.nodes") }
}



struct PrimData
{
    bounds: BBox,
    centroid: Point,
}

struct SplitPlaneCandidate
{
    leftBBox: BBox,
    rightBBox: BBox,
}

struct NodeSplitInformation
{
    nLeft: uint,
    left: &[uint],
    right: &[uint],
    leftBBox: BBox,
    rightBBox: BBox,
    bestAxis: int,
    bestCost: float,
}

struct BVHConstructionData
{
    // collect run-time data for BVH construction (to reduce the amount of stuff we pass around as argument)
    primData: &[PrimData],
    bvhNodes: &DynArray,
    splitHeuristic: uint,
    splitPlaneCands: &[SplitPlaneCandidate],
    primFinalizeOffset: uint,
    primFinalizeOrder: &DynArray,
}

// BVH copying functions
fn bvhsCompile(mut bvhs: &BVHTrees, mut rtBvhs: &RTBVHTrees) -> ()
{
    rtBvhs.nodes = @dynArrayData(&bvhs.nodes) as &[BVHNode];
    rtBvhs.roots = @dynArrayData(&bvhs.roots) as &[uint];
}

// construct a BVH tree, adding the nodes to the vbHnodes array. Returns the index of the root.
// split heuristic can be: 0 = equal split on longest axis, 1 = SAH on longest axis, 2 = SAH on all axes
fn bvhsAddTree(mut trees: &BVHTrees, splitHeuristic: uint, primBVHInterface: (primInitFn, primBoundsFn, primCopyFn, primFinishFn)) -> ()
{
    // prepare object copy
    let initRet = @primBVHInterface(0)();
    let nPrims = initRet(0);
    let targetBase = initRet(1);

    // prepare working arena and object data
    let mut totalBounds = bboxEmpty();
    let mut primData = ~[nPrims:PrimData];
    let splitPlaneCandidates = ~[nPrims:SplitPlaneCandidate];
    let leftPrims = ~[nPrims*depthLimit:uint];
    let rightPrims = ~[nPrims*depthLimit:uint];
    let mut allPrims = ~[nPrims:uint];
    let mut primFinalizeOrder = @dynArrayInit(uint_SIZEOF, nPrims, "BVH Construction: primFinalizeOrder");

    for primIdx in urange(0u, nPrims) {
        let bounds = @primBVHInterface(1)(primIdx);
        primData(primIdx) = PrimData{ bounds:bounds, centroid:@bboxCentroid(bounds) };
        totalBounds = bbextendb(totalBounds, bounds);
        allPrims(primIdx) = primIdx; // TODO get rid of this array, it's just used to pass the initial to-split-list...
    }

    let oldSize = @dynArraySize(&trees.nodes);
    let mut constrData = BVHConstructionData{ primData:primData, splitHeuristic:splitHeuristic, splitPlaneCands:splitPlaneCandidates, bvhNodes:&trees.nodes,
                                              primFinalizeOffset:targetBase, primFinalizeOrder:&primFinalizeOrder };
    let root = $buildBvhNode(allPrims, nPrims, totalBounds, 0u, leftPrims, rightPrims, &constrData);
    @assert(||oldSize == root, "bvhsAddTree: Someone put the root at the wrong place, and it wasn't me...");

    // do the primitive finalisation
    @assert(||@dynArraySize(&primFinalizeOrder) == nPrims, "constructBvh: Somehow we got the number of primitives wrong");
    for i in urange(0u, nPrims) {
        let idx = @primBVHInterface(2)(dynArrayFetchUint(&primFinalizeOrder, i));
        @assert(||idx == targetBase+i, "constructBvh: primCopy is misbehaving");
    }

    // clean up
    thorin_free(primData as &u8);
    thorin_free(splitPlaneCandidates as &u8);
    thorin_free(leftPrims as &u8);
    thorin_free(rightPrims as &u8);
    thorin_free(allPrims as &u8);
    @dynArrayClear(&primFinalizeOrder);

    // finish object copy
    @primBVHInterface(3)();
    @dynArrayAppendUint(&trees.roots, root);
    print_sii("Constructed a BVH tree with <num> primitives having <num> nodes:", nPrims as int, (@dynArraySize(&trees.nodes)-oldSize) as int);
}

/* Build a BVH node from the primitives (in splitPrims). These are indices into the tris vector above!
 * Put primitives into triBuf (starting at offset triBufOff), and the flattened nodes into nodeBuf.
 * Return the index of the root (in nodeBuf).
 */
fn buildBvhNode(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, mut leftPrims: &[uint], mut rightPrims: &[uint],
                constrData: &BVHConstructionData) -> uint
{
    let mut node:BVHNode;
    node.bbox = totalBounds;

    // split
    let mut splitInfo = NodeSplitInformation{ left:leftPrims, right:rightPrims, leftBBox:@bboxEmpty(), rightBBox:@bboxEmpty(), bestAxis: -1,
            nLeft: 0u, bestCost: 0.0f };
    bvhDecideSplit(prims, nPrims, totalBounds, depth, constrData, &splitInfo);

    // did we get a leaf?
    if (splitInfo.bestAxis < 0) {
        // create a leaf
        node.nPrims = nPrims as u16;
        for primIdxIdx in urange(0u, nPrims) {
            let primFinalIdx = dynArrayAppendUint(constrData.primFinalizeOrder, prims(primIdxIdx)) + constrData.primFinalizeOffset;
            if primIdxIdx == 0u {
                // store the final index of the first primitive
                node.sndChildFirstPrim = primFinalIdx;
            }
        }
        return(dynArrayAppend(constrData.bvhNodes, &node as &u8))
    }

    // Create an inner node
    // node.secondChild is not yet known, will be fixed up below
    node.axis = splitInfo.bestAxis as u16;
    node.nPrims = 0u16;
    let nodeIdx = dynArrayAppend(constrData.bvhNodes, &node as &u8);

    // Process child nodes recursively, using space further down in our arrays (after the space in leftPrims, rightPrims that we needed)
    assert(||splitInfo.nLeft <= nPrims, "buildBvhNode: Keeping too many primitives");
    let firstChild =  $buildBvhNode(leftPrims , splitInfo.nLeft       , splitInfo.leftBBox , depth+1u,
                                    &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32], constrData);
    let secondChild = $buildBvhNode(rightPrims, nPrims-splitInfo.nLeft, splitInfo.rightBBox, depth+1u,
                                    &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32], constrData);

    // Make sure the children's order in the vector is as expected
    @assert(||firstChild == nodeIdx+1u, "Left child doesn't come right after me");

    // Now that the second child's index in the vector is known, fix it and be done
    let mut nodePtr = dynArrayFetch(constrData.bvhNodes, nodeIdx) as &BVHNode; nodePtr.sndChildFirstPrim = secondChild;
    return(nodeIdx)
}

fn bvhDecideSplit(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, constrData: &BVHConstructionData, mut splitInfo: &NodeSplitInformation) -> ()
{
    @assert(||splitInfo.bestAxis < 0, "bvhDecideSplit: Got incorrectly initialized stuff");
    // termination criterion
    if(nPrims <= maxPrimsPerLeaf || depth >= depthLimit) {
        //  don't do any split
        return()
    }

    let longestAxis:uint = @bboxLongestAxis(totalBounds);
    if constrData.splitHeuristic == 0u {
        // sort objects by centroid, along longest axis
        sort(prims, nPrims, |prim1, prim2|@pointAxis(constrData.primData(prim1).centroid, longestAxis) < @pointAxis(constrData.primData(prim2).centroid, longestAxis));

        // put first half left, second half right
        splitInfo.bestAxis = longestAxis as int;
        splitInfo.nLeft = nPrims/2u;
        for i in urange(0u, splitInfo.nLeft) {
            let primIdx = prims(i);
            splitInfo.leftBBox = bbextendb(splitInfo.leftBBox, constrData.primData(primIdx).bounds);
            splitInfo.left(i) = primIdx;
        }
        for i in urange(0u, nPrims-splitInfo.nLeft) {
            let primIdx = prims(splitInfo.nLeft+i);
            splitInfo.rightBBox = bbextendb(splitInfo.rightBBox, constrData.primData(primIdx).bounds);
            splitInfo.right(i) = primIdx;
        }

        // done!
        return()
    }
    else {
        splitInfo.bestCost = isectCost*(nPrims as float);
        for i in @urange(0u, 3u) {
            let axis = (longestAxis+i) % 3u;
            $bvhSplitSHAAxis(prims, nPrims, totalBounds, constrData, splitInfo, axis);
            if constrData.splitHeuristic == 1u && splitInfo.bestAxis >= 0 {
                // we found a good split on this axis, use it
                return()
            }
        }
        // now the best split we can come up with is in the info, so we are done
        return()
    }
}

fn bvhSplitSHAAxis(mut prims: &[uint], nPrims: uint, totalBounds: BBox, mut constrData: &BVHConstructionData, mut splitInfo: &NodeSplitInformation, axis:uint) -> ()
{
    @assert(||nPrims >= 2u, "bvhSplitSHAAxis: need at least two primitives, otherwise there's nothing to split...");
    // sort objects by centroid, along given axis
    sort(prims, nPrims, |prim1, prim2|@pointAxis(constrData.primData(prim1).centroid, axis) < @pointAxis(constrData.primData(prim2).centroid, axis));

    // split i in splitPlaneCands contains i+1 primitives to the left - there are nTris-1 splits in total
    let mut curBox = bboxEmpty();
    // compute left bounding boxes
    for i in urange(0u, nPrims-1u) {
        // add next triangle
        let primIdx = prims(i);
        curBox = @bbextendb(curBox, constrData.primData(primIdx).bounds);
        constrData.splitPlaneCands(i).leftBBox = curBox;
    }
    // compute right bounding boxes
    curBox = bboxEmpty();
    for i in urangedown(nPrims-1u, 0u) {
        // add next triangle
        let primIdx = prims(i);
        curBox = @bbextendb(curBox, constrData.primData(primIdx).bounds);
        constrData.splitPlaneCands(i-1u).rightBBox = curBox; // triangle i is already on the left in index i, but it's still on the right in index i-1
    }

    // find split plane with minimal cost
    let mut minCostIdx = -1;
    let mut minCost:float;
    let invTotalSurface = 1.0f / @bbsurface(totalBounds);
    for i in urange(0u, nPrims-1u) {
        // now compute the cost
        let leftPrims = i+1u;
        let leftSurface = @bbsurface(constrData.splitPlaneCands(i).leftBBox);
        let rightSurface = @bbsurface(constrData.splitPlaneCands(i).rightBBox);
        let cost = traversalCost + isectCost*invTotalSurface*((leftPrims as float)*leftSurface + ((nPrims-leftPrims) as float)*rightSurface);
        //print_sif("Split <> has cost <>", i as int, cost);
        if (minCostIdx < 0 || cost < minCost) {
            minCost = cost;
            minCostIdx = i as int;
        }
    }
    @assert(||minCostIdx >= 0, "We should have found something...");

    // did we find something useful?
    //print_siii("Splitting axis <> at index <> of <>: ", axis as int, minCostIdx, nPrims as int - 1);
	if minCost > splitInfo.bestCost {
		return()
    }

	// yes, we did. Split!
	splitInfo.nLeft = minCostIdx as uint + 1u;
	splitInfo.bestCost = minCost;
	splitInfo.bestAxis = axis as int;
    memcpy(splitInfo.left as &u8, prims as &u8, splitInfo.nLeft*uint_SIZEOF as size_t);
    splitInfo.leftBBox = constrData.splitPlaneCands(minCostIdx).leftBBox;
    memcpy(splitInfo.right as &u8, &prims(splitInfo.nLeft) as &u8, (nPrims - splitInfo.nLeft)*uint_SIZEOF as size_t);
    splitInfo.rightBBox = constrData.splitPlaneCands(minCostIdx).rightBBox;
}

