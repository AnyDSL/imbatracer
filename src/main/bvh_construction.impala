
// abstract BVH construction functions
type primBoundsFn = fn(uint) -> BBox;
type primFinalizeFn = fn(uint) -> uint; // called exactly once per object, return the index the object finally has



struct BVHTrees
{
    roots: DynArray, // of uint
    bvhNodes: DynArray, // of BVHNode
}
fn bvhTrees() -> BVHTrees
{
    BVHTrees{ roots: @dynArray(uint_SIZEOF, "BVHTrees.roots"), bvhNodes:@dynArray(BVHNode_SIZEOF, "BVHTrees.bvhNodes") }
}



struct PrimData
{
    bounds: BBox,
    centroid: Point,
}

struct SplitPlaneCandidate
{
    nLeft: uint,
    leftBBox: BBox,
    rightBBox: BBox,
}

struct NodeSplitInformation
{
    nLeft: uint,
    left: &[uint],
    right: &[uint],
    leftBBox: BBox,
    rightBBox: BBox,
    bestAxis: int,
    bestCost: float,
}

// construct a BVH tree, adding the nodes to the vbHnodes array. Returns the index of the root.
fn constructBvh(bvhNodes: &DynArray, nPrims: uint, primBounds: primBoundsFn, primFinalize: primFinalizeFn) -> uint
{
    // prepare working arena and object data
    let mut totalBounds = bboxEmpty();
    let mut primData = ~[nPrims:PrimData];
    let splitPlaneCandidates = ~[nPrims:SplitPlaneCandidate];
    let leftPrims = ~[nPrims*depthLimit:uint];
    let rightPrims = ~[nPrims*depthLimit:uint];
    let mut allPrims = ~[nPrims:uint];

    for primIdx in urange(0u, nPrims) {
        let bounds = @primBounds(primIdx);
        primData(primIdx) = PrimData{ bounds:bounds, centroid:@bboxCentroid(bounds) };
        totalBounds = bbextendb(totalBounds, bounds);
        allPrims(primIdx) = primIdx; // TODO get rid of this array, it's just used to pass the initial to-split-list...
    }

    let oldSize = @dynArraySize(bvhNodes);
    let root = buildBvhNode(allPrims, nPrims, totalBounds, 0u, leftPrims, rightPrims,
            bvhNodes, primFinalize);

    // clean up
    thorin_free(primData as &u8);
    thorin_free(splitPlaneCandidates as &u8);
    thorin_free(leftPrims as &u8);
    thorin_free(rightPrims as &u8);
    thorin_free(allPrims as &u8);

    print_sii("Constructed a BVH tree with <num> primitives having <num> nodes:", nPrims as int, (@dynArraySize(bvhNodes)-oldSize) as int);
    return(root)

}

/* Build a BVH node from the primitives (in splitPrims). These are indices into the tris vector above!
 * Put primitives into triBuf (starting at offset triBufOff), and the flattened nodes into nodeBuf.
 * Return the index of the root (in nodeBuf).
 */
fn buildBvhNode(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, mut leftPrims: &[uint], mut rightPrims: &[uint],
        bvhNodes: &DynArray, primFinalize: primFinalizeFn) -> uint
{
    let mut node:BVHNode;
    node.bbox = totalBounds;

    // split
    let mut splitInfo = NodeSplitInformation{ left:leftPrims, right:rightPrims, leftBBox:@bboxEmpty(), rightBBox:@bboxEmpty(), bestAxis: -1,
            nLeft: 0u, bestCost: 0.0f };
    bvhDecideSplit(prims, nPrims, totalBounds, depth, &splitInfo);

    // did we get a leaf?
    if (splitInfo.bestAxis < 0) {
        // create a leaf
        node.nPrims = nPrims as u16;
        for primIdxIdx in urange(0u, nPrims) {
            let primFinalIdx = primFinalize(prims(primIdxIdx));
            if primIdxIdx == 0u {
                // store the final index of the first primitive
                node.sndChildFirstPrim = primFinalIdx;
            }
        }
        return(dynArrayAppend(bvhNodes, &node as &u8))
    }

    // Create an inner node
    // node.secondChild is not yet known, will be fixed up below
    node.axis = splitInfo.bestAxis as u16;
    node.nPrims = 0u16;
    let nodeIdx = dynArrayAppend(bvhNodes, &node as &u8);

    // Process child nodes recursively, using space further down in our arrays (after the space in leftPrims, rightPrims that we needed)
    assert(||splitInfo.nLeft <= nPrims, "Keeping too many primitives");
    /*let firstChild =  $buildBvhNode(leftPrims , splitInfo.nLeft       , splitInfo.leftBBox , depth+1u, &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32],
            bvhNodes, primFinalize);
    let secondChild = $buildBvhNode(rightPrims, nPrims-splitInfo.nLeft, splitInfo.rightBBox, depth+1u, &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32],
            bvhNodes, primFinalize); FIXME this code ought to be run */
    assert_failed("buildBvhNode: Cannot split!");
    let firstChild = 0u; let secondChild = 0u;

    // Make sure the children's order in the vector is as expected
    assert(||firstChild == nodeIdx+1u, "Left child doesn't come right after me");

    // Now that the second child's index in the vector is known, fix it and be done
    let mut nodePtr = dynArrayFetch(bvhNodes, nodeIdx) as &BVHNode; nodePtr.sndChildFirstPrim = secondChild; // FIXME cannot put this into a single command
    return(nodeIdx)
}

fn bvhDecideSplit(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, splitInfo: &NodeSplitInformation) -> ()
{
    // don't do any split
}

/* Some more convenient wrapper functions */
fn bvhsAddTree(mut trees: &BVHTrees, nPrim: uint, primBounds: primBoundsFn, primFinalize: primFinalizeFn) -> ()
{
    let oldSize = @dynArraySize(&trees.bvhNodes);
    let root = constructBvh(&trees.bvhNodes, nPrim, primBounds, primFinalize);
    @assert(||oldSize == root, "bvhsAddTree: root got the wrong index");
    dynArrayAppendUint(&trees.roots, root);
}
