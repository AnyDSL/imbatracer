
// abstract BVH construction function
type primBoundsFn = fn(uint) -> BBox;
type primCentroidFn = fn(uint) -> Point;
type primFinalizeFn = fn(uint) -> uint; // called exactly once per object, return the index the object finally has

struct PrimData
{
    bounds: BBox,
    centroid: Point,
}

struct SplitPlaneCandidate
{
    nLeft: uint,
    leftBBox: BBox,
    rightBBox: BBox,
}

struct NodeSplitInformation
{
    nLeft: uint,
    left: &[uint],
    right: &[uint],
    leftBBox: BBox,
    rightBBox: BBox,
    bestAxis: int,
    bestCost: float,
}

fn constructBvh(nPrims: uint, primBounds: primBoundsFn, primCentroid: primCentroidFn, primFinalize: primFinalizeFn) -> ()
{
    // prepare working arena and object data
    let mut bvhNodes = dynArrayInit(0u, nPrims / 4u); // FIXME: sizeof()
    let mut totalBounds = bboxEmpty();
    let mut primData = ~[nPrims:PrimData];
    let splitPlaneCandidates = ~[nPrims:SplitPlaneCandidate];
    let leftPrims = ~[nPrims*depthLimit:uint];
    let rightPrims = ~[nPrims*depthLimit:uint];
    let mut allPrims = ~[nPrims:uint];

    for primIdx in urange(0u, nPrims) {
        let bounds = @primBounds(nPrims);
        primData(nPrims) = PrimData{ bounds:bounds, centroid:@primCentroid(nPrims) };
        totalBounds = bbextendb(totalBounds, bounds);
        allPrims(primIdx) = nPrims; // TODO get rid of this array, it's just used to pass the initial to-split-list...
    }

    buildBvhNode(allPrims, nPrims, totalBounds, 0u, leftPrims, rightPrims,
            &bvhNodes, primFinalize);

}

/* Build a BVH node from the primitives (in splitPrims). These are indices into the tris vector above!
 * Put primitives into triBuf (starting at offset triBufOff), and the flattened nodes into nodeBuf.
 * Return the index of the root (in nodeBuf).
 */
fn buildBvhNode(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, mut leftPrims: &[uint], mut rightPrims: &[uint],
        bvhNodes: &DynArray, primFinalize: primFinalizeFn) -> uint
{
    let mut node:BVHNode;
    node.bbox = totalBounds;

    // split
    let mut splitInfo = NodeSplitInformation{ left:leftPrims, right:rightPrims, leftBBox:@bboxEmpty(), rightBBox:@bboxEmpty(), bestAxis: -1,
            nLeft: 0u, bestCost: 0.0f };
    bvhDecideSplit(prims, nPrims, totalBounds, depth, &splitInfo);

    // did we get a leaf?
    if (splitInfo.bestAxis < 0) {
        // create a leaf
        node.nPrims = nPrims as u16;
        for primIdxIdx in urange(0u, nPrims) {
            let primFinalIdx = primFinalize(prims(primIdxIdx));
            if primIdxIdx == 0u {
                // store the final index of the first primitive
                node.sndChildFirstPrim = primFinalIdx;
            }
        }
        return(dynArrayAppend(bvhNodes, &node as &u8))
    }

    // Create an inner node
    // node.secondChild is not yet known, will be fixed up below
    node.axis = splitInfo.bestAxis as u16;
    node.nPrims = 0u16;
    let nodeIdx = dynArrayAppend(bvhNodes, &node as &u8);

    // Process child nodes recursively, using space further down in our arrays (after the space in leftPrims, rightPrims that we needed)
    assert(||splitInfo.nLeft <= nPrims, "Keeping too many primitives");
    let firstChild =  buildBvhNode(leftPrims , splitInfo.nLeft       , splitInfo.leftBBox , depth+1u, &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32],
            bvhNodes, primFinalize);
    let secondChild = buildBvhNode(rightPrims, nPrims-splitInfo.nLeft, splitInfo.rightBBox, depth+1u, &leftPrims(nPrims) as &[u32], &rightPrims(nPrims) as &[u32],
            bvhNodes, primFinalize);

    // Make sure the children's order in the vector is as expected
    assert(||firstChild == nodeIdx+1u, "Left child doesn't come right after me");

    // Now that the second child's index in the vector is known, fix it and be done
    let mut nodePtr = dynArrayFetch(bvhNodes, nodeIdx) as &BVHNode; nodePtr.sndChildFirstPrim = secondChild; // FIXME cannot put this into a single command
    return(nodeIdx)
}

fn bvhDecideSplit(prims: &[uint], nPrims: uint, totalBounds: BBox, depth: uint, splitInfo: &NodeSplitInformation) -> ()
{
    // don't do any split
}
