type SetColorFn = fn(int, int, Color) -> ();
type GetColorIFn = fn(int, int, &RTState, &RTScratch) -> Color;
type GetColorFFn = fn(float, float, &RTState, &RTScratch) -> Color;

fn renderImage(mut buf : &[u32], width : int, height : int, measureTime : bool, state : &State, body : GetColorFFn) -> ()
{
    let wf = width as float;
    let hf = height as float;
    let setcolor:SetColorFn = |x, y, col|{buf(y*width+x) = col_rgb2int(col)};
    for x, y, rtstate, scratch in renderIteration(width, height, measureTime, state, setcolor)
    {
        // render in the center of the pixel
        let nx = (x as float + 0.5f) / wf;
        let ny = (y as float + 0.5f) / hf;
        // convert to screen coordinates (remember to swap y axis)
        let sx =  (nx - 0.5f) * 2.0f;
        let sy = -(ny - 0.5f) * 2.0f;
        // render!
        body(sx, sy, rtstate, scratch) // TODO adding @ in front of the body makes compilation take... eh, long^^
    }
}

extern fn impala_render(buf : &[u32], width : int, height : int, measureTime : bool, state : &State) -> ()
{
    // FIXME sometimes the complete scene (except for the background) goes all black?!?
    for x, y, mut rtstate, scratch in renderImage(buf, width, height, measureTime, state) {
        @runIntegrator(&rtstate.integrator, &rtstate.scene, runCamera(&rtstate.cam, x, y), scratch)
    }
}

