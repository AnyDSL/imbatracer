struct BVHNode
{
    bbox : BBox,
    sndChildFirstPrim : uint, // for an inner node, the second child. for a leaf, the first primitive.
    nPrim : u16, // number of primitives in child. 0 for inner node.
    axis: u16,
}

struct BVHTraversal
{
    todo : [uint*16], // sync this with BVH construction in C++!
}
fn emptyBVHTraversal() -> BVHTraversal
{
    @BVHTraversal { todo:[0u,0u,0u,0u, 0u,0u,0u,0u, 0u,0u,0u,0u, 0u,0u,0u,0u] }
}

fn bvhBBoxComp(bounds : BBox, comp : bool) -> Point
{
    if comp { bounds.cmax } else { bounds.cmin }
}

fn bvhDirIsNeg(neg : uint, axis : uint) -> bool
{
    (neg & (1u << axis)) != 0u
}

fn bvhMakeNeg(invDir : Vec) -> uint
{
    (bool2uint(invDir.x < 0.0f)      ) |
    (bool2uint(invDir.y < 0.0f) << 1u) |
    (bool2uint(invDir.z < 0.0f) << 2u)
}

fn bvhIntersectNode(bounds : BBox, o : Point, maxDist : float, invDir : Vec, neg: uint) -> bool
{
    // Check for ray intersection against x and y slabs
    let txmin = (@bvhBBoxComp(bounds,  @bvhDirIsNeg(neg, 0u)).x - o.x) * invDir.x;
    let txmax = (@bvhBBoxComp(bounds, !@bvhDirIsNeg(neg, 0u)).x - o.x) * invDir.x;
    let tymin = (@bvhBBoxComp(bounds,  @bvhDirIsNeg(neg, 1u)).y - o.y) * invDir.y;
    let tymax = (@bvhBBoxComp(bounds, !@bvhDirIsNeg(neg, 1u)).y - o.y) * invDir.y;
    if (txmin > tymax) || (tymin > txmax)
    { false }
    else {
        let tmin = max(txmin, tymin);
        let tmax = min(txmax, tymax);
        // Check for ray intersection against z slab
        let tzmin = (@bvhBBoxComp(bounds,  @bvhDirIsNeg(neg, 2u)).z - o.z) * invDir.z;
        let tzmax = (@bvhBBoxComp(bounds, !@bvhDirIsNeg(neg, 2u)).z - o.z) * invDir.z;
        if  (tmin > tzmax) || (tzmin > tmax)
        { false }
        else
        {
            max(tmin, tzmin) < maxDist && min(tmax, tzmax) >= 0.0f
        }
    }
}

fn bvhIntersectFirst(root: uint, scene : &Scene, mut scratch : &RTScratch) -> ()
{
    let isec = &(*scratch).isec;
    let invDir = @vapply1((*isec).ray.d, |f|1.0f/f);
    let neg = @bvhMakeNeg(invDir);
    let mut todo = &(*scratch).bvh.todo;
    let done = return;

    fn rayIntersects(node : uint) -> bool {
        @bvhIntersectNode((*scene).bvhNodes(node).bbox, (*isec).ray.o, (*isec).dist, invDir, neg)
    }

    // Invariant: The ray hits curNode and everything in the stack
    fn checkAndTraverseNode(curNode : uint, todoIdx : uint)
    {
        if @rayIntersects(curNode) {
            @traverseNode(curNode, todoIdx)
        }
        else {
            @popStack(todoIdx)
        }
    }
    fn popStack(todoIdx : uint)
    {
        if todoIdx == 0u {
            @done() // DONE!
        }
        else {
            // loop with topost element popped off. this may be non-intersecting, so be sure to check.
            let todoIdxNew = todoIdx-1u;
            @checkAndTraverseNode((*todo)(todoIdxNew), todoIdxNew)
        }
    }
    fn descend(fstNode : uint, sndNode : uint, todoIdx : uint)
    {
        if @rayIntersects(fstNode) {
            // push onto stack
            (*todo)(todoIdx) = fstNode;
            @traverseNode(fstNode, todoIdx+1u) // we can immediately traverse the first node as we know it intersects
        }
        else {
            // go to 2nd node, and don't even touch the stack
            @checkAndTraverseNode(sndNode, todoIdx)
        }
    }
    fn traverseNode(curNode : uint, todoIdx : uint)
    {
        let node = (*scene).bvhNodes(curNode);
        if (node.nPrim > 0u16) {
            // a leaf
            for tri in urange(node.sndChildFirstPrim, node.sndChildFirstPrim+(node.nPrim as uint)) {
                triIntersectFirst(tri, scene, isec);
            }
            // done with this node, pop one off the stack
            @popStack(todoIdx)
        }
        else {

            // an inner node, which child do we get to first?
            if @bvhDirIsNeg(neg, node.axis as uint) {
                @descend(node.sndChildFirstPrim, curNode+1u) // do the left child later, the right child now
            }
            else {
                @descend(curNode+1u, node.sndChildFirstPrim) // do the right child later, the left child now
            }
        }
    }

    checkAndTraverseNode(root, 0u)
}
