
struct CamController
{
    moveForward : int,
    moveRight : int,
    moveLeft : int,
    moveBack : int,
    moveUp : int,
    moveDown : int,
    speed : float,
    yawAccu : float,
    pitchAccu : float,
    rollAccu : float,
    mouseButtons : [bool*3], // left, middle, right
}

fn camControllerAlloc() -> &CamController
{
    ~CamController
    {
        moveForward:0,
        moveRight:0,
        moveLeft:0,
        moveBack:0,
        moveUp:0,
        moveDown:0,
        speed:50.0f,
        yawAccu:0.0f,
        pitchAccu:0.0f,
        rollAccu:0.0f,
        mouseButtons:[false, false, false],
    }
}

fn camControllerKeyInput(mut cc : &CamController, key : int, down : bool) -> ()
{
    // G to grab mouse is handled in C++, SDLGui.cpp

         if key == 119 { cc.moveForward = bool2int(down); } // W
    else if key == 97  { cc.moveLeft    = bool2int(down); } // A
    else if key == 115 { cc.moveBack    = bool2int(down); } // S
    else if key == 100 { cc.moveRight   = bool2int(down); } // D
    else if key == 113 { cc.moveUp      = bool2int(down); } // Q
    else if key == 101 { cc.moveDown   = bool2int(down); } // E
    else { print_si("Unhandled key: ", key); }
}


fn camControllerMouseButton(mut cc : &CamController, b : int, down : bool) -> ()
{
    print_si("MB:", b);
    if b >= 1 && b <= 3 // button 0 does not exist apparently
    {
        cc.mouseButtons(b-1) = down;
    }
}

fn camControllerMouseMove(mut cc : &CamController, dx : float, dy : float) -> ()
{
    let left = cc.mouseButtons(0);
    let middle = cc.mouseButtons(1);
    let right = cc.mouseButtons(2);

    if middle
    {
        cc.rollAccu = cc.rollAccu - dx;
    }
    else
    {
        cc.yawAccu = cc.yawAccu - dx;
        cc.pitchAccu = cc.pitchAccu - dy;
    }
}


fn camControllerUpdate(cc : &CamController, mut cam : &Cam, dt : float) -> ()
{
    let c = cam.view.origin;
    let f = cam.view.forward;
    let r = cam.view.right;
    let u = cam.view.up;
    let fwd = cc.moveForward - cc.moveBack;
    let lr = cc.moveRight - cc.moveLeft;
    let ud = cc.moveDown - cc.moveUp;
    let m = dt * cc.speed;

    let f2 = vfmul(f, fwd as float);
    let u2 = vfmul(u, ud as float);
    let r2 = vfmul(r, lr as float);
    let c2 = pvadd(c, fvmul(m, vadd(f2, vadd(r2, u2))));

    cam.view.origin = c2;

    viewSetYawPitchRoll(&cam.view, cc.yawAccu, cc.pitchAccu, cc.rollAccu);
}
