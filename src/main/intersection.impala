
fn defaultRayEps() -> float
{
    2.0f*epsilon()
}

fn defaultDist() -> float
{
    1e10f // max. drawing distance
}

fn noObj() -> uint
{ 0xFFFFFFFFu }

/*
struct Intersection
{
    dist : float,
    ray : Ray,
    // cache some data during initial intersection to be used when computing the shading intersection
    tri : uint, // the triangle we hit
    b : TexCoord, // barycentric coordinates
    obj : uint, // the object our triangle belongs to (to re-apply the transformation matrix)
    unitLen : float, // the length of a unit in ray direction, in the transformed coordinate system
}

fn intersection(ray : Ray, dist: float) -> Intersection
{
    @Intersection{ dist:dist, ray:ray,
        tri:@noObj(), b:texCoord0(), obj:@noObj(), unitLen:0.0f }
}

fn improveIntersection(mut isec : &Intersection, dist : float) -> ()
{
    @assert(||dist < isec.dist, "Improved intersection must have smaller distance");
    isec.dist = dist;
}

fn intersectionWorldHitPoint(isec : &Intersection) -> Point
{
    @rayP(isec.ray,  isec.dist)
}

*/


struct ShadingIntersection // all the stuff needed for shading an intersection
{
    materialIdx : uint,
    surfaceNormal : Vec,
    shadingNormal : Vec,
    uv : TexCoord,
    local : Point,
    eps: float,
}

fn shadingIntersection() -> ShadingIntersection
{
    @ShadingIntersection{ materialIdx:0u, surfaceNormal:@vec0(), shadingNormal:@vec0(), uv:@texCoord0(), local:@point0(), eps:@defaultRayEps() }
}

