
fn defaultRayEps() -> float
{
    2.0f*epsilon()
}

fn noObj() -> uint
{ 0xFFFFFFFFu }

struct Intersection
{
    dist : float,
    obj : uint,
    ray : Ray,
    surfaceNormal : Vec,
    shadingNormal : Vec,
    uv : TexCoord,
    eps : float
}

fn emptyIntersection() -> Intersection
{
    @Intersection{ dist:-1.0f, obj:noObj(),
        ray:ray0(), surfaceNormal:vec0(), shadingNormal:vec0(), uv:texCoord0(), eps:0.0f }
}

fn beginIntersection(ray : Ray, mut isec: &Intersection) -> ()
{
    isec.dist = 1e10f; // max. drawing distance
    isec.obj = @noObj();
    isec.ray = ray;
}

fn improveIntersection(mut isec : &Intersection, dist : float, obj : uint, surfaceNormal : Vec, shadingNormal : Vec, uv : TexCoord, eps : float) -> ()
{
    @assert(||dist < isec.dist && obj != @noObj(), 23);
    isec.dist = dist;
    isec.obj = obj;
    isec.surfaceNormal = surfaceNormal;
    isec.shadingNormal = shadingNormal;
    isec.uv = uv;
    isec.eps = eps;
}

fn intersectionHitPoint(isec : &Intersection) -> Point
{
    @rayP(isec.ray,  isec.dist)
}

fn intersectionSurfaceNormalTowardsOrigin(isec : &Intersection) -> Vec
{
    if @dot(isec.surfaceNormal, isec.ray.d) >= 0.0f {
        @vflip(isec.surfaceNormal)
    }
    else {
        isec.surfaceNormal
    }
}


