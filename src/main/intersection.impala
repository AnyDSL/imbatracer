
fn defaultEps() -> float
{
    2.0f*0.00001f // FIXME: value + this should be static variable (as soon as compiler supports it)
}


struct Intersection
{
    dist : float,
    obj : &Tri, // TODO: only triangles supported for now
    ray : Ray,
    surfaceNorm : Vec,
    shadingNorm : Vec,
    uv : Point,
    kind : int, // TODO: enum
    eps : float
}

fn noIntersection() -> Intersection
{
    // TODO: there is no need to init anything but obj
    Intersection{ obj:HACK_NULL_tri(),
        dist:-1.0f, ray:ray0(), surfaceNorm:vec0(), shadingNorm:vec0(), uv:point0(), kind:0, eps:0.0f
    }
}

fn beginIntersection() -> Intersection
{
    // TODO: only dist & obj needed
    Intersection{ dist:FLT_MAX_fn(), obj:HACK_NULL_tri(),
        ray:ray0(), surfaceNorm:vec0(), shadingNorm:vec0(), uv:point0(), kind:0, eps:0.0f }
}


fn improveIntersection(mut isec : &Intersection, dist : float, obj : &Tri, surfaceNorm : Vec, shadingNorm : Vec, uv : Point, eps : float) -> ()
{
    // TODO: various assertions

    (*isec).dist = dist;
    (*isec).obj = obj;
    (*isec).surfaceNorm = surfaceNorm;
    (*isec).shadingNorm = shadingNorm;
    (*isec).uv = uv;
    (*isec).eps = eps;
}



fn triIntersectFirst(obj : &Tri, isec : &Intersection) -> ()
{
    let res = triIntersectDistance(*obj, (*isec).ray, (*isec).dist);
    let t = res(0); // TODO: would be nice to have syntax for tuple unpacking
	if t >= 0.0f
	{
	    let bar = res(1);
	    let normal = (*obj).normal;
	    improveIntersection(isec, t, obj, normal, normal, bar, defaultEps()); // FIXME
	}
}



