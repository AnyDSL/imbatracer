
fn defaultRayEps() -> float
{
    2.0f*epsilon()
}

fn noObj() -> uint
{ 0xFFFFFFFFu }

struct Intersection
{
    dist : float,
    obj : uint,
    ray : Ray,
    surfaceNormal : Vec,
    shadingNormal : Vec,
    uv : TexCoord,
    local : Point,
    eps : float
}

fn emptyIntersection() -> Intersection
{
    Intersection{ dist:-1.0f, obj:noObj(),
        ray:ray0(), surfaceNormal:vec0(), shadingNormal:vec0(), uv:texCoord0(), local:point0(), eps:0.0f }
}

fn beginIntersection(ray : Ray, isec: &mut Intersection) -> ()
{
    isec.dist = 1e10f; // max. drawing distance
    isec.obj = @noObj();
    isec.ray = ray;
}

fn improveIntersection(isec : &mut Intersection, dist : float, obj : uint, surfaceNormal : Vec, shadingNormal : Vec, uv : TexCoord, local : Point, eps : float) -> ()
{
    @assert(||dist < isec.dist && obj != @noObj(), "Improved intersection must have object at smaller distance");
    @assert(||almost(vlen(surfaceNormal), 1.0f), "Improved intersection surface normal must be normalised");
    @assert(||almost(vlen(shadingNormal), 1.0f), "Improved intersection shading normal must be normalised");
    isec.dist = dist;
    isec.obj = obj;
    isec.surfaceNormal = surfaceNormal;
    isec.shadingNormal = shadingNormal;
    isec.uv = uv;
    isec.local = local;
    isec.eps = eps;
}

fn intersectionWorldHitPoint(isec : &Intersection) -> Point
{
    @rayP(isec.ray,  isec.dist)
}

fn intersectionSurfaceNormalTowardsOrigin(isec : &Intersection) -> Vec
{
    if @dot(isec.surfaceNormal, isec.ray.d) >= 0.0f {
        @vflip(isec.surfaceNormal)
    }
    else {
        isec.surfaceNormal
    }
}


