
fn defaultRayEps() -> float
{
    2.0f*epsilon()
}

fn defaultDist() -> float
{
    1e10f // max. drawing distance
}

fn noObj() -> uint
{ 0xFFFFFFFFu }

struct Intersection
{
    dist : float,
    obj : uint,
    ray : Ray,
    // these are not really relevant for further intersections, but to compute with the data available for intersection of triangles
    surfaceNormal : Vec,
    b : TexCoord, // barycentric coordinates
    eps: float,
}

fn intersection(ray : Ray, dist: float) -> Intersection
{
    @Intersection{ dist:dist, obj:@noObj(), ray:ray,
        surfaceNormal:@vec0(), b:texCoord0(), eps:0.0f }
}

fn improveIntersection(mut isec : &Intersection, dist : float, obj : uint, surfaceNormal : Vec, b : TexCoord, eps : float) -> ()
{
    @assert(||dist < isec.dist && obj != @noObj(), "Improved intersection must have object at smaller distance");
    @assert(||almost(vlen(surfaceNormal), 1.0f), "Improved intersection surface normal must be normalised");
    isec.dist = dist;
    isec.obj = obj;
    isec.surfaceNormal = surfaceNormal;
    isec.b = b;
    isec.eps = eps;
}

fn intersectionWorldHitPoint(isec : &Intersection) -> Point
{
    @rayP(isec.ray,  isec.dist)
}

fn intersectionSurfaceNormalTowardsOrigin(isec : &Intersection) -> Vec
{
    if @dot(isec.surfaceNormal, isec.ray.d) >= 0.0f {
        @vflip(isec.surfaceNormal)
    }
    else {
        isec.surfaceNormal
    }
}


