
fn defaultRayEps() -> float
{
    2.0f*epsilon()
}

fn defaultDist() -> float
{
    1e10f // max. drawing distance
}

fn noObj() -> uint
{ 0xFFFFFFFFu }

struct Intersection
{
    dist : float,
    ray : Ray,
    // cache some data during initial intersection to be used when computing the shading intersection
    tri : uint, // the triangle we hit
    b : TexCoord, // barycentric coordinates
    obj : uint, // the object our triangle belongs to (to re-apply the transformation matrix)
}

struct ShadingIntersection // all the stuff needed for shading that's missing above
{
    materialIdx : uint,
    surfaceNormal : Vec,
    shadingNormal : Vec,
    uv : TexCoord,
    local : Point,
    eps: float,
}

fn intersection(ray : Ray, dist: float) -> Intersection
{
    @Intersection{ dist:dist, ray:ray,
        tri:@noObj(), b:texCoord0(), obj:@noObj() }
}

fn improveIntersection(mut isec : &Intersection, dist : float) -> ()
{
    @assert(||dist < isec.dist, "Improved intersection must have smaller distance");
    isec.dist = dist;
}

fn intersectionWorldHitPoint(isec : &Intersection) -> Point
{
    @rayP(isec.ray,  isec.dist)
}



