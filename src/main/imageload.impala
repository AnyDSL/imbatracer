// image manipulation functions; only required on CPU

fn imageSetRaw(mut img : Image, x : int, y : int, c : Color) -> ()
{
    img.buf((y as uint) * img.stride + (x as uint)) = c
}

/* Mipmap generation:
+---------+-----+
|         |     |
|         |  1  |
|         |     |
|    0    +--+--+
|         | 2|
|         ++-+
|         ++ <-- 3
+----+----+

It's more efficient to put the mipmaps to the right of the original, but indexing is a bit more tricky in that case
*/


fn _genMipmaps(img : Image, xoffs : int, yoffsPrev : int, w : int, h : int, srclevel : uint) -> ()
{
    let yoffsNew = if srclevel == 0u {0} else {yoffsPrev + h};
    print_siii("Calculating mipmap level <> of size <x,y>: ", (srclevel as int)+1, w/2, h/2);
    for y in rangestep(0, h, 2)
    {
        for x in rangestep(0, w, 2)
        {
            // simple 2x2 box filter for now
            let c = cmul(ccadd(ccadd(ccadd(
                imageGetRaw(img, xoffs+x  , yoffsPrev+y  ),
                imageGetRaw(img, xoffs+x+1, yoffsPrev+y  )),
                imageGetRaw(img, xoffs+x  , yoffsPrev+y+1)),
                imageGetRaw(img, xoffs+x+1, yoffsPrev+y+1)),
                0.25f);

            imageSetRaw(img, (img.w as int) + x/2, yoffsNew+(y/2), c);
        }
    }

    if w/2 > 1 && h/2 > 1
    {
        // all subsequent calls place the mipmaps to the right of the original image
        _genMipmaps(img, img.w as int, yoffsNew, w / 2, h / 2, srclevel+1u);
    }
}



// FIXME: this will NOT work for the GPU.
fn loadImage(file : &[u8]) -> Image
{
    let mut w = 0u;
    let mut h = 0u;
    let buf = image_loadraw(file, &w, &h);
    if buf == 0 as &[u32]
    {
        print_ssi("*** FAILED TO LOAD IMAGE:", file, -1);
        return(IMAGE_DUMMY)
    }

    assert(||isPowerOf2(w) && isPowerOf2(h), "Image size not power of 2!");

    let stride = w + w/2u;

    // allocate extra space for mipmap
    let mut col = ~[stride*h : Color];
    //for i in urange(0u, stride*h) @{ col(i) = color1(1.0f); } // For debugging: Make unused regions white, to spot bugs

    print_sii("Converting image of size", w as int, h as int);

    for y in urange(0u, h)
    {
        for x in urange(0u, w)
        {
            col(y*stride + x) = col_int2rgb(buf(y*w + x));
        }
    }

    thorin_free(buf as &u8);

    let img = Image{buf:col, w:w, h:h, stride:stride, _unused_padding:0u};
    _genMipmaps(img, 0, 0, w as int, h as int, 0u);

    // Dump mipmapped image
    /*{
        let mut out = img;
        out.w = out.stride;
        saveImage("mip.png", out);
    }*/

    img
}

fn saveImage(file : &[u8], img : Image) -> bool
{
    let mut ibuf = ~[img.w*img.h:u32];
    for y in urange(0u, img.h)
    {
        for x in urange(0u, img.w)
        {
            ibuf(y*img.w + x) = col_rgb2int(img.buf(y*img.stride + x));
        }
    }
    let good = image_saveraw(file, ibuf, img.w, img.h);

    thorin_free(ibuf as &u8);
    good
}

