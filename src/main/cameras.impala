
struct Cam
{
    view : View,
    param1 : float,
    param2 : float,
    camtype : int
}

extern fn impala_camInitPerspectiveLookAt(mut cam : &Cam,
        cx : float, cy : float, cz : float, atx : float, aty : float, atz : float,
        upx : float, upy : float, upz : float, verticalOpeningAngle : float, horizonalOpeningAngle : float) -> ()
{
    let center = point(cx, cy, cz);
    let at = point(atx, aty, atz);
    let up = vec(upx, upy, upz);
    *cam = Cam { camtype : 0, view : viewEx(center, to(center, at), up, tanf(verticalOpeningAngle / 2.0f), tanf(horizonalOpeningAngle / 2.0f)),
        param1: 0.0f, param2: 0.0f };
}

fn perspectiveRay(v : &View, x : float, y : float) -> Ray
{
    rayNormalize(
        (*v).origin,
        vadd((*v).forward, vadd(vfmul((*v).up, y), vfmul((*v).right, x)))
    )
}

fn orthoRay(v : &View, x : float, y : float) -> Ray
{
    ray(
        pvadd((*v).origin, vadd(vfmul((*v).up, y), vfmul((*v).right, x))),
        (*v).forward // already normalized
    )
}

fn fisheyeRay(v : &View, x : float, y : float, fov : float) -> Ray
{
    let r = sqrtf(x*x + y*y);
    let phi = atan2f(y, x);
    let theta = r * fov / 2.0f;
    let costheta = cosf(theta);
    let sintheta = sinf(theta);

    let a = vfmul((*v).forward, costheta);
    let b = vfmul((*v).up, sintheta*sinf(phi));
    let c = vfmul((*v).right, sintheta*cosf(phi));
    ray(
        (*v).origin,
        vadd(a, vadd(b, c)) // known to be normal
    )
}

fn environRay(v : &View, x : float, y : float, vertical : float, horiz : float) -> Ray
{
    let theta = y * (vertical / 2.0f);
    let phi = x * (horiz / 2.0f);
    let costheta = cosf(theta);
    let sintheta = sinf(theta);

    let a = vfmul((*v).up, sintheta);
    let b = vfmul((*v).right, costheta*sinf(phi));
    let c = vfmul((*v).forward, costheta*cosf(phi));
    ray(
        (*v).origin,
        vadd(a, vadd(b, c)) // known to be normal
    )
}

fn compileCamera(mut cam : &Cam) -> (fn(float, float) -> Ray)
{
    let ty = (*cam).camtype;
    if      ty == 0 { |x, y| perspectiveRay(&(*cam).view, x, y) }
    else if ty == 1 { |x, y| orthoRay(&(*cam).view, x, y) }
    else if ty == 2 { |x, y| fisheyeRay(&(*cam).view, x, y, (*cam).param1) }
    else if ty == 3 { |x, y| environRay(&(*cam).view, x, y, (*cam).param1, (*cam).param2) }
    else            { |x, y| ray0() } // TODO: static assert?
}

