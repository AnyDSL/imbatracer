
fn perspectiveRay(v : View, x : float, y : float) -> Ray
{
    rayNormalize(
        v.origin,
        vadd(v.forward, vadd(vfmul(v.up, y), vfmul(v.right, x)))
    )
}

fn orthoRay(v : View, x : float, y : float) -> Ray
{
    ray(
        pvadd(v.origin, vadd(vfmul(v.up, y), vfmul(v.right, x))),
        v.forward // already normalized
    )
}

// TODO: functions below should be signature compatible

fn fisheyeRay(v : View, x : float, y : float, fov : float) -> Ray
{
    let r = sqrtf(x*x + y*y);
    let phi = atan2f(y, x);
    let theta = r * fov / 2.0f;
    let costheta = cosf(theta);
    let sintheta = sinf(theta);

    let a = vfmul(v.forward, costheta);
    let b = vfmul(v.up, sintheta*sinf(phi));
    let c = vfmul(v.right, sintheta*cosf(phi));
    ray(
        v.origin,
        vadd(a, vadd(b, c)) // known to be normal
    )
}

fn environRay(v : View, x : float, y : float, vertical : float, horiz : float) -> Ray
{
    let theta = y * (vertical / 2.0f);
    let phi = x * (horiz / 2.0f);
    let costheta = cosf(theta);
    let sintheta = sinf(theta);

    let a = vfmul(v.up, sintheta);
    let b = vfmul(v.right, costheta*sinf(phi));
    let c = vfmul(v.forward, costheta*cosf(phi));
    ray(
        v.origin,
        vadd(a, vadd(b, c)) // known to be normal
    )
}
