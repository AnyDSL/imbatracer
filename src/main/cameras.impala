
struct Cam
{
    view : View,
    param1 : float,
    param2 : float,
    camtype : int
}

fn camPerspectiveLookAt(center : Point, at : Point, up : Vec, verticalOpeningAngle : float, horizonalOpeningAngle : float) -> Cam
{
    let view = @viewEx(center, to(center, at), up, cpu_tanf(verticalOpeningAngle / 2.0f), cpu_tanf(horizonalOpeningAngle / 2.0f));
    Cam { camtype : 0, view : view, param1: 0.0f, param2: 0.0f }
}

fn perspectiveRay(v : &View, x : float, y : float) -> Ray
{
    @rayNormalize(
        v.origin,
        vadd(v.forward, vadd(vfmul(v.up, y), vfmul(v.right, x)))
    )
}

fn orthoRay(v : &View, x : float, y : float) -> Ray
{
    @ray(
        pvadd(v.origin, vadd(vfmul(v.up, y), vfmul(v.right, x))),
        v.forward // already normalized
    )
}

fn fisheyeRay(v : &View, x : float, y : float, fov : float) -> Ray
{
    let r = cpu_sqrtf(x*x + y*y);
    let phi = cpu_atan2f(y, x);
    let theta = r * fov / 2.0f;
    let costheta = cpu_cosf(theta);
    let sintheta = cpu_sinf(theta);

    let a = vfmul(v.forward, costheta);
    let b = vfmul(v.up, sintheta*cpu_sinf(phi));
    let c = vfmul(v.right, sintheta*cpu_cosf(phi));
    ray(
        v.origin,
        vadd(a, vadd(b, c)) // known to be normal
    )
}

fn environRay(v : &View, x : float, y : float, vertical : float, horiz : float) -> Ray
{
    let theta = y * (vertical / 2.0f);
    let phi = x * (horiz / 2.0f);
    let costheta = cpu_cosf(theta);
    let sintheta = cpu_sinf(theta);

    let a = vfmul(v.up, sintheta);
    let b = vfmul(v.right, costheta*cpu_sinf(phi));
    let c = vfmul(v.forward, costheta*cpu_cosf(phi));
    ray(
        v.origin,
        vadd(a, vadd(b, c)) // known to be normal
    )
}

fn runCamera(cam : &mut Cam, x : float, y : float) -> Ray
{
    let ty = cam.camtype;
    if      ty == 0 { @perspectiveRay(&cam.view, x, y) }
    else if ty == 1 { @orthoRay(&cam.view, x, y) }
    else if ty == 2 { @fisheyeRay(&cam.view, x, y, cam.param1) }
    else            { @environRay(&cam.view, x, y, cam.param1, cam.param2) }
}

