struct Vec
{
    x : float,
    y : float,
    z : float
}
static Vec_SIZEOF = 3u*float_SIZEOF;

struct Point
{
    x : float,
    y : float,
    z : float
}
static Point_SIZEOF = 3u*float_SIZEOF;

struct Float4
{
    x : float,
    y : float,
    z : float,
    w : float
}
static Float4_SIZEOF = 4u*float_SIZEOF;

struct TexCoord
{
    u : float,
    v : float,
}
static TexCoord_SIZEOF = 2u*float_SIZEOF;

// Vector
fn vec(x : float, y : float, z : float) -> Vec
{
    Vec{ x:x, y:y, z:z }
}

fn vec0() -> Vec
{
    vec1(0.0f)
}

fn vec1(a : float) -> Vec
{
    Vec{ x : a, y : a, z: a }
}

fn vec_f4(f : Float4) -> Vec
{
    @assert(||almost(f.w, 0.0f), "This Float4 is not a Vec");
    vec(f.x, f.y, f.z)
}

fn vecAt(v : Vec, i : int) -> float
{
    if      i == 0 { v.x }
    else if i == 1 { v.y }
    else           { v.z }
}
fn vecLongestAxis(v: Vec) -> uint
{
    if v.x > v.y {
        if v.x > v.z { 0u } else { 2u }
    }
    else {
        if v.y > v.z { 1u } else { 2u }
    }
}
fn vecAxis(v: Vec, a: uint) -> float
{
    @assert(||a < 3u, "vecAxis: invalid axis");
    if a == 0u      { v.x }
    else if a == 1u { v.y }
    else            { v.z }
}

fn vapply1(a : Vec, f: fn(float) -> float) -> Vec
{
    Vec{ x : f(a.x), y : f(a.y), z : f(a.z) }
}

fn vvapply2(a : Vec, b : Vec, f: fn(float, float) -> float) -> Vec
{
    @Vec{ x : f(a.x, b.x), y : f(a.y, b.y), z : f(a.z, b.z) }
}
fn vfapply2(a : Vec, b : float, f: fn(float, float) -> float) -> Vec
{
    @Vec{ x : f(a.x, b), y : f(a.y, b), z : f(a.z, b) }
}
fn fvapply2(a : float, b : Vec, f: fn(float, float) -> float) -> Vec
{
    @Vec{ x : f(a, b.x), y : f(a, b.y), z : f(a, b.z) }
}

fn vclamp(v : Vec, mi : Vec, ma : Vec) -> Vec { @vmin(ma, vmax(mi, v)) }

fn vmin(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, min) }
fn vmax(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, max) }

fn vmul(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, mul) }
fn vdiv(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, div) }
fn vadd(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, add) }
fn vsub(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, sub) }

fn vfmul(a : Vec, b : float) -> Vec { @vfapply2(a, b, mul) }
fn vfdiv(a : Vec, b : float) -> Vec { @vfapply2(a, b, div) }

fn fvmul(a : float, b : Vec) -> Vec { @fvapply2(a, b, mul) }
fn fvdiv(a : float, b : Vec) -> Vec { @fvapply2(a, b, div) }

fn vabs(a : Vec) -> Vec { @vapply1(a, fabsf) }

fn vflip(a : Vec) -> Vec { @vapply1(a, neg) }

fn vdiff(a : Vec, b : Vec) -> Vec { @vabs(@vsub(a, b)) }

fn vlensq(v : Vec) -> float { v.x*v.x + v.y*v.y + v.z*v.z }

fn vlen(v : Vec) -> float { @sqrtf(@vlensq(v)) }

fn normalize(v : Vec) -> Vec { vfmul(v, 1.0f/vlen(v)) }

fn vmaxf(v : Vec) -> float { max(v.x, max(v.y, v.z)) }
fn vminf(v : Vec) -> float { min(v.x, min(v.y, v.z))}

fn dot(a : Vec, b : Vec) -> float { a.x*b.x + a.y*b.y + a.z*b.z }
fn absdot(a : Vec, b : Vec) -> float { fabsf(dot(a, b)) }
fn cross(a : Vec, b : Vec) -> Vec { Vec { x : a.y*b.z - a.z*b.y, y : a.z*b.x - a.x*b.z, z : a.x*b.y - a.y*b.x } }

fn vequals(a : Vec, b : Vec) -> bool {  a.x==b.x && a.y==b.y && a.z==b.z }

fn vminaxis(a : Vec) -> int
{
    if a.x < a.y { if a.x < a.z { 0 } else { 2 } } else { if a.y < a.z { 1 } else { 2 } }
}

fn vmaxaxis(a : Vec) -> int
{
    if a.x > a.y { if a.x > a.z { 0 } else { 2 } } else { if a.y > a.z { 1 } else { 2 } }
}

fn vorthogonal(a : Vec) -> Vec
{
    let minaxis = vminaxis(vabs(a));
    if      minaxis == 0 { Vec{ x : 0.0f, y : -a.z, z : a.y  } }
    else if minaxis == 1 { Vec{ x : -a.z, y : 0.0f, z : a.x  } }
    else                 { Vec{ x : -a.y, y : a.x,  z : 0.0f } }
}

fn orthogonalize(ref : Vec, toOrtho : Vec) -> (Vec, Vec)
{
    let third = normalize(cross(ref, toOrtho));
    let ortho = cross(third, ref);
    @assert(||dot(toOrtho, ortho) > 0.0f, "Something went wrong during orthogonalisation");
    (ortho, third)
}

fn vlerpbarp(a : Vec, b : Vec, c : Vec, w : Point) -> Vec
{
    let ap = @vfapply2(a, w.x, mul);
    let bp = @vfapply2(b, w.y, mul);
    let cp = @vfapply2(c, w.z, mul);
	@vvapply2(ap, @vvapply2(bp, cp, add), add)
}


// Point
fn point(x : float, y : float, z : float) -> Point
{
    Point{ x:x, y:y, z:z }
}

fn point1(x : float) -> Point
{
    point(x, x, x)
}

fn point0() -> Point
{
    point1(0.0f)
}

fn point_f4(f : Float4) -> Point
{
    @assert(||almost(f.w, 1.0f), "This Float4 is not a Point");
    point(f.x, f.y, f.z)
}

fn ppapply2(a : Point, b : Point, f: fn(float, float) -> float) -> Point
{
    point(f(a.x, b.x), f(a.y, b.y), f(a.z, b.z))
}

fn pfapply1(a : Point, f: fn(float) -> float) -> Point
{
    point(f(a.x), f(a.y), f(a.z))
}

fn pfapply2(a : Point, b : float, f: fn(float, float) -> float) -> Point
{
    point(f(a.x, b), f(a.y, b), f(a.z, b))
}

fn pvadd(p : Point, v : Vec) -> Point
{
    point(p.x+v.x, p.y+v.y, p.z+v.z)
}

fn pvsub(p : Point, v : Vec) -> Point
{
    point(p.x-v.x, p.y-v.y, p.z-v.z)
}

fn to(src : Point, dst : Point) -> Vec
{
    vec(dst.x - src.x, dst.y - src.y, dst.z - src.z)
}

fn ppmin(a : Point, b : Point) -> Point
{
    ppapply2(a, b, min)
}

fn ppmax(a : Point, b : Point) -> Point
{
    ppapply2(a, b, max)
}

fn plerpbarp(a : Point, b : Point, c : Point, w : Point) -> Point
{
    let ap = @pfapply2(a, w.x, mul);
    let bp = @pfapply2(b, w.y, mul);
    let cp = @pfapply2(c, w.z, mul);
	@ppapply2(ap, @ppapply2(bp, cp, add), add)
}
fn pointAxis(p: Point, a: uint) -> float
{
    @assert(||a < 3u, "vecAxis: invalid axis");
    if a == 0u      { p.x }
    else if a == 1u { p.y }
    else            { p.z }
}


// Float4
fn float4(x : float, y : float, z : float, w : float) -> Float4
{
    Float4{ x:x, y:y, z:z, w:w }
}

fn float4_1(x : float) -> Float4
{
    float4(x, x, x, x)
}

fn float4_0() -> Float4
{
    float4_1(0.0f)
}

fn float4_v(v : Vec) -> Float4
{
    float4(v.x, v.y, v.z, 0.0f)
}
fn float4_p(p : Point) -> Float4
{
    float4(p.x, p.y, p.z, 1.0f)
}

fn f4apply2(a : Float4, b : Float4, f: fn(float, float) -> float) -> Float4
{
    float4(f(a.x, b.x), f(a.y, b.y), f(a.z, b.z), f(a.w, b.w))
}

fn f4fapply1(a : Float4,f: fn(float) -> float) -> Float4
{
    float4(f(a.x), f(a.y), f(a.z), f(a.w))
}

fn f4fapply2(a : Float4, b : float, f: fn(float, float) -> float) -> Float4
{
    float4(f(a.x, b), f(a.y, b), f(a.z, b), f(a.w, b))
}

fn f4mul(a : Float4, b : Float4) -> Float4 { @f4apply2(a, b, mul) }
fn f4add(a : Float4, b : Float4) -> Float4 { @f4apply2(a, b, add) }
fn f4scale(a : Float4, b : float) -> Float4 { @f4fapply2(a, b, mul) }


fn f4dot(a : Float4, b : Float4) -> float { a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w }

fn f4Axis(f : Float4, a: uint) -> float
{
    @assert(||a < 4u, "vecAxis: invalid axis");
    if a == 0u      { f.x }
    else if a == 1u { f.y }
    else if a == 2u { f.z }
    else            { f.w }
}

fn f4SetAxis(mut f : &Float4, a: uint, v : float) -> ()
{
    @assert(||a < 4u, "vecAxis: invalid axis");
    if a == 0u      { f.x = v }
    else if a == 1u { f.y = v }
    else if a == 2u { f.z = v }
    else            { f.w = v }
}


// TexCoord
fn texCoord(u: float, v : float) -> TexCoord
{
    TexCoord{u:u, v:v}
}
fn texCoord0() -> TexCoord
{ texCoord(0.0f, 0.0f) }


fn tfapply2(a : TexCoord, b : float, f: fn(float, float) -> float) -> TexCoord
{
    texCoord(f(a.u, b), f(a.v, b))
}

fn ttapply2(a : TexCoord, b : TexCoord, f: fn(float, float) -> float) -> TexCoord
{
    texCoord(f(a.u, b.u), f(a.v, b.v))
}

fn plerpbart(a : TexCoord, b : TexCoord, c : TexCoord, w : Point) -> TexCoord
{
    let ap = @tfapply2(a, w.x, mul);
    let bp = @tfapply2(b, w.y, mul);
    let cp = @tfapply2(c, w.z, mul);
	@ttapply2(ap, @ttapply2(bp, cp, add), add)
}


