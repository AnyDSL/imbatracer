struct Vec
{
    x : float,
    y : float,
    z : float
}

struct Point
{
    x : float,
    y : float,
    z : float
}

struct TexCoord
{
    u : float,
    v : float,
}

fn vec(x : float, y : float, z : float) -> Vec
{
    Vec{ x:x, y:y, z:z }
}

fn vec0() -> Vec
{
    vec1(0.0f)
}

fn vec1(a : float) -> Vec
{
    Vec{ x : a, y : a, z: a }
}

fn vecAt(v : Vec, i : int) -> float
{
    if      i == 0 { v.x }
    else if i == 1 { v.y }
    else           { v.z }
}

fn vapply1(a : Vec, f: fn(float) -> float) -> Vec
{
    Vec{ x : f(a.x), y : f(a.y), z : f(a.z) }
}

fn vvapply2(a : Vec, b : Vec, f: fn(float, float) -> float) -> Vec
{
    @Vec{ x : f(a.x, b.x), y : f(a.y, b.y), z : f(a.z, b.z) }
}
fn vfapply2(a : Vec, b : float, f: fn(float, float) -> float) -> Vec
{
    @Vec{ x : f(a.x, b), y : f(a.y, b), z : f(a.z, b) }
}
fn fvapply2(a : float, b : Vec, f: fn(float, float) -> float) -> Vec
{
    @Vec{ x : f(a, b.x), y : f(a, b.y), z : f(a, b.z) }
}

fn vclamp(v : Vec, mi : Vec, ma : Vec) -> Vec { @vmin(ma, vmax(mi, v)) }

fn vmin(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, min) }
fn vmax(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, max) }

fn vmul(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, mul) }
fn vdiv(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, div) }
fn vadd(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, add) }
fn vsub(a : Vec, b : Vec) -> Vec { @vvapply2(a, b, sub) }

fn vfmul(a : Vec, b : float) -> Vec { @vfapply2(a, b, mul) }
fn vfdiv(a : Vec, b : float) -> Vec { @vfapply2(a, b, div) }

fn fvmul(a : float, b : Vec) -> Vec { @fvapply2(a, b, mul) }
fn fvdiv(a : float, b : Vec) -> Vec { @fvapply2(a, b, div) }

fn vabs(a : Vec) -> Vec { @vapply1(a, fabsf) }

fn vflip(a : Vec) -> Vec { @vapply1(a, neg) }

fn vdiff(a : Vec, b : Vec) -> Vec { @vabs(@vsub(a, b)) }

fn vlensq(v : Vec) -> float { v.x*v.x + v.y*v.y + v.z*v.z }

fn vlen(v : Vec) -> float { @sqrtf(@vlensq(v)) }

fn normalize(v : Vec) -> Vec { vfmul(v, 1.0f/vlen(v)) }

fn vmaxf(v : Vec) -> float { max(v.x, max(v.y, v.z)) }
fn vminf(v : Vec) -> float { min(v.x, min(v.y, v.z))}

fn dot(a : Vec, b : Vec) -> float { a.x*b.x + a.y*b.y + a.z*b.z }
fn absdot(a : Vec, b : Vec) -> float { fabsf(dot(a, b)) }
fn cross(a : Vec, b : Vec) -> Vec { Vec { x : a.y*b.z - a.z*b.y, y : a.z*b.x - a.x*b.z, z : a.x*b.y - a.y*b.x } }

fn vequals(a : Vec, b : Vec) -> bool {  a.x==b.x && a.y==b.y && a.z==b.z }

fn vminaxis(a : Vec) -> int
{
    if a.x < a.y { if a.x < a.z { 0 } else { 2 } } else { if a.y < a.z { 1 } else { 2 } }
}

fn vmaxaxis(a : Vec) -> int
{
    if a.x > a.y { if a.x > a.z { 0 } else { 2 } } else { if a.y > a.z { 1 } else { 2 } }
}

fn vorthogonal(a : Vec) -> Vec
{
    let minaxis = vminaxis(vabs(a));
    if      minaxis == 0 { Vec{ x : 0.0f, y : -a.z, z : a.y  } }
    else if minaxis == 1 { Vec{ x : -a.z, y : 0.0f, z : a.x  } }
    else                 { Vec{ x : -a.y, y : a.x,  z : 0.0f } }
}

fn orthogonalize(ref : Vec, toOrtho : Vec) -> (Vec, Vec)
{
    let third = normalize(cross(ref, toOrtho));
    let ortho = cross(third, ref);
    @assert(||dot(toOrtho, ortho) > 0.0f, 22);
    (ortho, third)
}

fn vlerpbarp(a : Vec, b : Vec, c : Vec, w : Point) -> Vec
{
    let ap = @vfapply2(a, w.x, mul);
    let bp = @vfapply2(b, w.y, mul);
    let cp = @vfapply2(c, w.z, mul);
	@vvapply2(ap, @vvapply2(bp, cp, add), add)
}



fn point(x : float, y : float, z : float) -> Point
{
    Point{ x:x, y:y, z:z }
}

fn point1(x : float) -> Point
{
    point(x, x, x)
}

fn point0() -> Point
{
    point1(0.0f)
}

fn ppapply2(a : Point, b : Point, f: fn(float, float) -> float) -> Point
{
    point(f(a.x, b.x), f(a.y, b.y), f(a.z, b.z))
}

fn pfapply2(a : Point, b : float, f: fn(float, float) -> float) -> Point
{
    point(f(a.x, b), f(a.y, b), f(a.z, b))
}

fn pvadd(p : Point, v : Vec) -> Point
{
    point(p.x+v.x, p.y+v.y, p.z+v.z)
}

fn pvsub(p : Point, v : Vec) -> Point
{
    point(p.x-v.x, p.y-v.y, p.z-v.z)
}

fn to(src : Point, dst : Point) -> Vec
{
    vec(dst.x - src.x, dst.y - src.y, dst.z - src.z)
}

fn ppmin(a : Point, b : Point) -> Point
{
    ppapply2(a, b, min)
}

fn ppmax(a : Point, b : Point) -> Point
{
    ppapply2(a, b, max)
}

fn plerpbarp(a : Point, b : Point, c : Point, w : Point) -> Point
{
    let ap = @pfapply2(a, w.x, mul);
    let bp = @pfapply2(b, w.y, mul);
    let cp = @pfapply2(c, w.z, mul);
	@ppapply2(ap, @ppapply2(bp, cp, add), add)
}


fn UV(u: float, v : float) -> TexCoord
{
    TexCoord{u:u, v:v}
}


