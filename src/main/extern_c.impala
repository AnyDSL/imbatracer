
type size_t = u64; // FIXME: should be size_t (esp. for 32 bit arch!)

// CPU-only functions
extern "C"
{
    // Debugging
    fn print_s(&[u8]) -> ();
    fn print_si(&[u8], int) -> ();
    fn print_sptr(&[u8], &u8) -> ();
    fn print_ssi(&[u8], &[u8], int) -> ();
    fn print_sii(&[u8], int, int) -> ();
    fn print_siii(&[u8], int, int, int) -> ();
    fn print_sif(&[u8], int, float) -> ();
    fn print_sf(&[u8], float) -> ();
    fn print_sff(&[u8], float, float) -> ();
    fn print_sfff(&[u8], float, float, float) -> ();
    fn print_sffff(&[u8], float, float, float, float) -> ();
    fn assert_failed(&[u8]) -> ();

    // gui integration
    fn set_pixelscale(&u8, float) -> ();
    fn get_pixelscale(&u8) -> float;

    // load stuff
    fn image_loadraw(file : &[u8], w : &uint, h : &uint) -> &[u32];

    // object loader
    fn load_object_from_file(path: &[u8], filename: &[u8], flags: uint, matOverride: &[uint], scene: &Scene, tris: &Tris) -> ();

    // runtime, but not yet provided by thorin
    fn thorin_free(&u8) -> ();
    fn memset(&u8, int, size_t) -> ();
    fn memcpy(&u8, &u8, size_t) -> ();
}

// some derived forms
fn print_sv(s : &[u8], v : Vec) -> ()
{
    print_sfff(s, v.x, v.y, v.z);
}
fn print_sp(s : &[u8], p : Point) -> ()
{
    print_sfff(s, p.x, p.y, p.z);
}
fn print_sc(s : &[u8], c : Color) -> ()
{
    print_sfff(s, c.r, c.g, c.b);
}

fn print_f4(s : &[u8], f : Float4) -> ()
{
    print_sffff(s, f.x, f.y, f.z, f.w)
}

fn print_matrix(s : &[u8], m : Matrix) -> ()
{
    print_f4(s, m.rows(0));
    print_f4(s, m.rows(1));
    print_f4(s, m.rows(2));
    print_f4(s, m.rows(3));
}


