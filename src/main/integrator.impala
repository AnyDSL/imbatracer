
struct Integrator
{
    // for debugger
    minDist : float,
    maxDist : float,
    mode : int,

    itype : int
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(isec : &Intersection) -> Color
{
    @color1(absdot((*isec).shadingNormal, (*isec).ray.d)) // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(isec : &Intersection) -> Color
{
    let n = (*isec).shadingNormal;
    @color(n.x, n.y, n.z)
}

fn debugRadianceNormalSign(isec : &Intersection) -> Color
{
    let n = (*isec).shadingNormal;
    @color(@scaleLin(n.x, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.y, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.z, -1.0f, 1.0f, 0.0f, 1.0f))
}

fn debugRadianceDepth(isec : &Intersection) -> Color
{
    let mindist = 5.0f;
    let maxdist = 100.0f;
    let d = clamp(mindist, (*isec).dist, maxdist);
    let v = @scaleLin(d, mindist, maxdist, 1.0f, 0.0f);
    @color(v, v, v)
}

fn integrateLightSources(scratch : &RTScratch, scene : &Scene, hitP : Point, outDir : Vec, shadingN : Vec, local : Point, matReflectance : fn(Point, Vec, Vec, Vec) -> Color, rayEps : float) -> Color
{
    let mut c = @color0();

    for i in @urange(0u, (*scene).nLights)
    {
        let lF = @buildLight((*scene).lights(i));
        let hitF = lF(0);
        let intensityF = lF(1);

        let mut lhit = hitF(hitP);
        @assert(||{almost(vlensq(lhit.dir), 1.0f)}, 1001);

        if @dot(lhit.dir, shadingN) > 0.0f // light comes towards us, on same side of surface?
        {
            let irrIntensity = @intensityF(lhit);
            let reflected = @matReflectance(local, shadingN, outDir, lhit.dir);
            let contrib = @ccapply2(irrIntensity, reflected, mul);

            @assert(||{!cAny(contrib, isneg)}, 1002);

            if cAny(contrib, isstrictpos)
            {
                let shadowRay = @ray(pvadd(hitP, vfmul(lhit.dir, rayEps)), lhit.dir);
                lhit.dist = lhit.dist - 2.0f*rayEps; // we substract rayEps at both ends
                if true //@sceneIntersectAny(scene, scratch, shadowRay, lhit.dist-rayEps)
                {
                    c = @ccapply2(c, contrib, add); // light shines on hit point
                }
            }
        }
    }
    c
}

fn raytraceRadiance(isec : &Intersection, scene : &Scene, scratch : &RTScratch) -> Color
{
    let outDir = @vflip((*isec).ray.d);
    //let inDir =

    // HACK: that there's some material to test
    let matinfo = @dummyMaterial();
    let mat = @buildMaterial(matinfo);
    let reflectance = mat(0);
    let emission = mat(1);

    let local = (*isec).uv;
    let hitP = @intersectionHitPoint(isec);

	@ccadd(
        // we ignore any contribution not coming directly from a light source
        integrateLightSources(scratch, scene, hitP, outDir, (*isec).shadingNormal, local, reflectance, (*isec).eps),
        // and add the material's own light emission that is not dependent on light
        emission(local, (*isec).shadingNormal, outDir)
    )
}


fn recraytraceRadiance(isec : &Intersection, scene : &Scene, scratch : &RTScratch) -> Color
{
    color0() // TODO
}

fn makeDistanceScaled(minDist: float, maxDist: float, isec : &Intersection, getcol: fn(&Intersection) -> Color) -> Color
{
    if maxDist <= minDist {
        getcol(isec)
    }
    else {
        let t = scaleLin((*isec).dist, minDist, maxDist, 1.0f, 0.0f);
        clerp(getcol(isec), color0(), t)
    }
}

fn debuggerRadiance(mode: int, minDist: float, maxDist: float, isec : &Intersection) -> Color
{
    makeDistanceScaled(minDist, maxDist, isec,
            if      mode == 0 { debugRadianceNormalDir }
            else if mode == 1 { debugRadianceNormalSign }
            else              { debugRadianceDepth }
        )
}

fn getRadianceForHit(integr : &Integrator, isec : &Intersection, scene : &Scene, scratch : &RTScratch) -> Color
{
    let ty = (*integr).itype;
    if      ty == 0 { cosineRadiance(isec) }  // Cosine shading
    else if ty == 1 { raytraceRadiance(isec, scene, scratch) }
    else if ty == 2 { recraytraceRadiance(isec, scene, scratch) }
    else            { debuggerRadiance((*integr).mode, (*integr).minDist, (*integr).maxDist, isec) }
}

fn runIntegrator(integr : &Integrator, scene : &Scene, ray : Ray, mut scratch : &RTScratch) -> Color
{
    let isec = &(*scratch).isec;
    @beginIntersection(ray, isec);
    @sceneIntersectFirst(scene, scratch);

    if (*isec).obj == @noObj() {
        @color(1.0f, 0.0f, 0.0f)
    }
    else {
        @getRadianceForHit(integr, isec, scene, scratch)
    }
}

