
struct Integrator
{
    // for debugger
    minDist : float,
    maxDist : float,
    mode : int,

    itype : int
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(isec : &Intersection) -> Color
{
    @color1(absdot(isec.shadingNormal, isec.ray.d)) // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(isec : &Intersection) -> Color
{
    let n = isec.shadingNormal;
    @color(n.x, n.y, n.z)
}

fn debugRadianceNormalSign(isec : &Intersection) -> Color
{
    let n = isec.shadingNormal;
    @color(@scaleLin(n.x, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.y, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.z, -1.0f, 1.0f, 0.0f, 1.0f))
}

fn debugRadianceDepth(isec : &Intersection) -> Color
{
    let mindist = 5.0f;
    let maxdist = 100.0f;
    let d = clamp(mindist, isec.dist, maxdist);
    let v = @scaleLin(d, mindist, maxdist, 1.0f, 0.0f);
    @color1(v)
}

fn integrateLightSources(scratch : &RTScratch, scene : &Scene, hitP : Point, outDir : Vec, surfaceN : Vec, shadingN : Vec, uv : TexCoord, local : Point,
                         matReflectance : ReflectanceFn, rayEps : float) -> Color
{
    let mut c = @color0();

    for i in @urange(0u, scene.nLights)
    {
        let lF = @buildLight(scene.lights(i));
        let hitF:LightHitFn = lF(0);

        let lhit = hitF(hitP);
        @assert(||almost(vlensq(lhit.dir), 1.0f), "Light source hit direction must be normalised");

        if @dot(lhit.dir, surfaceN) >= 0.0f // light comes towards us, on same side of surface?
        {
            let intensityF:LightIntensityFn = lF(1);
            let irrIntensity = @intensityF(lhit);
            let reflected = @matReflectance(uv, local, shadingN, outDir, lhit.dir);
            let contrib = @ccapply2(irrIntensity, reflected, mul);

            @assert(||{!cAny(contrib, isneg)}, "Lights cannot have negative contribution");

            if @cAny(contrib, isstrictpos)
            {
                let shadowRay = @ray(pvadd(hitP, vfmul(surfaceN, rayEps)), lhit.dir);
                let mut dist = lhit.dist - 2.0f*rayEps; // we substract rayEps at both ends
                if !@sceneIntersectAny(scene, scratch, shadowRay, &mut dist)
                {
                    c = @ccapply2(c, contrib, add); // light shines on hit point
                }
            }
        }
    }
    c
}

fn raytraceRadiance(isec : &Intersection, scene : &Scene, scratch : &RTScratch) -> Color
{
    let outDir = @vflip(isec.ray.d);
    let surfaceN = @intersectionSurfaceNormalTowardsOrigin(isec);

    // HACK: that there's some material to test
    let matinfo = if @triHasMaterial(isec.obj, scene) { @triMaterial(isec.obj, scene) } else { @dummyMaterial() };
    let mat = @buildMaterial(matinfo, scene);
    let reflectance = mat(0);
    let emission = mat(1);

    let uv = isec.uv;
    let local = isec.local;
    let hitP = @intersectionWorldHitPoint(isec);

	@ccadd(
        // we ignore any contribution not coming directly from a light source
        integrateLightSources(scratch, scene, hitP, outDir, surfaceN, isec.shadingNormal, uv, local, reflectance, isec.eps),
        // and add the material's own light emission that is not dependent on light
        emission(uv, local, surfaceN, outDir)
    )
}


fn recraytraceRadiance(isec : &Intersection, scene : &Scene, scratch : &RTScratch) -> Color
{
    color0() // TODO
}

fn makeDistanceScaled(minDist: float, maxDist: float, isec : &Intersection, getcol: fn(&Intersection) -> Color) -> Color
{
    if maxDist <= minDist {
        getcol(isec)
    }
    else {
        let t = scaleLin(isec.dist, minDist, maxDist, 1.0f, 0.0f);
        clerp(getcol(isec), color0(), t)
    }
}

fn debuggerRadiance(mode: int, minDist: float, maxDist: float, isec : &Intersection) -> Color
{
    makeDistanceScaled(minDist, maxDist, isec,
            if      mode == 0 { debugRadianceNormalDir }
            else if mode == 1 { debugRadianceNormalSign }
            else              { debugRadianceDepth }
        )
}

fn getRadianceForHit(integr : &Integrator, isec : &Intersection, scene : &Scene, scratch : &RTScratch) -> Color
{
    let ty = integr.itype;
    if      ty == 0 { cosineRadiance(isec) }  // Cosine shading
    else if ty == 1 { raytraceRadiance(isec, scene, scratch) }
    else if ty == 2 { recraytraceRadiance(isec, scene, scratch) }
    else            { debuggerRadiance(integr.mode, integr.minDist, integr.maxDist, isec) }
}

fn runIntegrator(integr : &Integrator, scene : &Scene, ray : Ray, scratch : &mut RTScratch) -> Color
{
    let isec = &mut scratch.isec;
    @beginIntersection(ray, isec);
    @sceneIntersectFirst(scene, scratch);

    if isec.obj == @noObj() {
        @color(1.0f, 0.0f, 0.0f)
    }
    else {
        @getRadianceForHit(integr, isec, scene, scratch)
    }
}

