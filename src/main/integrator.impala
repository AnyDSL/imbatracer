
struct Integrator
{
    maxDist : float,
    maxRecDepth : float,
    mode : int, // for debugger

    itype : int
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(isec : Intersection) -> Color
{
    vec1(absdot(isect.norm, isect.ray.d)); // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(isec : Intersection) -> Color
{
    let n = ray.isect.norm
}

fn debugRadianceNormalSign(isec : Intersection) -> Color
{
}

fn debugRadianceDepth(isec : Intersection) -> Color
{
}

fn raytraceRadiance(isec : Intersection) -> Color
{
    color0() // TODO
}

fn recraytraceRadiance(isec : Intersection) -> Color
{
    color0() // TODO
}

fn getRadianceForHitFn(integr : Integrator) -> fn(Intersection) -> Color
{
    let ty = integr.itype
    else if ty == 0 { cosineRadiance }
    else if ty == 1 { raytraceRadiance }
    else if ty == 2 { recraytraceRadiance }
    else
    {
        let mode = integr.mode;
        if      mode == 0 { debugRadianceNormalDir }
        else if mode == 1 { debugRadianceNormalSign }
        else              { debugRadianceDepth }
    }
}

fn getRadiance(scene : &Scene, hit : fn(Ray) -> Color, nohit : fn() -> Color) -> Color
{
    let isec = @beginIntersection();

    //intersectWithScene(scene, &isec);
    triIntersectScene(scene, isec);

    if isec.obj == @noObj() { nohit() } else { hit(isec) }
}


fn getRadFn(integr : Integrator, scene : &Scene) -> fn(Ray) -> Color
{
    local hit = getRadianceForHitFn(integr);
    local nohit = color0();

    |ray : Ray| -> Color { getRadiance(scene, hit, nohit) }
}

