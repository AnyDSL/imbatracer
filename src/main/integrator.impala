
struct Integrator
{
    minDist : float,
    maxDist : float,
    maxRecDepth : float,
    mode : int, // for debugger

    itype : int
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(isec : Intersection) -> Color
{
    color1(absdot(isec.norm, isec.ray.d)) // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(isec : Intersection) -> Color
{
    let n = isec.norm;
    color(n.x, n.y, n.z)
}

fn debugRadianceNormalSign(isec : Intersection) -> Color
{
    let n = isec.norm;
    @color(@scaleLin(n.x, -1.f, 1.f, 0.f, 1.f),
           @scaleLin(n.y, -1.f, 1.f, 0.f, 1.f),
           @scaleLin(n.z, -1.f, 1.f, 0.f, 1.f))
}

fn debugRadianceDepth(isec : Intersection) -> Color
{
    color1(1.0f)
}

fn raytraceRadiance(isec : Intersection) -> Color
{
    color0() // TODO
}

fn recraytraceRadiance(isec : Intersection) -> Color
{
    color0() // TODO
}

fn makeDistanceScaled(minDist: float, maxDist: float, getcol: fn(Intersection) -> Color) -> fn(Intersection) -> Color
{
    if maxDist <= minDist
    { getcol }
    else
    {
        |isec : Intersection| -> Color
        {
            let t = scaleLin(isec.dist, minDist, maxDist, 1.0f, 0.0f);
            clerp(getcol(isec), color0(), t)
        }
    }
}

fn debuggerRadiance(mode: int, minDist: float, maxDist: float) -> fn(Intersection) -> Color
{
    makeDistanceScaled(minDist, maxDist,
            if      mode == 0 { debugRadianceNormalDir }
            else if mode == 1 { debugRadianceNormalSign }
            else              { debugRadianceDepth }
        )
}

fn getRadianceForHitFn(integr : &Integrator) -> fn(Intersection) -> Color
{
    let ty = (*integr).itype;
         if ty == 0 { cosineRadiance }  // Cosine shading
    else if ty == 1 { raytraceRadiance }
    else if ty == 2 { recraytraceRadiance }
    else            { debuggerRadiance((*integr).mode, (*integr).minDist, (*integr).maxDist) }
}

fn getRadiance(ray : Ray, scene : fn(&Intersection) -> (), hit : fn(Intersection) -> Color, nohit : Color) -> Color
{
    let mut isec = @beginIntersection(ray);

    scene(&isec);

    if isec.obj == @noObj() { nohit } else { hit(isec) }
}

fn compileIntegrator(integr : &Integrator, scene : fn(&Intersection) -> ()) -> fn(Ray) -> Color
{
    let hit = getRadianceForHitFn(integr);
    let nohit = color(1.0f, 0.0f, 0.0f);

    |ray : Ray| -> Color { getRadiance(ray, scene, hit, nohit) }
}

