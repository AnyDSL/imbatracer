
struct Integrator
{
    // for debugger
    minDist : float,
    maxDist : float,
    mode : int, //4:debug, 2:recraytrace, 1:raytrace, 0:cosine

    itype : int,
    maxRecDepth : uint,
}
static Integrator_SIZEOF = 5u*int_SIZEOF;

struct ShadingData
{
    materials: DynArray, // &[Material],
    textures : DynArray, // &[Texture],

    lights: DynArray, // &[Light],
}
fn initShadingData() -> ShadingData
{
    ShadingData{ materials: @dynArray(Material_SIZEOF, "ShadingData.materials"), textures: @dynArray(Texture_SIZEOF, "ShadingData.textures"),
                 lights: @dynArray(Light_SIZEOF, "ShadingData.lights") }
}

struct RTShadingData
{
    materials: &[Material],
    textures : &[Texture],

    lights: &[Light],
    nLights : uint,
}
static RTShadingData_SIZEOF = 4u*pointer_SIZEOF; // this includes padding that I think will be there...

fn shadingDataCompile(mut shadingData: &ShadingData, mut rtShadingData: &RTShadingData) -> ()
{
    rtShadingData.materials = dynArrayData(&shadingData.materials) as &[Material];
    rtShadingData.textures = dynArrayData(&shadingData.textures) as &[Texture];
    rtShadingData.lights = dynArrayData(&shadingData.lights) as &[Light];
    rtShadingData.nLights = dynArraySize(&shadingData.lights);
}
fn shadingDataFree(shadingData: &RTShadingData) -> ()
{
    thorin_free(shadingData.materials as &u8);
    thorin_free(shadingData.textures as &u8);
    thorin_free(shadingData.lights as &u8);
}


static BVH_DEPTH_LIMIT = 16u; // keep in sync with the stack size below

struct RTStack
{
    inner : [uint*16],
    outer : [uint*16],
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(ray: Ray, dist:float, sisec: &ShadingIntersection) -> Color
{
    @color1(absdot(sisec.shadingNormal, ray.d)) // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(dist:float, sisec: &ShadingIntersection) -> Color
{
    let n = sisec.surfaceNormal;
    @color(n.x, n.y, n.z)
}

fn debugRadianceNormalSign(dist:float, sisec: &ShadingIntersection) -> Color
{
    let n = sisec.surfaceNormal;
    @color(@scaleLin(n.x, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.y, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.z, -1.0f, 1.0f, 0.0f, 1.0f))
}


static debug_lodcolors = [@color1(1.0f), @color(1.0f, 0.0f, 0.0f), @color(0.0f, 1.0f, 0.0f), @color(0.0f, 0.0f, 1.0f), @color(1.0f, 1.0f, 0.0f)];

fn debugRadianceLODLevel(ray: Ray, dist: float, sisec: &ShadingIntersection) -> Color
{
    let ilod = distanceToLODLevel(dist) as int;
    if ilod > 5
    {
        color0()
    }
    else
    {
        let c = debug_lodcolors(ilod);
        let brightness = absdot(sisec.shadingNormal, ray.d);
        cmul(c, brightness)
    }
}


fn integrateLightSources(mut scene : &RTScene, hitP : Point, outDir : Vec, surfaceN : Vec, shadingN : Vec, uv : TexCoord, local : Point,
                         mat : &Material, rayEps : float, stack : &RTStack) -> Color
{
    let mut c = @color0();

    for i in @urange(0u, scene.shadingData.nLights)
    {
        let light = &scene.shadingData.lights(i);
        let lhit = evalLightHit(light, hitP);
        @assert(||almost(vlensq(lhit.dir), 1.0f), "Light source hit direction must be normalised");

        if @dot(lhit.dir, surfaceN) >= 0.0f // light comes towards us, on same side of surface?
        {
            let irrIntensity = @evalLightIntensity(light, lhit);
            let reflected = @evalMaterialReflectance(uv, local, shadingN, outDir, lhit.dir, mat, &scene.shadingData);
            let contrib = @ccapply2(irrIntensity, reflected, mul);
            //print_sc("Total contrib", contrib);

            @assert(||{!cAny(contrib, isneg)}, "Lights cannot have negative contribution");

            if @cAny(contrib, isstrictpos)
            {
                let mut shadowRay = @ray(pvadd(hitP, vfmul(surfaceN, rayEps)), lhit.dir);
                let dist = lhit.dist - 2.0f*rayEps; // we substract rayEps at both ends
                if @!sceneIntersectAny(scene, &shadowRay, dist, stack)
                {
                    c = @ccapply2(c, contrib, add); // light shines on hit point
                }
            }
        }
    }
    c
}

fn raytraceRadiance(ray: Ray, dist:float, sisec: &ShadingIntersection, mut scene : &RTScene, stack : &RTStack) -> Color
{
    let outDir = @vflip(ray.d);
    let surfaceN = @normalTowardsOrigin(sisec.surfaceNormal, ray);
    let mat = &scene.shadingData.materials(sisec.materialIdx);
    let uv = sisec.uv;
    let local = sisec.local;
    let hitP = @rayP(ray, dist);

	@ccadd(
        // we ignore any contribution not coming directly from a light source
        @integrateLightSources(scene, hitP, outDir, surfaceN, sisec.shadingNormal, uv, local, mat, sisec.eps, stack),
        // and add the material's own light emission that is not dependent on light
        evalMaterialEmission(uv, local, surfaceN, outDir, mat, &scene.shadingData)
    )
}


fn recraytraceRadiance(theRay: Ray, dist:float, sisec: &ShadingIntersection, mut scene : &RTScene, integr : &Integrator, recRemain : uint, stack : &RTStack) -> Color
{
    let outDir = @vflip(theRay.d);
    let surfaceN = @normalTowardsOrigin(sisec.surfaceNormal, theRay);
    let mat = &scene.shadingData.materials(sisec.materialIdx);
    let uv = sisec.uv;
    let local = sisec.local;
    let hitP = @rayP(theRay, dist);
    let sampling = mat.sampling;

    let mut c = @color0();

    if sampling != SAMPLING_NOT_NEEDED && recRemain > 0u
    {
        let sampleId = 0u;
        for sampleId in urange(0u, mat.nSamples)
        {
            let sr = evalMaterialSampleReflectance(mat, local, sisec.shadingNormal, outDir, sampleId);
            if cAny(sr.reflectance, isstrictpos)
            {
                let startPos:Point = @pvadd(hitP, vfmul(sr.direction, sisec.eps));
                let recray = @ray(startPos, sr.direction);
                // partial specialize for rec raytrace so we get rid of the branching in getRadianceForHit()
                let rc = $runIntegratorRec(2, integr, scene, recray, recRemain-1u, stack); // TODO: enable PE again
                @assert(||{!cAny(sr.reflectance, isneg)}, "light stolen!");
                c = @ccadd(c, @ccmul(rc, sr.reflectance));
            }
        }
        c = cmul(c, 1.0f / (mat.nSamples as int as float));
    }
    if sampling != SAMPLING_ALL
    {
        let cl = @integrateLightSources(scene, hitP, outDir, surfaceN, sisec.shadingNormal, uv, local, mat, sisec.eps, stack);
        c = @ccadd(c, cl);
    }

    @ccadd(c, evalMaterialEmission(uv, local, surfaceN, outDir, mat, &scene.shadingData))
}

fn makeDistanceScaled(minDist: float, maxDist: float, dist:float, sisec: &ShadingIntersection, getcol: fn(float, &ShadingIntersection) -> Color) -> Color
{
    if maxDist <= minDist {
        @getcol(dist, sisec)
    }
    else {
        let t = scaleLin(dist, minDist, maxDist, 1.0f, 0.0f);
        clerp(@getcol(dist, sisec), color0(), t)
    }
}

fn debuggerRadiance(mode: int, minDist: float, maxDist: float, dist:float, sisec: &ShadingIntersection) -> Color
{
    @makeDistanceScaled(minDist, maxDist, dist, sisec,
            if      mode == 0 { debugRadianceNormalDir }
            else if mode == 1 { debugRadianceNormalSign }
            else              { |_, __, ___|color1(1.0f) } // FIXME this is broken
        )
}

fn getRadianceForHit(ty : int, integr : &Integrator, ray: Ray, dist:float, sisec: &ShadingIntersection, scene : &RTScene, recRemain : uint, stack : &RTStack) -> Color
{
    if      ty == 0 { cosineRadiance(ray, dist, sisec) }
    else if ty == 1 { raytraceRadiance(ray, dist, sisec, scene, stack) }
    else if ty == 2 { recraytraceRadiance(ray, dist, sisec, scene, integr, recRemain, stack) } // TODO the GPU crashes if we enable this
    //else if ty == 3 { debugRadianceLODLevel(ray, dist, sisec) }
    else            { debuggerRadiance(integr.mode, integr.minDist, integr.maxDist, dist, sisec) }
}

fn runIntegratorRec(ty : int, integr : &Integrator, scene : &RTScene, mut ray : Ray, recRemain : uint, stack : &RTStack) -> Color
{
    //let mut isec = @intersection(ray, @defaultDist());
    let mut sisec:ShadingIntersection;
    //print_s("Tracing a ray");
    let dist = @sceneIntersectFirst(scene, &ray, defaultDist, &sisec, stack);

    if dist >= defaultDist {
        @color(1.0f, 0.0f, 0.0f)
    }
    else {
        //@sceneShadeIntersection(scene, &isec, &sisec);
        //print_s("Doing shading");
        getRadianceForHit(ty, integr, ray, dist, &sisec, scene, recRemain, stack)
    }
}

fn runIntegrator(integr : &Integrator, scene : &RTScene, ray : Ray) -> Color
{
    let mut stack : RTStack;
    $runIntegratorRec(integr.itype, integr, scene, ray, integr.maxRecDepth, &stack)
}

