
struct Integrator
{
    // for debugger
    minDist : float,
    maxDist : float,
    mode : int,

    itype : int
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(ray: Ray, dist:float, sisec: &ShadingIntersection) -> Color
{
    @color1(absdot(sisec.shadingNormal, ray.d)) // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(dist:float, sisec: &ShadingIntersection) -> Color
{
    let n = sisec.surfaceNormal;
    @color(n.x, n.y, n.z)
}

fn debugRadianceNormalSign(dist:float, sisec: &ShadingIntersection) -> Color
{
    let n = sisec.surfaceNormal;
    @color(@scaleLin(n.x, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.y, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.z, -1.0f, 1.0f, 0.0f, 1.0f))
}

fn integrateLightSources(mut scene : &Scene, hitP : Point, outDir : Vec, surfaceN : Vec, shadingN : Vec, uv : TexCoord, local : Point,
                         mat : &Material, rayEps : float) -> Color
{
    let mut c = @color0();

    for i in @urange(0u, scene.nLights)
    {
        let light = &scene.lights(i);
        let lhit = evalLightHit(light, hitP);
        @assert(||almost(vlensq(lhit.dir), 1.0f), "Light source hit direction must be normalised");

        if @dot(lhit.dir, surfaceN) >= 0.0f // light comes towards us, on same side of surface?
        {
            let irrIntensity = @evalLightIntensity(light, lhit);
            let reflected = @evalMaterialReflectance(uv, local, shadingN, outDir, lhit.dir, mat, scene);
            let contrib = @ccapply2(irrIntensity, reflected, mul);
            //print_sc("Total contrib", contrib);

            @assert(||{!cAny(contrib, isneg)}, "Lights cannot have negative contribution");

            if @cAny(contrib, isstrictpos)
            {
                let shadowRay = @ray(pvadd(hitP, vfmul(surfaceN, rayEps)), lhit.dir);
                let dist = lhit.dist - 2.0f*rayEps; // we substract rayEps at both ends
                if @!sceneIntersectAny(scene, shadowRay, dist)
                {
                    c = @ccapply2(c, contrib, add); // light shines on hit point
                }
            }
        }
    }
    c
}

fn raytraceRadiance(ray: Ray, dist:float, sisec: &ShadingIntersection, mut scene : &Scene) -> Color
{
    let outDir = @vflip(ray.d);
    let surfaceN = @normalTowardsOrigin(sisec.surfaceNormal, ray);

    // HACK: that there's some material to test
    let mat = &scene.materials(sisec.materialIdx);

    let uv = sisec.uv;
    let local = sisec.local;
    let hitP = @rayP(ray, dist);

	@ccadd(
        // we ignore any contribution not coming directly from a light source
        @integrateLightSources(scene, hitP, outDir, surfaceN, sisec.shadingNormal, uv, local, mat, sisec.eps),
        // and add the material's own light emission that is not dependent on light
        evalMaterialEmission(uv, local, surfaceN, outDir, mat, scene)
    )
}


fn recraytraceRadiance(ray: Ray, dist:float, sisec: &ShadingIntersection, scene : &Scene) -> Color
{
    color0() // TODO
}

fn makeDistanceScaled(minDist: float, maxDist: float, dist:float, sisec: &ShadingIntersection, getcol: fn(float, &ShadingIntersection) -> Color) -> Color
{
    if maxDist <= minDist {
        @getcol(dist, sisec)
    }
    else {
        let t = scaleLin(dist, minDist, maxDist, 1.0f, 0.0f);
        clerp(@getcol(dist, sisec), color0(), t)
    }
}

fn debuggerRadiance(mode: int, minDist: float, maxDist: float, dist:float, sisec: &ShadingIntersection) -> Color
{
    @makeDistanceScaled(minDist, maxDist, dist, sisec,
            if      mode == 0 { debugRadianceNormalDir }
            else if mode == 1 { debugRadianceNormalSign }
            else              { |_, __, ___|color1(1.0f) } // FIXME this is broken
        )
}

fn getRadianceForHit(integr : &Integrator, ray: Ray, dist:float, sisec: &ShadingIntersection, scene : &Scene) -> Color
{
    let ty = integr.itype;
    if      ty == 0 { @cosineRadiance(ray, dist, sisec) }
    else if ty == 1 { @raytraceRadiance(ray, dist, sisec, scene) }
    else if ty == 2 { @recraytraceRadiance(ray, dist, sisec, scene) }
    else            { @debuggerRadiance(integr.mode, integr.minDist, integr.maxDist, dist, sisec) }
}

fn runIntegrator(integr : &Integrator, scene : &Scene, ray : Ray) -> Color
{
    //let mut isec = @intersection(ray, @defaultDist());
    let mut sisec:ShadingIntersection;
    let dist = @sceneIntersectFirst(scene, ray, defaultDist, &sisec);

    if dist >= defaultDist {
        @color(1.0f, 0.0f, 0.0f)
    }
    else {
        //@sceneShadeIntersection(scene, &isec, &sisec);
        @getRadianceForHit(integr, ray, dist, &sisec, scene)
    }
}

