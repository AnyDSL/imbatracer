
struct Integrator
{
    minDist : float,
    maxDist : float,
    maxRecDepth : float,
    mode : int, // for debugger

    itype : int
}


// return a gray color whose value is the cosine between the ray direction and the hit surface normal
fn cosineRadiance(isec : &Intersection) -> Color
{
    @color1(acc_absdot((*isec).shadingNormal, (*isec).ray.d)) // ignore normal direction by abs()ing
}

fn debugRadianceNormalDir(isec : &Intersection) -> Color
{
    let n = (*isec).shadingNormal;
    @color(n.x, n.y, n.z)
}

fn debugRadianceNormalSign(isec : &Intersection) -> Color
{
    let n = (*isec).shadingNormal;
    @color(@scaleLin(n.x, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.y, -1.0f, 1.0f, 0.0f, 1.0f),
           @scaleLin(n.z, -1.0f, 1.0f, 0.0f, 1.0f))
}

fn debugRadianceDepth(isec : &Intersection) -> Color
{
    color1(1.0f)
}

fn raytraceRadiance(isec : &Intersection) -> Color
{
    color0() // TODO
}

fn recraytraceRadiance(isec : &Intersection) -> Color
{
    color0() // TODO
}

fn makeDistanceScaled(minDist: float, maxDist: float, isec : &Intersection, getcol: fn(&Intersection) -> Color) -> Color
{
    if maxDist <= minDist {
        getcol(isec)
    }
    else {
        let t = scaleLin((*isec).dist, minDist, maxDist, 1.0f, 0.0f);
        clerp(getcol(isec), color0(), t)
    }
}

fn debuggerRadiance(mode: int, minDist: float, maxDist: float, isec : &Intersection) -> Color
{
    makeDistanceScaled(minDist, maxDist, isec,
            if      mode == 0 { debugRadianceNormalDir }
            else if mode == 1 { debugRadianceNormalSign }
            else              { debugRadianceDepth }
        )
}

fn getRadianceForHit(integr : &Integrator, isec : &Intersection) -> Color
{
    let ty = (*integr).itype;
    if      ty == 0 { cosineRadiance(isec) }  // Cosine shading
    else if ty == 1 { raytraceRadiance(isec) }
    else if ty == 2 { recraytraceRadiance(isec) }
    else            { debuggerRadiance((*integr).mode, (*integr).minDist, (*integr).maxDist, isec) }
}

fn runIntegrator(integr : &Integrator, scene : &Scene, ray : Ray, mut scratch : &RTScratch) -> Color
{
    let isec = &(*scratch).isec;
    @beginIntersection(ray, isec);
    @sceneIntersectFirst(scene, scratch);

    if (*isec).obj == @noObj() {
        @color(1.0f, 0.0f, 0.0f)
    }
    else {
        @getRadianceForHit(integr, isec)
    }
}

