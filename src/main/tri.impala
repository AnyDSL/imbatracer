
fn triPoint(tri : uint, pt : uint, scene : Scene) -> Point
{
    assert(||pt < 3u && tri < scene.nTris);
    let idx = scene.triVerts(3u*tri + pt);
    scene.verts(idx)
}

fn triIntersectDistance(tri : uint, scene : Scene, ray : Ray, maxDistance : float) -> (float, Vec, Point) // t, barycentric coords
{
    /* Directly compute barycentric coordinates and t, and cancel early if we notice the ray is not going to hit
     * Surface parameterization: with barycentric coordinates b1, b2, it is p(b1, b2) = (1-b1-b2)*a + b1*b + b2*c
     * Let e1 = a.to(b), a2 = a.to(c). Then p(b1, b2) * a + b1*e1 + b2*e2
     * We want p(b1, b2) = o + t*d, which after sorting coefficients yields
     *      -t*d + b1*e1 + b2*e2 = o-a = a.to(o)
     * This is a linear system with the matrix A = [ -d e1 e2 ] and s = a.to(o). By Cramer's rule, the solution is
     * Let detA = | A |, then t = | s  e1 e2 | / detA
     *					     b1 = | -d s  e2 | / detA
     *                       b2 = |-d  e1  s | / detA
     * We can use that | v1 v2 v3 | = v1*cross(v2, v3), and swapping columns *twice* does not change the determinant
     * so we can pre-compute cross(d, e2) = cross(e2, -d) = f1, cross(s, e1) = f2, and we get
     * detA = e1*f1, t = e2*f2, / detA, b1 = s*f1, b2 = -d*-f2 = d*f2
     */
    // compute inverse determinant
    let a = @triPoint(tri, 0u, scene);
    let e1 = to(a, @triPoint(tri, 1u, scene));
    let e2 = to(a, @triPoint(tri, 2u, scene));
    print_ip(1, a);
    print_iv(2, e1);
    print_iv(3, e2);
    let f1 = cross(ray.d, e2);
    print_iv(42, f1);
    let detA = dot(e1, f1);
    print_if(41, detA);
    let invDetA = 1.0f/detA;
    print_if(44, 1.0f/-0.990052f);

    // compute b1
    let s = to(a, ray.o);
    print_iv(43, s);
    let b1 = dot(s, f1) * (1.0f / detA);
    print_if(40, b1);
    if b1 < 0.0f || b1 > 1.0f
    { (-1.0f, vec0(), point0()) }
    else
    {
        // compute b2
        let f2 = cross(s, e1);
        let b2 = dot(ray.d, f2) * invDetA;
        if b2 < 0.0f || b1+b2 > 1.0f
        { (-1.0f, vec0(), point0()) }
        else
        {
            // compute t
            let t = dot(e2, f2) * invDetA;
            if (t < 0.0f) {
                print_iv(4, f1); print_iv(5, f2);
                print_if(6, b1); print_if(7, b2);
                print_if(8, detA);
                print_ip(12, pvadd(ray.o, vfmul(ray.d, t)));
            }
            if t >= maxDistance
            { (-1.0f, vec0(), point0()) }
            else
            { (t, normalize(cross(e1, e2)), point(1.0f-b1-b2, b1, b2)) }
        }
    }
}

fn triIntersectAny(tri : uint, scene : Scene, ray : Ray, maxDistance : float) -> bool
{
    @(triIntersectDistance(tri, scene, ray, maxDistance)(0)) >= 0.0f
}

fn triIntersectFirst(tri : uint, scene : Scene, isec : &Intersection) -> ()
{
   // print_ints(900, tri as int);
    let res = @triIntersectDistance(tri, scene, (*isec).ray, (*isec).dist);
   // print_ints(901, tri as int);
    let t = res(0); // TODO: would be nice to have syntax for tuple unpacking
    print_ip(9000, (*isec).ray.o);
    print_iv(9001, (*isec).ray.d);
    print_if(9002, t);
    if t >= 0.0f
    {
        let normal = res(1);
        //print_ints(910, tri as int);
        improveIntersection(isec, t, tri, normal, defaultEps()); // FIXME
       // print_ints(911, tri as int);
    }
}

fn triIntersectScene(scene : Scene, isec : &Intersection) -> ()
{
   // print_ints(1000, scene.nTris as int);
    for tri in range(0, scene.nTris as int)
    {
        //print_ints(1001, tri);
        triIntersectFirst(tri as uint, scene, isec)
    }
}


