

fn triIntersectDistance_slow(tri : uint, scene : &Scene, ray : Ray, maxDistance : float, distOnly : bool) -> (float, Vec, Point) // t, barycentric coords
{
    /* Directly compute barycentric coordinates and t, and cancel early if we notice the ray is not going to hit
     * Surface parameterization: with barycentric coordinates b1, b2, it is p(b1, b2) = (1-b1-b2)*a + b1*b + b2*c
     * Let e1 = a.to(b), a2 = a.to(c). Then p(b1, b2) * a + b1*e1 + b2*e2
     * We want p(b1, b2) = o + t*d, which after sorting coefficients yields
     *      -t*d + b1*e1 + b2*e2 = o-a = a.to(o)
     * This is a linear system with the matrix A = [ -d e1 e2 ] and s = a.to(o). By Cramer's rule, the solution is
     * Let detA = | A |, then t = | s  e1 e2 | / detA
     *					     b1 = | -d s  e2 | / detA
     *                       b2 = |-d  e1  s | / detA
     * We can use that | v1 v2 v3 | = v1*cross(v2, v3), and swapping columns *twice* does not change the determinant
     * so we can pre-compute cross(d, e2) = cross(e2, -d) = f1, cross(s, e1) = f2, and we get
     * detA = e1*f1, t = e2*f2, / detA, b1 = s*f1, b2 = -d*-f2 = d*f2
     */
    // compute inverse determinant
    let a = @triPoint(tri, 0u, scene);
    let e1 = to(a, @triPoint(tri, 1u, scene));
    let e2 = to(a, @triPoint(tri, 2u, scene));
    let f1 = cross(ray.d, e2);
    let detA = dot(e1, f1);
    let invDetA = 1.0f / detA;

    // compute b1
    let s = to(a, ray.o);
    let b1 = dot(s, f1) * invDetA;
    if b1 < 0.0f || b1 > 1.0f
    { (-1.0f, @vec0(), @point0()) }
    else
    {
        // compute b2
        let f2 = cross(s, e1);
        let b2 = dot(ray.d, f2) * invDetA;
        if b2 < 0.0f || b1+b2 > 1.0f
        { (-1.0f, @vec0(), @point0()) }
        else
        {
            // compute t
            let t = dot(e2, f2) * invDetA;
            if t >= maxDistance
            { (-1.0f, @vec0(), @point0()) }
            else {
                if distOnly { (t, @vec0(), @point0()) }
                else { (t, @normalize(cross(e1, e2)), @point(1.0f-b1-b2, b1, b2)) }
            }
        }
    }
}

fn triIntersectGeneric(tri : uint, scene : &Scene, ray : Ray, maxDistance : float, mut sisec: &ShadingIntersection) -> float
{
    /* Directly compute barycentric coordinates and t, and cancel early if we notice the ray is not going to hit
     * Surface parameterization: with barycentric coordinates b1, b2, it is p(b1, b2) = (1-b1-b2)*a + b1*b + b2*c
     * Let e1 = a.to(b), a2 = a.to(c). Then p(b1, b2) = a + b1*e1 + b2*e2
     * We want p(b1, b2) = o + t*d, which after sorting coefficients yields
     *      -t*d + b1*e1 + b2*e2 = o-a = a.to(o)
     * This is a linear system with the matrix A = [ -d e1 e2 ] and s = a.to(o). By Cramer's rule, the solution is
     * Let detA = | A |, then t = | s  e1 e2 | / detA
     *					     b1 = | -d s  e2 | / detA
     *                       b2 = |-d  e1  s | / detA
     * We can use that | v1 v2 v3 | = v1*cross(v2, v3), and swapping columns *twice* does not change the determinant
     * so we can pre-compute cross(d, e2) = cross(e2, -d) = f1, cross(s, e1) = f2, and we get
     * detA = e1*f1, t = e2*f2, / detA, b1 = s*f1, b2 = -d*-f2 = d*f2
     */
    // compute inverse determinant
    let a = @triPoint(tri, 0u, scene);
    let e1 = to(a, @triPoint(tri, 1u, scene));
    let e2 = to(a, @triPoint(tri, 2u, scene));
    let f1 = cross(ray.d, e2);
    let detA = dot(e1, f1);
    let invDetA = 1.0f / detA;

    // compute b1
    let s = to(a, ray.o);
    let b1 = dot(s, f1) * invDetA;
    if b1 < 0.0f || b1 > 1.0f {
        return (maxDistance)
    }
    // compute b2
    let f2 = cross(s, e1);
    let b2 = dot(ray.d, f2) * invDetA;
    if b2 < 0.0f || b1+b2 > 1.0f {
        return (maxDistance)
    }
    // compute t
    let t = dot(e2, f2) * invDetA;
    if t < 0.0f || t >= maxDistance {
        return (maxDistance)
    }
    else if sisec == (0u as &ShadingIntersection) {
        return (t)
    }
    else {
        // do the Shading
        let surfaceNormal = @normalize(cross(e1, e2));
        let bar = @point(1f-b1-b2, b1, b2);
        sisec.eps = @sqrtf((@vlensq(e1)+@vlensq(e2)))*defaultRayEps();
        sisec.surfaceNormal = surfaceNormal;
        sisec.shadingNormal =
            if @triHasNormals(tri, scene) {
                let n1 = @triVertNormal(tri, 0u, scene);
                let n2 = @triVertNormal(tri, 1u, scene);
                let n3 = @triVertNormal(tri, 2u, scene);
                @normalize(@vlerpbarp(n1, n2, n3, bar))
            }
            else {
                surfaceNormal // surfce normal, already normalized
            };
        sisec.uv = @triTexPoint(bar, tri, scene);
        sisec.local = @triLocalHitPoint(bar, tri, scene); // TODO directly use b1, b2, e1, e2, a
        sisec.materialIdx = @triMaterialIdx(tri, scene);
        return (t)
    }
}

fn triIntersectAny(tri : uint, scene : &Scene, ray : Ray, maxDistance : float) -> bool
{
    @triIntersectGeneric(tri, scene, ray, maxDistance, 0u as &ShadingIntersection) < maxDistance
}

fn triIntersectFirst(tri : uint, scene : &Scene, ray : Ray, maxdist: float, sisec: &ShadingIntersection) -> float
{
    @triIntersectGeneric(tri, scene, ray, maxdist, sisec)
}
/*
fn triShadeIntersection(tri: uint, scene: &Scene, isec: &Intersection, mut sisec: &ShadingIntersection) -> ()
{
    let a = @triPoint(tri, 0u, scene);
    let e1 = @to(a, @triPoint(tri, 1u, scene));
    let e2 = @to(a, @triPoint(tri, 2u, scene));
    let bar = @point(1f-isec.b.u-isec.b.v, isec.b.u, isec.b.v);
    sisec.eps = @sqrtf((@vlensq(e1)+@vlensq(e2))*defaultRayEps());
    sisec.surfaceNormal = @normalize(cross(e1, e2));
    sisec.shadingNormal =
        if @triHasNormals(tri, scene) {
            let n1 = @triVertNormal(tri, 0u, scene);
            let n2 = @triVertNormal(tri, 1u, scene);
            let n3 = @triVertNormal(tri, 2u, scene);
            @normalize(@vlerpbarp(n1, n2, n3, bar))
        }
        else {
            sisec.surfaceNormal // surfce normal, already normalized
        };
    sisec.uv = @triTexPoint(bar, tri, scene);
    sisec.local = @triLocalHitPoint(bar, tri, scene);
    sisec.materialIdx = @triMaterialIdx(tri, scene);
}
*/
fn triBBox(tri : uint, scene : &Scene) -> BBox
{
    let a = @triPoint(tri, 0u, scene);
    let b = @triPoint(tri, 1u, scene);
    let c = @triPoint(tri, 2u, scene);
    @bbextend(bbox(a, b), c)
}

fn triArea(tri : uint, scene : &Scene) -> float
{
    let a = @triPoint(tri, 0u, scene);
    let e1 = to(a, @triPoint(tri, 1u, scene));
    let e2 = to(a, @triPoint(tri, 2u, scene));
    @vlen(cross(e1, e2))*0.5f
}

// map hit point to triangle texture coord
fn triTexPoint(isecBar : Point, tri : uint, scene : &Scene) -> TexCoord
{
    if @triHasTexcoord(tri, scene)
    {
        let t1 = @triTexCoord(tri, 0u, scene);
        let t2 = @triTexCoord(tri, 1u, scene);
        let t3 = @triTexCoord(tri, 2u, scene);

        @plerpbart(t1, t2, t3, isecBar)
    }
    else
    {
        @texCoord0()
    }
}

fn triLocalHitPoint(isecBar : Point, tri : uint, scene : &Scene) -> Point
{
    let t1 = @triPoint(tri, 0u, scene);
    let t2 = @triPoint(tri, 1u, scene);
    let t3 = @triPoint(tri, 2u, scene);

    @plerpbarp(t1, t2, t3, isecBar)
}
