
// a container for a bunch of triangles
struct Tris
{
    verts : DynArray, // of Point
    triVerts : DynArray, // of uint, 3 successive entries are the three indices of the vertices of a triangle

    normals : DynArray, // of Vec
    texCoords: DynArray, // of TexCoord
    triData : DynArray, // of uint, 7 successive indices belong to one triangle: 3 normals, 3 texcoors, 1 material
}
static Tris_SIZEOF = 5u*DynArray_SIZEOF;
fn trisInit() -> Tris
{
    Tris{ verts: @dynArray(Point_SIZEOF, "Tris.verts"), triVerts: @dynArray(uint_SIZEOF, "Tris.triVerts"),
          normals: @dynArray(Vec_SIZEOF, "Tris.normals"), texCoords: @dynArray(TexCoord_SIZEOF, "Tris.texCoords"), triData: @dynArray(uint_SIZEOF, "Tris.triData") }
}



fn trisSize(mut tris: &Tris) -> uint
{
    //print_sii("The two lists have length", dynArraySize(&tris.triVerts) as i32, dynArraySize(&tris.triData) as i32);
    let nTris = dynArraySize(&tris.triVerts)/3u;
    @assert(||nTris == dynArraySize(&tris.triData)/7u, "Triangle list sizes do not match");
    nTris
}
fn triPointC(mut tris: &Tris, tri: uint, n: uint) -> Point
{
    let idx = @dynArrayFetchUint(&tris.triVerts, 3u*tri+n);
    let p = @dynArrayFetch(&tris.verts, idx) as &Point;
    *p
}
fn triBounds(tris: &Tris, idx: uint) -> BBox
{
    bbextend(bbox(@triPointC(tris, idx, 0u), @triPointC(tris, idx, 1u)), @triPointC(tris, idx, 2u))
}

struct RTTris
{
    verts : &[Point],
    triVerts : &[uint], // 3 successive entries are the three indices of the vertices of a triangle

    normals : &[Vec],
    texCoords: &[TexCoord],
    triData : &[uint], // 7 successive indices belong to one triangle: 3 normals, 3 texcoors, 1 material; same order of triangles as in triVerts
}
static RTTris_SIZEOF = 5u*pointer_SIZEOF;
// copy stuff for the BVH.
fn trisBVHInterface(mut tris: &Tris, mut targetTris: &Tris) -> (primInitFn, primBoundsFn, primCopyFn, primFinishFn)
{
    let mut curIdx = @trisSize(targetTris);
    let vertBase = dynArrayAppendArray(&targetTris.verts, &tris.verts);
    let normalBase = dynArrayAppendArray(&targetTris.normals, &tris.normals);
    let texCoordBase = dynArrayAppendArray(&targetTris.texCoords, &tris.texCoords);

    (   // init
        ||{
            let nTris = @trisSize(tris);
            dynArrayReserve(&targetTris.triVerts, (curIdx+nTris)*3u);
            dynArrayReserve(&targetTris.triData, (curIdx+nTris)*7u);
            (nTris, curIdx)
        },
        // bounds
        |idx|{
            @triBounds(tris, idx)
        },
        // copy
        |copyIdx|{
            //print_sii("Copying triangle with <id1> (that's number <id2>)", copyIdx as int, curIdx as int);
            // append triangle copyIdx in tris, to the list of triangles in rtTris
            for i in @urange(0u, 3u) {
                dynArrayAppendUint(&targetTris.triVerts, @dynArrayFetchUint(&tris.triVerts, 3u*copyIdx+i)+vertBase);
            }
            for i in @urange(0u, 3u) {
                dynArrayAppendUint(&targetTris.triData, @dynArrayFetchUint(&tris.triData, 7u*copyIdx+i)+normalBase);
            }
            for i in @urange(0u, 3u) {
                dynArrayAppendUint(&targetTris.triData, @dynArrayFetchUint(&tris.triData, 7u*copyIdx+3u+i)+texCoordBase);
            }
            dynArrayAppendUint(&targetTris.triData, @dynArrayFetchUint(&tris.triData, 7u*copyIdx+6u)); // the material
            // increment and return
            let idx = curIdx;
            curIdx = idx+1u;
            idx
        },
        // finish
        ||{
            @dynArrayClear(&tris.verts);
            @dynArrayClear(&tris.triVerts);
            @dynArrayClear(&tris.normals);
            @dynArrayClear(&tris.texCoords);
            @dynArrayClear(&tris.triData);
        }
    )
}
fn trisCompile(mut tris: &Tris, mut rtTris: &RTTris) -> ()
{
    rtTris.verts = @dynArrayData(&tris.verts) as &[Point];
    rtTris.triVerts = @dynArrayData(&tris.triVerts) as &[uint];
    rtTris.normals = @dynArrayData(&tris.normals) as &[Vec];
    rtTris.texCoords = @dynArrayData(&tris.texCoords) as &[TexCoord];
    rtTris.triData = @dynArrayData(&tris.triData) as &[uint];
}
fn trisFree(tris: &RTTris) -> ()
{
    thorin_free(tris.verts as &u8);
    thorin_free(tris.triVerts as &u8);
    thorin_free(tris.normals as &u8);
    thorin_free(tris.texCoords as &u8);
    thorin_free(tris.triData as &u8);
}



// accessor functions
fn triPoint(tri : uint, n : uint, tris : &RTTris) -> Point
{
    @assert(||n < 3u, "Accessing invalid triangle point");
    let idx = tris.triVerts(3u*tri + n);
    tris.verts(idx)
}

fn triHasNormals(tri : uint, tris : &RTTris) -> bool
{
    tris.triData(7u*tri) != noIdx
}

fn triVertNormal(tri : uint, n : uint, tris : &RTTris) -> Vec
{
    @assert(||n < 3u, "triVertNormal: Accessing invalid triangle normal");
    let idx = tris.triData(7u*tri + n);
    tris.normals(idx)
}

fn triHasTexcoord(tri : uint, tris : &RTTris) -> bool
{
    tris.triData(7u*tri+3u) != noIdx
}

fn triTexCoord(tri : uint, n : uint, tris : &RTTris) -> TexCoord
{
    @assert(||n < 3u, "triTexCoord: Accessing invalid triangle texture coordinate");
    let idx = tris.triData(7u*tri + 3u + n);
    tris.texCoords(idx)
}

fn triMaterialIdx(tri : uint, tris : &RTTris) -> uint
{
    let idx = tris.triData(7u*tri + 6u);
    idx
}

// = construction functions =
fn trisAddTriBasic(mut tris: &Tris, v1: uint, v2: uint, v3: uint, mat: uint) -> ()
{
    // add triangle vertices
    dynArrayAppendUint(&tris.triVerts, v1);
    dynArrayAppendUint(&tris.triVerts, v2);
    dynArrayAppendUint(&tris.triVerts, v3);
    // add triangle data
    for i in @range(0, 6) {
        dynArrayAppendUint(&tris.triData, noIdx);
    }
    dynArrayAppendUint(&tris.triData, mat);
}
fn trisAddTri(mut tris: &Tris, v1: uint, v2: uint, v3: uint, n1: uint, n2: uint, n3: uint, t1: uint, t2: uint, t3: uint, mat: uint) -> ()
{
    // add triangle vertices
    dynArrayAppendUint(&tris.triVerts, v1);
    dynArrayAppendUint(&tris.triVerts, v2);
    dynArrayAppendUint(&tris.triVerts, v3);
    // add triangle data
    dynArrayAppendUint(&tris.triData, n1);
    dynArrayAppendUint(&tris.triData, n2);
    dynArrayAppendUint(&tris.triData, n3);
    dynArrayAppendUint(&tris.triData, t1);
    dynArrayAppendUint(&tris.triData, t2);
    dynArrayAppendUint(&tris.triData, t3);
    dynArrayAppendUint(&tris.triData, mat);
}
fn trisAddVertex(mut tris: &Tris, mut p: Point) -> uint
{
    @dynArrayAppend(&tris.verts, &p as &u8)
}
fn trisNumVertices(mut tris: &Tris) -> uint
{
    @dynArraySize(&tris.verts)
}
fn trisAddNormal(mut tris: &Tris, mut v: Vec) -> uint
{
    @dynArrayAppend(&tris.normals, &v as &u8)
}
fn trisNumNormals(mut tris: &Tris) -> uint
{
    @dynArraySize(&tris.normals)
}
fn trisAddTexCoord(mut tris: &Tris, mut t: TexCoord) -> uint
{
    @dynArrayAppend(&tris.texCoords, &t as &u8)
}
fn trisNumTexCoords(mut tris: &Tris) -> uint
{
    @dynArraySize(&tris.texCoords)
}

fn trisAddCube(mut tris: &Tris, size: float, mat: uint) -> ()
{
    let vertOffset = dynArraySize(&tris.verts);

    let halfSize = size/2.0f;
    trisAddVertex(tris, @point(-halfSize, -halfSize, -halfSize));
    trisAddVertex(tris, @point( halfSize, -halfSize, -halfSize));
    trisAddVertex(tris, @point(-halfSize,  halfSize, -halfSize));
    trisAddVertex(tris, @point(-halfSize, -halfSize,  halfSize));
    trisAddVertex(tris, @point(-halfSize,  halfSize,  halfSize));
    trisAddVertex(tris, @point( halfSize, -halfSize,  halfSize));
    trisAddVertex(tris, @point( halfSize,  halfSize, -halfSize));
    trisAddVertex(tris, @point( halfSize,  halfSize,  halfSize));

    trisAddTriBasic(tris, vertOffset+0u, vertOffset+1u, vertOffset+2u, mat);
    trisAddTriBasic(tris, vertOffset+6u, vertOffset+1u, vertOffset+2u, mat);

    trisAddTriBasic(tris, vertOffset+0u, vertOffset+1u, vertOffset+3u, mat);
    trisAddTriBasic(tris, vertOffset+5u, vertOffset+1u, vertOffset+3u, mat);

    trisAddTriBasic(tris, vertOffset+0u, vertOffset+2u, vertOffset+3u, mat);
    trisAddTriBasic(tris, vertOffset+4u, vertOffset+2u, vertOffset+3u, mat);

    trisAddTriBasic(tris, vertOffset+7u, vertOffset+6u, vertOffset+5u, mat);
    trisAddTriBasic(tris, vertOffset+1u, vertOffset+6u, vertOffset+5u, mat);

    trisAddTriBasic(tris, vertOffset+7u, vertOffset+6u, vertOffset+4u, mat);
    trisAddTriBasic(tris, vertOffset+2u, vertOffset+6u, vertOffset+4u, mat);

    trisAddTriBasic(tris, vertOffset+7u, vertOffset+5u, vertOffset+4u, mat);
    trisAddTriBasic(tris, vertOffset+3u, vertOffset+5u, vertOffset+4u, mat);
}
fn trisCreateCube(size: float, mat: uint) -> Tris
{
    let mut tris = trisInit();
    trisAddCube(&tris, size, mat);
    tris
}


// object loader. <materials> is a list of material indices, terminated by a noIdx-entry - or NULL
fn trisAddFromFile(tris: &Tris, path: &[u8], filename: &[u8], flags: uint, matOverride: &[uint], scene: &Scene) -> ()
{
    load_object_from_file(path, filename, flags, matOverride, scene, tris);
}
fn trisCreateFromFile(path: &[u8], filename: &[u8], flags: uint, matOverride: &[uint], scene: &Scene) -> Tris
{
    let mut tris = trisInit();
    @trisAddFromFile(&tris, path, filename, flags, matOverride, scene);
    tris
}

// = traversal functions =
fn triIntersectGeneric(tri : uint, tris : &RTTris, ray : &Ray, maxDistance : float, mut sisec: &ShadingIntersection) -> float
{
    /* Directly compute barycentric coordinates and t, and cancel early if we notice the ray is not going to hit
     * Surface parameterization: with barycentric coordinates b1, b2, it is p(b1, b2) = (1-b1-b2)*a + b1*b + b2*c
     * Let e1 = a.to(b), a2 = a.to(c). Then p(b1, b2) = a + b1*e1 + b2*e2
     * We want p(b1, b2) = o + t*d, which after sorting coefficients yields
     *      -t*d + b1*e1 + b2*e2 = o-a = a.to(o)
     * This is a linear system with the matrix A = [ -d e1 e2 ] and s = a.to(o). By Cramer's rule, the solution is
     * Let detA = | A |, then t = | s  e1 e2 | / detA
     *					     b1 = | -d s  e2 | / detA
     *                       b2 = |-d  e1  s | / detA
     * We can use that | v1 v2 v3 | = v1*cross(v2, v3), and swapping columns *twice* does not change the determinant
     * so we can pre-compute cross(d, e2) = cross(e2, -d) = f1, cross(s, e1) = f2, and we get
     * detA = e1*f1, t = e2*f2, / detA, b1 = s*f1, b2 = -d*-f2 = d*f2
     */
    // compute inverse determinant
    let a = @triPoint(tri, 0u, tris);
    let e1 = to(a, @triPoint(tri, 1u, tris));
    let e2 = to(a, @triPoint(tri, 2u, tris));
    let f1 = cross(ray.d, e2);
    let detA = dot(e1, f1);
    let invDetA = 1.0f / detA;

    // compute b1
    let s = to(a, ray.o);
    let b1 = dot(s, f1) * invDetA;
    if b1 < 0.0f || b1 > 1.0f {
        return (maxDistance)
    }
    // compute b2
    let f2 = cross(s, e1);
    let b2 = dot(ray.d, f2) * invDetA;
    if b2 < 0.0f || b1+b2 > 1.0f {
        return (maxDistance)
    }
    // compute t
    let t = dot(e2, f2) * invDetA;
    if t < 0.0f || t >= maxDistance {
        return (maxDistance)
    }
    else if sisec == (0u as &ShadingIntersection) {
        return (t)
    }
    else {
        // do the Shading
        let surfaceNormal = @normalize(cross(e1, e2));
        let bar = @point(1f-b1-b2, b1, b2);
        sisec.eps = @sqrtf((@vlensq(e1)+@vlensq(e2)))*defaultRayEps();
        sisec.surfaceNormal = surfaceNormal;
        sisec.shadingNormal =
            if @triHasNormals(tri, tris) {
                let n1 = @triVertNormal(tri, 0u, tris);
                let n2 = @triVertNormal(tri, 1u, tris);
                let n3 = @triVertNormal(tri, 2u, tris);
                @normalize(@vlerpbarp(n1, n2, n3, bar))
            }
            else {
                surfaceNormal // surfce normal, already normalized
            };
        sisec.uv = @triTexPoint(bar, tri, tris);
        sisec.local = @triLocalHitPoint(bar, tri, tris); // TODO directly use b1, b2, e1, e2, a
        sisec.materialIdx = @triMaterialIdx(tri, tris);
        return (t)
    }
}

fn trisIntersectAny(idx : uint, tris : &RTTris, ray : &Ray, maxDistance : float) -> bool
{
    @triIntersectGeneric(idx, tris, ray, maxDistance, 0u as &ShadingIntersection) < maxDistance
}

fn trisIntersectFirst(idx : uint, tris : &RTTris, ray : &Ray, maxdist: float, sisec: &ShadingIntersection) -> float
{
    @triIntersectGeneric(idx, tris, ray, maxdist, sisec)
}


fn triBBox(tri : uint, tris : &RTTris) -> BBox
{
    let a = @triPoint(tri, 0u, tris);
    let b = @triPoint(tri, 1u, tris);
    let c = @triPoint(tri, 2u, tris);
    @bbextend(bbox(a, b), c)
}

fn triArea(tri : uint, tris : &RTTris) -> float
{
    let a = @triPoint(tri, 0u, tris);
    let e1 = to(a, @triPoint(tri, 1u, tris));
    let e2 = to(a, @triPoint(tri, 2u, tris));
    @vlen(cross(e1, e2))*0.5f
}

// map hit point to triangle texture coord
fn triTexPoint(isecBar : Point, tri : uint, tris : &RTTris) -> TexCoord
{
    if @triHasTexcoord(tri, tris)
    {
        let t1 = @triTexCoord(tri, 0u, tris);
        let t2 = @triTexCoord(tri, 1u, tris);
        let t3 = @triTexCoord(tri, 2u, tris);

        @plerpbart(t1, t2, t3, isecBar)
    }
    else
    {
        @texCoord0()
    }
}

fn triLocalHitPoint(isecBar : Point, tri : uint, tris : &RTTris) -> Point
{
    let t1 = @triPoint(tri, 0u, tris);
    let t2 = @triPoint(tri, 1u, tris);
    let t3 = @triPoint(tri, 2u, tris);

    @plerpbarp(t1, t2, t3, isecBar)
}
