
struct BVHNode
{
    bbox : BBox,
    sndChildFirstPrim : uint, // for an inner node, the second child. for a leaf, the first primitive.
    nPrims : u16, // number of primitives in child. 0 for inner node.
    axis: u16,
}
static BVHNode_SIZEOF = BBox_SIZEOF + uint_SIZEOF + 2u*u16_SIZEOF;

struct RTBVHTrees
{
    roots: &[u32],
    bvhNodes: &[BVHNode],
}

fn bvhsFree(bvhs: &RTBVHTrees) -> ()
{
    thorin_free(bvhs.roots as &u8);
    thorin_free(bvhs.bvhNodes as &u8);
}

static depthLimit = 16u; // keep in sync with the stack size below in bvhIntersectGeneric

fn bvhBBoxComp(bounds : BBox, comp : bool) -> Point
{
    if comp { bounds.cmax } else { bounds.cmin }
}

fn bvhDirIsNeg(neg : uint, axis : uint) -> bool
{
    (neg & (1u << axis)) != 0u
}

fn bvhMakeNeg(invDir : Vec) -> uint
{
    (bool2uint(invDir.x < 0.0f)      ) |
    (bool2uint(invDir.y < 0.0f) << 1u) |
    (bool2uint(invDir.z < 0.0f) << 2u)
}

fn bvhIntersectNode(bounds : BBox, o : Point, maxDist : float, invDir : Vec, neg: uint) -> bool
{
    // Check for ray intersection against x and y slabs
    let txmin = (@bvhBBoxComp(bounds,  @bvhDirIsNeg(neg, 0u)).x - o.x) * invDir.x;
    let txmax = (@bvhBBoxComp(bounds, !@bvhDirIsNeg(neg, 0u)).x - o.x) * invDir.x;
    let tymin = (@bvhBBoxComp(bounds,  @bvhDirIsNeg(neg, 1u)).y - o.y) * invDir.y;
    let tymax = (@bvhBBoxComp(bounds, !@bvhDirIsNeg(neg, 1u)).y - o.y) * invDir.y;
    if (txmin > tymax) || (tymin > txmax)
    { false }
    else {
        let tmin = max(txmin, tymin);
        let tmax = min(txmax, tymax);
        // Check for ray intersection against z slab
        let tzmin = (@bvhBBoxComp(bounds,  @bvhDirIsNeg(neg, 2u)).z - o.z) * invDir.z;
        let tzmax = (@bvhBBoxComp(bounds, !@bvhDirIsNeg(neg, 2u)).z - o.z) * invDir.z;
        if  (tmin > tzmax) || (tzmin > tmax)
        { false }
        else
        {
            max(tmin, tzmin) < maxDist && min(tmax, tzmax) >= 0.0f
        }
    }
}

fn bvhIntersectGeneric(root: uint, bvhNodes : &[BVHNode], ray : &Ray, mut maxdist : float, checkIntersect : fn(uint, float) -> float) -> float
{
    let invDir = @vapply1(ray.d, |f|1.0f/f);
    let neg = @bvhMakeNeg(invDir);

    // we roll our own stack
    let done = return;
    let mut todo = [0u, ..16]; // keep in sync with the constant at the top of this file (TODO?)
    let mut todoIdx = 0; // the first *free* index

    // CPS fun while passing the current node around as argument :-)
    for curNode in ever1(root) { // we shouldn't unroll this, but adding a $ here makes stuff go slower
        //print_si("Traversing through BVH node <id>:", curNode as int);
        // stack helper functions
        fn pushNode(node : uint) -> ()
        {
            todo(todoIdx) = node; // do the left child later
            todoIdx = todoIdx+1;
        }
        fn popNode()
        {
            if todoIdx == 0 {
                done(maxdist) // DONE!
            }
            else {
                // continue with stack element
                todoIdx = todoIdx-1;
                continue(todo(todoIdx))
            }
        }

        if @bvhIntersectNode(bvhNodes(curNode).bbox, ray.o, maxdist, invDir, neg)
        {
            // inner loop: we assume the current node does not intersect
            let inner = continue;

            let nPrim = bvhNodes(curNode).nPrims;
            let sndChildFirstPrim = bvhNodes(curNode).sndChildFirstPrim;
            if (nPrim > 0u16) {
                // a leaf
                for tri in urange(sndChildFirstPrim, sndChildFirstPrim+(nPrim as uint)) {
                    maxdist = @checkIntersect(tri, maxdist); // try and intersect the thing, and do whatever. Called function returns new maxdist to narrow the search.
                }
                // done with this node, pop one off the stack
                @popNode()
            }
            else {
                fn descend(fstNode : uint, sndNode : uint) {
                    @pushNode(sndNode);
                    continue(fstNode)
                }
                // an inner node, which child do we get to first?
                if @bvhDirIsNeg(neg, bvhNodes(curNode).axis as uint) {
                    @descend(sndChildFirstPrim, curNode+1u) // do the left child later
                }
                else {
                    @descend(curNode+1u, sndChildFirstPrim) // do the right child later
                }
            }
        }
        else
        {
            // we missed this node, pop one off the stack
            @popNode()
        }
    };
    // FIXME unreachable
    maxdist
}

fn bvhsBound(idx: uint, bvhTrees: &RTBVHTrees) -> BBox
{
    let root = bvhTrees.roots(idx);
    bvhTrees.bvhNodes(root).bbox
}

fn bvhsIntersectFirst(idx: uint, bvhTrees: &RTBVHTrees, ray: &Ray, maxdist: float, sisec : &ShadingIntersection, subIntersectFirst: IntersectFirstFn) -> float
{
    @bvhIntersectGeneric(bvhTrees.roots(idx), bvhTrees.bvhNodes, ray, maxdist,
        |subIdx, maxdist|
        {
            @subIntersectFirst(subIdx, ray, maxdist, sisec) // returns new maxdist
        }
    )
}


fn bvhsIntersectAny(idx: uint, bvhTrees : &RTBVHTrees, ray : &Ray, maxdist : float, subIntersectAny: IntersectAnyFn) -> bool
{
    let success = return; // jump out once we hit anything

    @bvhIntersectGeneric(bvhTrees.roots(idx), bvhTrees.bvhNodes, ray, maxdist,
        |subIdx, maxdist|
        {
            if @subIntersectAny(subIdx, ray, maxdist) {
                success(true)
            }
            else {
                maxdist
            }
        }
    );

    false
}

