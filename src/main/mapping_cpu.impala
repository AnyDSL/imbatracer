
fn renderIteration(width : int, height : int, measureTime : bool, state : &State, setcolor: SetColorFn, getcolor: GetColorIFn) -> ()
{
    let start = thorin_get_micro_time();
    @renderSubsampled(8u, width as uint, height as uint, state, setcolor, getcolor);
    let stop = thorin_get_micro_time();
    if measureTime { thorin_print_micro_time(stop-start); };
}

fn subsampleDebugView() -> bool
{
    @isDebug()
}

struct PixelInfo
{
    rgb : Color,
    xyz : XYZ,
}

struct PixelBuffer
{
    w : uint,
    pix : &[PixelInfo],
    used : &[u8],
    allocSize : uint,
}

fn free_PixelBuffer(p : &PixelBuffer) -> ()
{
    thorin_free(p.pix as &u8);
    thorin_free(p.used as &u8);
    thorin_free(p as &u8);
}


fn preparePixelBuffer(level : uint, mut state : &State, w : uint, h : uint) -> &PixelBuffer
{
    let mut pb = state.user1 as &PixelBuffer;

    let allocW = round_up(w, level)/2u+1u;
    let allocH = round_up(h, level)/2u+1u;

    let sz = allocW * allocH;

    fn alloc() -> &PixelBuffer
    {
        print_sii("Image size", w as int, h as int);
        let p = ~PixelBuffer{ w:(w >> 1u), pix:~[sz:PixelInfo], used:~[sz:u8], allocSize:sz };
        state.user1 = p as &u8;
        p
    }

    if (pb == (0 as &PixelBuffer))
    {
        pb = alloc()
    }
    else if(pb.allocSize != sz)
    {
        free_PixelBuffer(pb);
        pb = alloc()
    }

    memset(pb.used as &u8, 0, sz as size_t);
    pb
}


type RenderFunc = fn(uint, uint, bool) -> Color;

fn renderSubsampled(level : uint, width : uint, height : uint, state : &State, setcolor: SetColorFn, getcolor: GetColorIFn) -> ()
{
    let mut rtstate = RTState{ cam: state.cam, integrator: state.integrator, scene: state.scene };

    if level <= 1u {
        for y in $urange(0u, height) {
            for x in $urange(0u, width) { // TODO: this used to be $inner_loop(), but wfv2 is too slow to be practical, for now
                @setcolor(x as int, y as int, $getcolor(x as int, y as int, &rtstate));
            }
        }
        return()
    }

    let pixcache = preparePixelBuffer(level, state, width, height);


    fn renderPixel(x:uint, y:uint, write:bool) -> Color
    {
        let c = $getcolor(x as int, y as int, &rtstate);
        if write {
            @setcolor(x as int, y as int, if @subsampleDebugView() { color(0.0f, 1.0f, 0.0f) } else { c });
        }
        c
    }

    for y in $urangestep(0u, height, level) {
        for x in $urangestep(0u, width, level) {
            renderBlock(renderPixel, setcolor, pixcache, x, y, width, height, level)
        }
    }
}

fn getCachePixel(body : RenderFunc, mut pixcache : &PixelBuffer, x : uint, y : uint, write : bool) -> &PixelInfo
{
    //print_ii(x, y);
    assert(||{(x&1u)==0u && (y&1u)==0u}, "Subsampling cached x and y must be even");
    let idx = (y >> 1u) * pixcache.w + (x >> 1u);
    assert(||{idx < pixcache.allocSize}, "Subsampling pixel cache out of bounds access");
    if pixcache.used(idx) == 0u8
    {
        let c = @cclamp01(@body(x, y, write));  // TODO: do the clamping elsewhere?
        pixcache.pix(idx) = @PixelInfo{rgb:c, xyz:@col_toXYZ(c)};
        pixcache.used(idx) = 1u8;
    }
    &pixcache.pix(idx)
}

fn renderBlock(body : RenderFunc, setcolor: SetColorFn, pixcache : &PixelBuffer, x : uint, y : uint, w : uint, h : uint, level : uint) -> ()
{
    renderBlock2(body, setcolor, pixcache, x, y, w, h, level, @getCachePixel(body, pixcache, x, y, true))
}

fn renderBlock2(body : RenderFunc, setcolor: SetColorFn, pixcache : &PixelBuffer, x : uint, y : uint, w : uint, h : uint, level : uint, topleft : &PixelInfo) -> ()
{
    assert(||{(level%2u)==0u && level>1u}, "Subsampling Level must be even and > 1");

    let maxColorDist = 0.1f;

    let topright = @getCachePixel(body, pixcache, x + level, y, x+level < w);
    let bottomleft = @getCachePixel(body, pixcache, x, y + level, y+level < h);
    let bottomright = @getCachePixel(body, pixcache, x + level, y + level, x+level < w && y+level < h);

    if @colorDistXYZ(topleft.xyz, topright.xyz) <= maxColorDist
    && @colorDistXYZ(topleft.xyz, bottomleft.xyz) <= maxColorDist
    && @colorDistXYZ(topright.xyz, bottomright.xyz) <= maxColorDist
    && @colorDistXYZ(bottomleft.xyz, bottomright.xyz) <= maxColorDist
    {
        // colors are similar, interpolate
        let step = 1.0f / (level as float);
        let xmax = @umin(x + level, w);
        let ymax = @umin(y + level, h);

        fn fillrow(xbegin : uint, yy : uint, mut xf : float, a : Color, b : Color) -> ()
        {
            for xx in @urange(xbegin, xmax)
            {
                let mix = if @subsampleDebugView() { @color0() } else { @clerp(a, b, xf) };
                @setcolor(xx as int, yy as int, mix);
                xf = xf + step;
            }
        }


        // top left pixel is already written to image, fill rest of row
        @fillrow(x+1u, y, step, topleft.rgb, topright.rgb);

        let mut ty = step;
        for yy in urange(y+1u, ymax)
        {
            let ileft  = if @subsampleDebugView() { @color0() } else { @clerp(topleft.rgb, bottomleft.rgb, ty) };
            let iright = if @subsampleDebugView() { @color0() } else { @clerp(topright.rgb, bottomright.rgb, ty) };

            @setcolor(x as int, yy as int, ileft);
            @fillrow(x+1u, yy, step, ileft, iright);
            ty = ty + step;
        }

        return()
    }

    let nextlevel = level >> 1u;


    fn boundsChecked(offs : uint, f : fn(uint, uint) -> ()) -> ()
    {
        let haveRightNeighbor = (x+offs < w);
        let haveBottomNeighbor = (y+offs < h);
        if haveRightNeighbor
        {
            f(x+offs, y);
        }
        if haveBottomNeighbor
        {
            f(x, y+offs);
        }
        if haveRightNeighbor && haveBottomNeighbor
        {
            f(x+offs, y+offs);
        }
    }

    if nextlevel == 1u
    {
        let renderpixel = if @subsampleDebugView()
        {
            |xx:uint, yy:uint| -> () { @setcolor(xx as int, yy as int, @color1(1.0f)); }
        } else {
            |xx:uint, yy:uint| -> () { @body(xx, yy, true); }
        };
        // top-left pixel is already written to image
        @boundsChecked(1u, renderpixel);
        return()
    }


    // subdivide
    renderBlock2(body, setcolor, pixcache, x, y, w, h, nextlevel, topleft); // in this case the color is known, saves a cache lookup

    boundsChecked(nextlevel, |xx:uint, yy:uint| $renderBlock(body, setcolor, pixcache, xx, yy, w, h, nextlevel) );

}

