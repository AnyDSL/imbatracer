
fn renderIteration(width : int, height : int, measureTime : bool, state : &State, setcolor: SetColorFn, getcolor: GetColorIFn) -> ()
{
    let start = thorin_get_micro_time();
    @renderSubsampled(8u, width as uint, height as uint, state, setcolor, getcolor);
    let stop = thorin_get_micro_time();
    if measureTime { thorin_print_micro_time(stop-start); };
}


fn assert(f : fn() -> bool, msg: [u8]) -> ()
{
    if @isDebug() && !f() {
        assert_failed(msg)
    }
}

struct PixelInfo
{
    rgb : Color,
    xyz : XYZ,
}

struct PixelBuffer
{
    w : uint,
    pix : &[PixelInfo],
    used : &[u8],
    allocSize : uint,
}

fn free_PixelBuffer(p : &PixelBuffer) -> ()
{
    thorin_free(p.pix as &u8);
    thorin_free(p.used as &u8);
    thorin_free(p as &u8);
}


fn preparePixelBuffer(mut state : &State, w : uint, h : uint) -> &PixelBuffer
{
    let mut pb = state.user1 as &PixelBuffer;

    // FIXME: this is way too big. only half should be required
    let sz = w * h;
    //let sz = (w >> 1u) * (h >> 1u);

    fn alloc() -> &PixelBuffer
    {
        print_ii(w as int, h as int);
        let p = ~PixelBuffer{ w:(w >> 1u), pix:~[sz:PixelInfo], used:~[sz:u8], allocSize:sz };
        state.user1 = p as &u8;
        p
    }

    if (pb == (0 as &PixelBuffer))
    {
        pb = alloc()
    }
    else if(pb.allocSize != sz)
    {
        //free_PixelBuffer(pb);
        pb = alloc()
    }

    memset(pb.used as &u8, 0, sz as size_t);
    pb
}


type RenderFunc = fn(uint, uint) -> Color;

fn renderSubsampled(level : uint, width : uint, height : uint, state : &State, setcolor: SetColorFn, getcolor: GetColorIFn) -> ()
{
    let mut rtstate = RTState{ cam: state.cam, integrator: state.integrator, scene: state.scene };

    if level <= 1u
    {
        let mut scratch = @emptyScratch(); // scratch space for the current intersection (TODO is this better than passing it around?)
        for y in $urange(0u, height) {
            for x in $urange(0u, width) { // TODO: this used to be $inner_loop(), but wfv2 is too slow to be practical, for now
                @setcolor(x as int, y as int, $getcolor(x as int, y as int, &rtstate, &scratch));
            }
        }
        return()
    }

    let pixcache = $preparePixelBuffer(state, width, height);


    fn renderPixel(x:uint, y:uint) -> Color
    {
        let mut scratch = @emptyScratch();
        let c = $getcolor(x as int, y as int, &rtstate, &scratch);
        @setcolor(x as int, y as int, c);
        c
    }

    for y in $urangestep(0u, height, level) {
        for x in $urangestep(0u, width, level) {
            renderBlock(renderPixel, setcolor, pixcache, x, y, width, height, level)
        }
    }
}

fn getCachePixel(body : RenderFunc, mut pixcache : &PixelBuffer, x : uint, y : uint) -> &PixelInfo
{
    //print_ii(x, y);
    assert(||{(x&1u)==0u && (y&1u)==0u}, "Subsampling x and y must be even");
    let idx = (y >> 1u) * pixcache.w + (x >> 1u);
    if pixcache.used(idx) == 0u8
    {
        let c = cclamp01($body(x, y));  // TODO: do the clamping elsewhere?
        pixcache.pix(idx) = PixelInfo{rgb:c, xyz:col_toXYZ(c)};
        pixcache.used(idx) = 1u8;
    }
    &pixcache.pix(idx)
}

fn renderBlock(body : RenderFunc, setcolor: SetColorFn, pixcache : &PixelBuffer, x : uint, y : uint, w : uint, h : uint, level : uint) -> ()
{
    renderBlock2(body, setcolor, pixcache, x, y, w, h, level, getCachePixel(body, pixcache, x, y))
}

fn renderBlock2(body : RenderFunc, setcolor: SetColorFn, pixcache : &PixelBuffer, x : uint, y : uint, w : uint, h : uint, level : uint, topleft : &PixelInfo) -> ()
{
    assert(||{(level%2u)==0u && level>1u}, "Subsampling Level must be even");
    assert(||{x+level<w}, "Subsampling x is out of bounds");
    assert(||{y+level<h}, "Subsampling y is out of bounds");
    //print_ifff(level, x as float, y as float, -1.0f);
    let maxColorDist = 0.1f;

    let topright = getCachePixel(body, pixcache, x + level, y);
    let bottomleft = getCachePixel(body, pixcache, x, y + level);
    let bottomright = getCachePixel(body, pixcache, x + level, y + level);

    if @colorDistXYZ(topleft.xyz, topright.xyz) <= maxColorDist
    && @colorDistXYZ(topleft.xyz, bottomleft.xyz) <= maxColorDist
    && @colorDistXYZ(topright.xyz, bottomright.xyz) <= maxColorDist
    && @colorDistXYZ(bottomleft.xyz, bottomright.xyz) <= maxColorDist
    {
        // colors are similar, interpolate
        let step = 1.0f / (level as float);
        let xmax = @umin(x + level, w);
        let ymax = @umin(y + level, h);

        fn fillrow(xbegin : uint, y : uint, mut xf : float, a : Color, b : Color) -> ()
        {
            for xx in @urange(xbegin, xmax)
            {
                @setcolor(xx as int, y as int, clerp(a, b, xf));
                xf = xf + step;
            }
        }

        // top left pixel is already written to image, fill rest of row
        @fillrow(x+1u, y, step, topleft.rgb, topright.rgb);

        let mut ty = step;
        for yy in urange(y+1u, ymax)
        {
            let ileft = @clerp(topleft.rgb, bottomleft.rgb, ty);
            let iright = @clerp(topright.rgb, bottomright.rgb, ty);

            @setcolor(x as int, yy as int, ileft);
            @fillrow(x+1u, yy, step, ileft, iright);
            ty = ty + step;
        }

        return()
    }


    let nextlevel = level >> 1u;
    let haveRightNeighbor = (x+nextlevel < w);
    let haveBottomNeighbor = (y+nextlevel < h);

    let boundsChecked = |f : fn(uint, uint) -> ()| -> ()
    {
        if haveRightNeighbor
        {
            f(x+nextlevel, y);
        }
        if haveBottomNeighbor
        {
            f(x, y+nextlevel);
        }
        if haveRightNeighbor && haveBottomNeighbor
        {
            f(x+nextlevel, y+nextlevel);
        }
    };

    if nextlevel == 1u
    {
        let renderpixel = |xx:uint, yy:uint| -> () { $body(xx, yy); };
        // top-left pixel is already written to image
        boundsChecked(renderpixel);
        return()
    }


    // subdivide
    renderBlock2(body, setcolor, pixcache, x, y, w, h, nextlevel, topleft); // in this case the color is known, saves a cache lookup

    boundsChecked(|xx:uint, yy:uint| $renderBlock(body, setcolor, pixcache, xx, yy, w, h, nextlevel) );

}

