type TextureFn = fn(TexCoord, Point) -> Color;

struct Texture
{
    ty : int,
    color1 : Color,
    color2 : Color,
    noise : Noise,
}

// ----------------------------------------------

fn constantTexture(c : Color) -> Texture
{
    Texture{ ty: -1, color1:c,
        color2: color0(), noise:noise0()
    }
}

fn checkerboardTexture2D(a : Color, b : Color) -> Texture
{
    Texture{ ty: 0, color1:a, color2: b,
        noise:noise0()
    }
}

fn checkerboardTexture3D(a : Color, b : Color) -> Texture
{
    Texture{ ty: 1, color1:a, color2: b,
        noise:noise0()
    }
}

fn noiseTexture(a : Color, b : Color, noise : Noise) -> Texture
{
    Texture{ ty: 2, color1:a, color2:b, noise:noise }
}


// -----------------------------------------------


fn evalCheckerboardTexture2D(uv:TexCoord, p:Point, a : Color, b : Color) -> Color
{
    if (absfractional(uv.u) >= 0.5f) != (absfractional(uv.v) >= 0.5f) { a } else { b }
}

fn evalCheckerboardTexture3D(uv:TexCoord, p:Point, a : Color, b : Color) -> Color
{
    let i = bool2uint(absfractional(p.x) >= 0.5f)
          ^ bool2uint(absfractional(p.y) >= 0.5f)
          ^ bool2uint(absfractional(p.z) >= 0.5f);
    if i == 0u { a } else { b }
}

fn evalNoiseTexture3D(p : Point, a : Color, b : Color, noise : &Noise) -> Color
{
    clerp(a, b, evalNoise(p, noise))
}


fn evalTexture(uv:TexCoord, p:Point, mut tex : &Texture) -> Color
{
         if(tex.ty == 0) { evalCheckerboardTexture2D(uv, p, tex.color1, tex.color2) }
    else if(tex.ty == 1) { evalCheckerboardTexture3D(uv, p, tex.color1, tex.color2) }
    else if(tex.ty == 2) { evalNoiseTexture3D(p, tex.color1, tex.color2, &tex.noise) } // FIXME: this makes compiling SLOOOOOW
    else                 { tex.color1 }
}
