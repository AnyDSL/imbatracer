type TextureFn = fn(TexCoord, Point) -> Color;

struct Texture
{
    ty : int,
    color1 : Color,
    color2 : Color,
    noise : Noise,
    img : Image,
    imgW : float,
    imgH : float,
    imgFilter : int,
    imgBorder : int,
}
static Texture_SIZEOF = 4u + 2u*Color_SIZEOF + Noise_SIZEOF + Image_SIZEOF + 4u*4u;

static TEX_CONSTANT = -1;
static TEX_CHECK2D = 0;
static TEX_CHECK3D = 1;
static TEX_NOISE = 2;
static TEX_IMAGE = 3;

static FILTER_NEAREST = 0;
static FILTER_BILINEAR = 1;

static BORDER_REPEAT = 0;
static BORDER_CLAMP = 1;
static BORDER_MIRROR = 2;

// ----------------------------------------------

fn constantTexture(c : Color) -> Texture
{
    Texture{ ty: TEX_CONSTANT, color1:c,
        color2: color0(), noise:noise0(), img:IMAGE_DUMMY, imgW:0.0f, imgH:0.0f, imgFilter:0, imgBorder:0
    }
}

fn checkerboardTexture2D(a : Color, b : Color) -> Texture
{
    Texture{ ty: TEX_CHECK2D, color1:a, color2: b,
        noise:noise0(), img:IMAGE_DUMMY, imgW:0.0f, imgH:0.0f, imgFilter:0, imgBorder:0
    }
}

fn checkerboardTexture3D(a : Color, b : Color) -> Texture
{
    Texture{ ty: TEX_CHECK3D, color1:a, color2: b,
        noise:noise0(), img:IMAGE_DUMMY, imgW:0.0f, imgH:0.0f, imgFilter:0, imgBorder:0
    }
}

fn noiseTexture(a : Color, b : Color, noise : Noise) -> Texture
{
    Texture{ ty: TEX_NOISE, color1:a, color2:b, noise:noise,
         img:IMAGE_DUMMY, imgW:0.0f, imgH:0.0f, imgFilter:0, imgBorder:0
    }
}

fn imageTexture(img : Image, filter : int, border : int) -> Texture
{
    Texture{ ty: TEX_IMAGE, img:img, imgFilter:filter, imgBorder:border, imgW:img.w as float, imgH:img.h as float,
        color1:color0(), color2:color0(), noise:noise0()
    }
}

// -----------------------------------------------



// Helper for image texture access
fn texel(img : Image, x : float, y : float, filter : int, border : int) -> Color
{
    let latticeTexel = if border == BORDER_CLAMP { imageGetClamped }
                  else if border == BORDER_MIRROR { imageGetMirrored }
                  else { imageGetRepeat };

    if filter == FILTER_BILINEAR
    {
        let fx = floorf(x);
        let fy = floorf(y);
        let ix = fx as int;
        let iy = fy as int;
        clerp2d(latticeTexel(img, ix, iy), latticeTexel(img, ix+1, iy), latticeTexel(img, ix, iy+1), latticeTexel(img, ix+1, iy+1), x-fx, y-fy)
    }
    else
    {
        latticeTexel(img, iroundf(x), iroundf(y))
    }
}

// -----------------------------------------------


fn evalCheckerboardTexture2D(uv:TexCoord, p:Point, a : Color, b : Color) -> Color
{
    if (absfractional(uv.u) >= 0.5f) != (absfractional(uv.v) >= 0.5f) { a } else { b }
}

fn evalCheckerboardTexture3D(uv:TexCoord, p:Point, a : Color, b : Color) -> Color
{
    let i = bool2uint(absfractional(p.x) >= 0.5f)
          ^ bool2uint(absfractional(p.y) >= 0.5f)
          ^ bool2uint(absfractional(p.z) >= 0.5f);
    if i == 0u { a } else { b }
}

fn evalNoiseTexture3D(p : Point, a : Color, b : Color, noise : &Noise) -> Color
{
    clerp(a, b, evalNoise(p, noise))
}

fn evalImageTexture(uv : TexCoord, img : Image, wf : float, hf : float, filter : int, border : int) -> Color
{
    @texel(img, uv.u*wf, uv.v*hf, filter, border)
}


fn evalTexture(uv:TexCoord, p:Point, mut tex : &Texture) -> Color
{
         if(tex.ty == TEX_CHECK2D) { evalCheckerboardTexture2D(uv, p, tex.color1, tex.color2) }
    else if(tex.ty == TEX_CHECK3D) { evalCheckerboardTexture3D(uv, p, tex.color1, tex.color2) }
    else if(tex.ty == TEX_NOISE)   { evalNoiseTexture3D(p, tex.color1, tex.color2, &tex.noise) }
    else if(tex.ty == TEX_IMAGE)   { evalImageTexture(uv, tex.img, tex.imgW, tex.imgH, tex.imgFilter, tex.imgBorder) }
    else                           { tex.color1 }
}
