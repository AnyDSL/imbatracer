

struct Scene
{
    bvhNodes: &[BVHNode],

    verts : &[Point],
    triVerts : &[uint], // 3 successive entries are the three indices of the vertices of a triangle

    normals : &[Vec],
    triNormals : &[uint],

    texcoords: &[TexCoord],
    triTexcoords : &[uint],

    objs: &[Object],
    nObjs : uint,

    lights: &[Light],
    nLights : uint,
}


fn noIdx() -> uint // the ID to be used when "nothing" is referenced (not valid for vertices; either one normal/texCoord or all of them must be absent)
{ 0xFFFFFFFFu }

// TODO: Figure out the best way to pass around stuff. Scene as pointer or as copy? Intersection as pointer, or as function from Ray to isect?
fn sceneIntersectFirst(scene: &Scene, scratch : &RTScratch) -> ()
{
    for obj in urange(0u, (*scene).nObjs)
    {
        @objIntersectFirst(obj, scene, scratch)
    }
}

fn sceneIntersectAny(scene: &Scene, scratch : &RTScratch, ray : Ray, maxdist : float) -> bool
{
    let done = return;
    for obj in urange(0u, (*scene).nObjs)
    {
        if @objIntersectAny(obj, scene, scratch, ray, maxdist)
        {
            done(true)
        }
    }
    false
}
