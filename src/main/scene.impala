// compose layers of stuff together to form a scene one can intersect against

type IntersectFirstFn = fn(uint, &Ray, float, &ShadingIntersection) -> float;
type IntersectAnyFn   = fn(uint, &Ray, float) -> bool;


struct Scene
{
    // scene geometry
    meshes: DynArray, // of Tris
    //objects: DynArray, // of Instances, indexing the meshes

    // shading data
    shadingData: ShadingData,
}
fn sceneInit() -> Scene
{
    let mut scene = Scene{ meshes:@dynArray(Tris_SIZEOF, "Scene.meshes"), shadingData:@initShadingData() };

    // add default textures and materials
    @sceneAddTextureV(&scene, @constantTexture(color1(0.0f)));
    @sceneAddTextureV(&scene, @constantTexture(color1(1.0f)));
    @sceneAddMaterialV(&scene, @dummyMaterial());

    return(scene)
}

struct RTScene
{
    // scene geometry
    bvhOuter: RTBVHTree,
    bvhInners: RTBVHTrees,
    tris: RTTris,

    // shading data
    shadingData: RTShadingData,
}

/* Static Scene API: Add stuff, and compile it */
fn sceneAddMesh(mut scene: &Scene, tris: &Tris) -> uint
{
    dynArrayAppend(&scene.meshes, tris as &u8)
}
fn sceneAddMeshFromFile(scene: &Scene, path: &[u8], filename: &[u8], flags: uint, materials: &DynArray) -> uint
{
    let mut tris = @trisInit();
    @trisAddFromFile(&tris, path, filename, flags, materials, scene);
    @sceneAddMesh(scene, &tris)
}

fn sceneAddTextureV(scene: &Scene, mut tex: Texture) -> uint
{
    sceneAddTexture(scene, &tex)
}
fn sceneAddTexture(mut scene: &Scene, tex: &Texture) -> uint
{
    dynArrayAppend(&scene.shadingData.textures, tex as &u8)
}
fn sceneAddMaterialV(scene: &Scene, mut mat: Material) -> uint
{
    sceneAddMaterial(scene, &mat)
}
fn sceneAddMaterial(mut scene: &Scene, mat: &Material) -> uint
{
    dynArrayAppend(&scene.shadingData.materials, mat as &u8)
}
fn sceneAddLightV(scene: &Scene, mut l: Light) -> uint
{
    sceneAddLight(scene, &l)
}
fn sceneAddLight(mut scene: &Scene, l: &Light) -> uint
{
    dynArrayAppend(&scene.shadingData.lights, l as &u8)
}

fn sceneCompile(mut scene: &Scene, mut rtScene: &RTScene) -> ()
{
    // build BVHs for meshes
    let mut bvhMeshes = bvhTrees();
    for objidx in urange(0u, dynArraySize(&scene.meshes)) {
        print_si("Compiling mesh <id>", objidx as int);
        let tris = dynArrayFetch(&scene.meshes, objidx) as &Tris;
        let triFinalize = trisPrepareCopy(tris, &rtScene.tris); // copy triangles to the RTScene
        bvhsAddTree(&bvhMeshes, trisSize(tris), |triidx|triBounds(tris, triidx), triFinalize);
        trisFinishCopy(tris, &rtScene.tris);
    }

    // build BVH of objects
    // FIXME TEMP HACK
    rtScene.bvhInners.bvhNodes = @dynArrayData(&bvhMeshes.bvhNodes) as &[BVHNode];
    @assert(||@dynArrayFetchUint(&bvhMeshes.roots, 0u) == 0u, "root has wrong index");
    rtScene.bvhInners.roots = ~[1:uint];
    rtScene.bvhInners.roots(0) = 0u;
    /*let bvhMeshFinalize = bvhsPrepareCopy(&bvhMeshes, &rtScene.bvhInners);
    let mut bvhObjects = bvhTree();
    bvhCreateTree(&bvhObjects, dynArraySize(&scene.objects),
        |objidx|instanceBounds(dynArrayFetch(&scene.objects, objidx) as &Instance, |meshidx|bvhBounds(bvhMeshes, meshidx)),
        bvhMeshFinalize);
    bvhCompile(&bvhObjects, &rtScene.bvhOuter);*/

    // copy shading data
    shadingDataCompile(&scene.shadingData, &rtScene.shadingData);
}
fn sceneFree(mut scene: &RTScene) -> ()
{
    // FIXME free more stuff
    shadingDataFree(&scene.shadingData);
}


/* Run-time Object API: Provide two functions
 * - IntersectFirst takes a scene, a ray, the max. distance, a pointer to the shading intersection and returns the new max. distance (if an intersection was found),
 *   or the old one if nothing was found
 * - IntersectAny takes ascene, a ray, and the max. distance and returns whether there's a hit in that range
 */
fn sceneIntersectFirst(mut scene: &RTScene, ray : &Ray, maxdist : float, sisec : &ShadingIntersection) -> float
{
    @bvhsIntersectFirst(0u, &scene.bvhInners, ray, maxdist, sisec, |idx, ray, maxdist, sisec|trisIntersectFirst(idx, &scene.tris, ray, maxdist, sisec))
}

fn sceneIntersectAny(mut scene: &RTScene, ray : &Ray, maxdist : float) -> bool
{
    @bvhsIntersectAny(0u, &scene.bvhInners, ray, maxdist, |idx, ray, maxdist|trisIntersectAny(idx, &scene.tris, ray, maxdist))
}
