// compose layers of stuff together to form a scene one can intersect against

type IntersectFirstFn = fn(uint, &Ray, float, &ShadingIntersection) -> float;
type IntersectAnyFn   = fn(uint, &Ray, float) -> bool;

struct Scene
{
    // scene geometry
    bvh: BVHTree,
    tris: RTTris,

    // shading data
    materials: &[Material],
    textures : &[Texture],

    lights: &[Light],
    nLights : uint,

}


/* Object API: Provide two functions
 * - IntersectFirst takes a scene, a ray, the max. distance, a pointer to the shading intersection and returns the new max. distance (if an intersection was found),
 *   or the old one if nothing was found
 * - IntersectAny takes ascene, a ray, and the max. distance and returns whether there's a hit in that range
 */

// TODO: Figure out the best way to pass around stuff. Scene as pointer or as copy? Intersection as pointer, or as function from Ray to isect?
fn sceneIntersectFirst(mut scene: &Scene, ray : &Ray, maxdist : float, sisec : &ShadingIntersection) -> float
{
    @bvhIntersectFirst(&scene.bvh, ray, maxdist, sisec, |idx, ray, maxdist, sisec|trisIntersectFirst(idx, &scene.tris, ray, maxdist, sisec))
}

fn sceneIntersectAny(mut scene: &Scene, ray : &Ray, maxdist : float) -> bool
{
    @bvhIntersectAny(&scene.bvh, ray, maxdist, |idx, ray, maxdist|trisIntersectAny(idx, &scene.tris, ray, maxdist))
}
