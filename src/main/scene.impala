// compose layers of stuff together to form a scene one can intersect against

type IntersectFirstFn = fn(uint, &Ray, float, &ShadingIntersection) -> float;
type IntersectAnyFn   = fn(uint, &Ray, float) -> bool;


struct Scene
{
    // scene geometry
    meshes: DynArray, // of Tris
    //objects: DynArray, // of Instances, indexing the meshes

    // shading data
    shadingData: ShadingData,
}
fn sceneInit() -> Scene
{
    Scene{ meshes:@dynArray(Tris_SIZEOF, "Scene.meshes"), shadingData:@initShadingData() }
}

struct RTScene
{
    // scene geometry
    bvhOuter: RTBVHTree,
    bvhInners: RTBVHTrees,
    tris: RTTris,

    // shading data
    shadingData: RTShadingData,
}

/* Static Scene API: Add stuff, and compile it */
fn sceneAddMesh(mut scene: &Scene, tris: &Tris) -> ()
{
    dynArrayAppend(&scene.meshes, tris as &u8);
}

fn sceneCompile(mut scene: &Scene, mut rtScene: &RTScene) -> ()
{
    // build BVHs for meshes
    let mut bvhMeshes = bvhTrees();
    for objidx in urange(0u, dynArraySize(&scene.meshes)) {
        print_si("Compiling mesh <id>", objidx as int);
        let tris = dynArrayFetch(&scene.meshes, objidx) as &Tris;
        let triFinalize = trisPrepareCopy(tris, &rtScene.tris); // copy triangles to the RTScene
        bvhsAddTree(&bvhMeshes, trisSize(tris), |triidx|triBounds(tris, triidx), triFinalize);
    }

    // build BVH of objects
    // FIXME TEMP HACK
    rtScene.bvhInners.bvhNodes = @dynArrayData(&bvhMeshes.bvhNodes) as &[BVHNode];
    @assert(||@dynArrayFetchUint(&bvhMeshes.roots, 0u) == 0u, "root has wrong index");
    rtScene.bvhInners.roots = ~[1:uint];
    rtScene.bvhInners.roots(0) = 0u;
    /*let bvhMeshFinalize = bvhsPrepareCopy(&bvhMeshes, &rtScene.bvhInners);
    let mut bvhObjects = bvhTree();
    bvhCreateTree(&bvhObjects, dynArraySize(&scene.objects),
        |objidx|instanceBounds(dynArrayFetch(&scene.objects, objidx) as &Instance, |meshidx|bvhBounds(bvhMeshes, meshidx)),
        bvhMeshFinalize);
    bvhCompile(&bvhObjects, &rtScene.bvhOuter);*/
}


/* Run-time Object API: Provide two functions
 * - IntersectFirst takes a scene, a ray, the max. distance, a pointer to the shading intersection and returns the new max. distance (if an intersection was found),
 *   or the old one if nothing was found
 * - IntersectAny takes ascene, a ray, and the max. distance and returns whether there's a hit in that range
 */

// TODO: Figure out the best way to pass around stuff. Scene as pointer or as copy? Intersection as pointer, or as function from Ray to isect?
fn sceneIntersectFirst(mut scene: &RTScene, ray : &Ray, maxdist : float, sisec : &ShadingIntersection) -> float
{
    @bvhsIntersectFirst(0u, &scene.bvhInners, ray, maxdist, sisec, |idx, ray, maxdist, sisec|trisIntersectFirst(idx, &scene.tris, ray, maxdist, sisec))
}

fn sceneIntersectAny(mut scene: &RTScene, ray : &Ray, maxdist : float) -> bool
{
    @bvhsIntersectAny(0u, &scene.bvhInners, ray, maxdist, |idx, ray, maxdist|trisIntersectAny(idx, &scene.tris, ray, maxdist))
}
