// compose layers of stuff together to form a scene one can intersect against

type IntersectFirstFn = fn(uint, &Ray, float, &ShadingIntersection) -> float;
type IntersectAnyFn   = fn(uint, &Ray, float) -> bool;


struct Scene
{
    // scene geometry
    meshes: DynArray, // of Tris
    // no instances here, that's done at run-time (with a fast BVH re-construction)

    // shading data
    shadingData: ShadingData,
}
fn sceneInit() -> Scene
{
    let mut scene = Scene{ meshes:@dynArray(Tris_SIZEOF, "Scene.meshes"), shadingData:@initShadingData() };

    // add default textures and materials
    @sceneAddTextureV(&scene, @constantTexture(color1(0.0f)));
    @sceneAddTextureV(&scene, @constantTexture(color1(1.0f)));
    @sceneAddMaterialV(&scene, @dummyMaterial());

    return(scene)
}

struct RTScene
{
    // scene geometry
    // mesh data
    bvhMeshes: RTBVHTrees,
    meshes: RTTris,
    // object data
    bvhOuter: RTBVHTrees, // this will always be only one tree
    objects: RTInstances,

    // shading data
    shadingData: RTShadingData,
}
static RTScene_SIZEOF = RTBVHTrees_SIZEOF + RTTris_SIZEOF + RTBVHTrees_SIZEOF + RTInstances_SIZEOF + RTShadingData_SIZEOF;

/* Static Scene API: Add stuff, and compile it */
fn sceneAddMesh(mut scene: &Scene, tris: &Tris) -> uint
{
    dynArrayAppend(&scene.meshes, tris as &u8)
}
fn sceneAddMeshFromFile(scene: &Scene, path: &[u8], filename: &[u8], flags: uint, matOverride: &[uint]) -> uint
{
    let mut tris = @trisInit();
    @trisAddFromFile(&tris, path, filename, flags, matOverride, scene);
    @sceneAddMesh(scene, &tris)
}

fn sceneAddTextureV(scene: &Scene, mut tex: Texture) -> uint
{
    sceneAddTexture(scene, &tex)
}
fn sceneAddTexture(mut scene: &Scene, tex: &Texture) -> uint
{
    dynArrayAppend(&scene.shadingData.textures, tex as &u8)
}
fn sceneAddMaterialV(scene: &Scene, mut mat: Material) -> uint
{
    sceneAddMaterial(scene, &mat)
}
fn sceneAddMaterial(mut scene: &Scene, mat: &Material) -> uint
{
    dynArrayAppend(&scene.shadingData.materials, mat as &u8)
}
fn sceneAddLightV(scene: &Scene, mut l: Light) -> uint
{
    sceneAddLight(scene, &l)
}
fn sceneAddLight(mut scene: &Scene, l: &Light) -> uint
{
    dynArrayAppend(&scene.shadingData.lights, l as &u8)
}

// compile the meshes of a scene. Must be called exactly once!
fn sceneCompileMeshes(mut scene: &Scene, mut rtScene: &RTScene) -> ()
{
    // build BVHs for meshes, and copy mesh data
    let mut bvhMeshes = bvhTrees();
    let mut meshes = trisInit();
    for objidx in urange(0u, dynArraySize(&scene.meshes)) {
        print_si("Compiling mesh <id>", objidx as int);
        let tris = dynArrayFetch(&scene.meshes, objidx) as &Tris;
        @bvhsAddTree(&bvhMeshes, 0u, @trisBVHInterface(tris, &meshes)); // copy triangles to the RTScene
    }
    bvhsCompile(&bvhMeshes, &rtScene.bvhMeshes);
    trisCompile(&meshes, &rtScene.meshes);
    @dynArrayClear(&scene.meshes);

    // copy shading data
    shadingDataCompile(&scene.shadingData, &rtScene.shadingData);
}
// compile the objects of a scene. Can be called repeatedly.
fn sceneCompileObjects(mut rtScene: &RTScene, objects: &Instances) -> ()
{
    // free old stuff
    bvhsFree(&rtScene.bvhOuter);
    instsFree(&rtScene.objects);

    // build BVH of objects, and copy instance data
    let mut bvhOuter = bvhTrees();
    @bvhsAddTree(&bvhOuter, 1u, @instsBVHInterface(objects, &rtScene.objects, |meshIdx|bvhsBound(meshIdx, &rtScene.bvhMeshes)));
    bvhsCompile(&bvhOuter, &rtScene.bvhOuter);
    @assert(||rtScene.bvhOuter.roots(0) == 0u, "The one and only outer tree has a weird root"); // this is a hack, but oh well... ;-)
}

fn sceneFree(mut scene: &RTScene) -> ()
{
    bvhsFree(&scene.bvhOuter);
    instsFree(&scene.objects);
    bvhsFree(&scene.bvhMeshes);
    trisFree(&scene.meshes);
    shadingDataFree(&scene.shadingData);
}


/* Run-time Object API: Provide two functions
 * - IntersectFirst takes a scene, a ray, the max. distance, a pointer to the shading intersection and returns the new max. distance (if an intersection was found),
 *   or the old one if nothing was found
 * - IntersectAny takes ascene, a ray, and the max. distance and returns whether there's a hit in that range
 */
fn sceneIntersectFirst(mut scene: &RTScene, ray : &Ray, maxdist : float, sisec : &ShadingIntersection) -> float
{
    @bvhsIntersectFirst(0u, &scene.bvhOuter, ray, maxdist, sisec,
        |idx, ray, maxdist, sisec|instanceIntersectFirst(idx, &scene.objects, ray, maxdist, sisec,
            |idx, ray, maxdist, sisec|bvhsIntersectFirst(idx, &scene.bvhMeshes, ray, maxdist, sisec,
                |idx, ray, maxdist, sisec|trisIntersectFirst(idx, &scene.meshes, ray, maxdist, sisec)
            )
        )
    )
}

fn sceneIntersectAny(mut scene: &RTScene, ray : &Ray, maxdist : float) -> bool
{
    @bvhsIntersectAny(0u, &scene.bvhOuter, ray, maxdist,
        |idx, ray, maxdist|instanceIntersectAny(idx, &scene.objects, ray, maxdist,
            |idx, ray, maxdist|bvhsIntersectAny(idx, &scene.bvhMeshes, ray, maxdist,
                |idx, ray, maxdist|trisIntersectAny(idx, &scene.meshes, ray, maxdist)
            )
        )
    )
}
