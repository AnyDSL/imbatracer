// compose layers of stuff together to form a scene one can intersect against

type IntersectFirstFn = fn(uint, &Ray, float, &ShadingIntersection) -> float;
type IntersectAnyFn   = fn(uint, &Ray, float) -> bool;


struct Scene
{
    // scene geometry
    meshes: DynArray, // of Tris
    objects: DynArray, // of Instances, indexing the meshes

    // shading data
    shadingData: ShadingData,
}
struct RTScene
{
    // scene geometry
    bvhOuter: RTBVHTree,
    bvhInners: RTBVHTrees,
    tris: RTTris,

    // shading data
    shadingData: RTShadingData,
}

/* Static Scene API: Add stuff, and compile it */
fn sceneAdd(mut scene: &Scene, tris: &Tris) -> ()
{
    dynArrayAppend(&scene.objects, tris as &u8);
}

fn sceneCompile(mut scene: &Scene, mut rtScene: &RTScene) -> ()
{
    // build BVHs for meshes
    let mut bvhMeshes = bvhTrees();
    for objidx in urange(0u, dynArraySize(&scene.objects)) {
        let tris = dynArrayFetch(&scene.objects, objidx) as &Tris;
        let triFinalize = trisPrepareCopy(tris, &rtScene.tris); // copy triangles to the RTScene
        bvhsAddTree(&bvhMeshes, trisSize(tris), |triidx|triBounds(tris, triidx), triFinalize);
    }

    // build BVH of objects
    let bvhMeshFinalize = bvhsPrepareCopy(&bvhMeshes, &rtScene.bvhInners);
    let mut bvhObjects = bvhTree();
    bvhCreateTree(&bvhObjects, dynArraySize(&scene.objects),
        |objidx|instanceBounds(dynArrayFetch(&scene.objects, objidx) as &Instance, |meshidx|bvhBounds(bvhMeshes, meshidx)),
        bvhMeshFinalize);
    bvhCompile(&bvhObjects, &rtScene.bvhOuter);
}


/* Run-time Object API: Provide two functions
 * - IntersectFirst takes a scene, a ray, the max. distance, a pointer to the shading intersection and returns the new max. distance (if an intersection was found),
 *   or the old one if nothing was found
 * - IntersectAny takes ascene, a ray, and the max. distance and returns whether there's a hit in that range
 */

// TODO: Figure out the best way to pass around stuff. Scene as pointer or as copy? Intersection as pointer, or as function from Ray to isect?
fn sceneIntersectFirst(mut scene: &RTScene, ray : &Ray, maxdist : float, sisec : &ShadingIntersection) -> float
{
    @bvhIntersectFirst(&scene.bvh, ray, maxdist, sisec, |idx, ray, maxdist, sisec|trisIntersectFirst(idx, &scene.tris, ray, maxdist, sisec))
}

fn sceneIntersectAny(mut scene: &RTScene, ray : &Ray, maxdist : float) -> bool
{
    @bvhIntersectAny(&scene.bvh, ray, maxdist, |idx, ray, maxdist|trisIntersectAny(idx, &scene.tris, ray, maxdist))
}
