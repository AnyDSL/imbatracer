struct Material {
    ka: Vec3,
    kd: Vec3,
    ks: Vec3,
    exp: float,
    tex_a: int,
    tex_d: int,
    tex_s: int,
    tex_t: int
}

fn sample_texture(mut textures: &[Texture], tex_id: int, st: Vec2, dstdx: Vec2, dstdy: Vec2, bh: BoundaryHandling) -> Vec3 @{
    if tex_id >= 0 @{
        let tex = &textures(tex_id);
        if tex.levels > 1 @{
            // Trilinear interpolation between mipmap levels
            let size = (tex.width * tex.height) as float;
            let dmax = size * maxf(vec2_lensq(dstdx), vec2_lensq(dstdy));
            let bias = 0.025f;
            let d = minf(1.0f, maxf(0.0f, bias + 0.5f * log2f(dmax) / (tex.levels as float)));
            let c = sample_mipmap(tex, d, st, bh);
            vec3(c.a * c.r, c.a * c.g, c.a * c.b)
        } else @{
            let c = bilinear_interpolation(tex, 0, st, bh);
            vec3(c.a * c.r, c.a * c.g, c.a * c.b)
        }
    } else @{
        vec3(1.0f, 1.0f, 1.0f)
    }
}

// TODO : replace materials by shader system in the future
fn evaluate_material_bvh(p: &Packet, h: &Hit, mut scene: &Scene, comp: &CompiledBvhScene, accumulate: fn (int, Vec3) -> (), rnd: fn () -> float) -> () @{
    let mut normals : [Vec3 * 64];
    let mut face_normals : [Vec3 * 64];
    let mut du : [Vec2 * 64];
    let mut dv : [Vec2 * 64];

    fn frontfacing(id: int, d: Vec3, front: fn()) -> () {
        if vec3_dot(face_normals(id), d) > 0.0f {
            front()
        }
    }

    // Compute normals and differentials
    for i in range(0, packet_size(p)) @{
        let inst_id = hit_inst(h, i);
        let mesh_id = scene.instances(inst_id).mesh_id;
        let mesh = scene.meshes(mesh_id);

        let mut tinv = mat4_transpose(&scene.instances(inst_id).inv_mat);

        let tri_id = hit_tri(h, i);
        if tri_id >= 0 @{
            let u = hit_u(h, i);
            let v = hit_v(h, i);
            let w = 1.0f - u - v;
            let t = hit_t(h, i);

            // Compute interpolated normal
            let n0 = vec3_mulf(mesh.normals(mesh.indices(tri_id * 3 + 0)), w);
            let n1 = vec3_mulf(mesh.normals(mesh.indices(tri_id * 3 + 1)), u);
            let n2 = vec3_mulf(mesh.normals(mesh.indices(tri_id * 3 + 2)), v);
            let n = vec3_add(n0, vec3_add(n1, n2));

            normals(i) = vec3_norm(mat4_mul_vec3(&tinv, n, 0.0f));

            // Compute face normal
            let v0 = mesh.vertices(mesh.indices(tri_id * 3 + 0));
            let v1 = mesh.vertices(mesh.indices(tri_id * 3 + 1));
            let v2 = mesh.vertices(mesh.indices(tri_id * 3 + 2));
            let e0 = vec3_sub(v1, v0);
            let e1 = vec3_sub(v2, v0);
            let tn = mat4_mul_vec3(&tinv, vec3_cross(e0, e1), 0.0f);
            face_normals(i) = if vec3_dot(tn, packet_dir(p, i)) > 0.0f { vec3_map(tn, |x| -x) } else { tn };

            // Compute differentials (for mipmapping)
            let p_intr = vec3_add(packet_org(p, i), vec3_mulf(packet_dir(p, i), t));
            compute_differentials(p, i, p_intr, face_normals(i), e0, e1, &du(i), &dv(i));
        } else @{
            normals(i) = vec3(0.0f, 0.0f, 0.0f);
            face_normals(i) = vec3(0.0f, 0.0f, 0.0f);
        }
    }

    let mut diff : [Vec3 * 64];
    let mut spec : [Vec3 * 64];
    let mut shiny : [float * 64];

    // Ambient light contribution & diffuse/spec param. computation
    for i in range(0, packet_size(p)) @{
        let tri_id = hit_tri(h, i);
        if tri_id >= 0 @{
            let mesh_id = scene.instances(hit_inst(h, i)).mesh_id;
            let mesh = scene.meshes(mesh_id);
            let mat_id = mesh.materials(tri_id);
            let mat = scene.materials(mat_id);

            if mat.tex_a >= 0 | mat.tex_d >= 0 | mat.tex_s >= 0 {
                let u = hit_u(h, i);
                let v = hit_v(h, i);

                let st0 = mesh.texcoords(mesh.indices(tri_id * 3 + 0));
                let st1 = mesh.texcoords(mesh.indices(tri_id * 3 + 1));
                let st2 = mesh.texcoords(mesh.indices(tri_id * 3 + 2));

                let dstdu = vec2_sub(st1, st0);
                let dstdv = vec2_sub(st2, st0);
                let st = vec2_add(vec2_add(st0,
                                  vec2_mulf(dstdu, u)),
                                  vec2_mulf(dstdv, v));

                let dudx = du(i).values(0);
                let dudy = du(i).values(1);
                let dvdx = dv(i).values(0);
                let dvdy = dv(i).values(1);
                let dstdx = vec2_add(vec2_mulf(dstdu, dudx), vec2_mulf(dstdv, dvdx));
                let dstdy = vec2_add(vec2_mulf(dstdu, dudy), vec2_mulf(dstdv, dvdy));

                // Sample textures (reuse previous results if possible)
                let ambient = @sample_texture(scene.textures, mat.tex_a, st, dstdx, dstdy, bh_repeat);

                diff(i) = if mat.tex_d == mat.tex_a @{
                    ambient
                } else {
                    sample_texture(scene.textures, mat.tex_d, st, dstdx, dstdy, bh_repeat)
                };

                spec(i) = if mat.tex_s == mat.tex_a @{
                    ambient
                } else if mat.tex_s == mat.tex_d @{
                    diff(i)
                } else {
                    sample_texture(scene.textures, mat.tex_s, st, dstdx, dstdy, bh_repeat)
                };

                @accumulate(i, vec3_mul(ambient, mat.ka));
                diff(i) = vec3_mul(diff(i), mat.kd);
                spec(i) = vec3_mul(spec(i), mat.ks);
                shiny(i) = mat.exp;
            } else {
                @accumulate(i, mat.ka);
                diff(i) = mat.kd;
                spec(i) = mat.ks;
                shiny(i) = mat.exp;
            }
        }
    }

    // Add the contribution of each light
    let mut sp : Packet;
    let mut sh : Hit;

    for j in range(0, scene.num_lights) @{
        let f = 1.0f / (light_samples(&scene.lights(j)) as float);

        for s in range(0, light_samples(&scene.lights(j))) {
            light_packet(&scene.lights(j), p, h, &sp, &sh, frontfacing, rnd);
            first_hit_bvh_scene(scene, comp, &sp, &sh, h);

            // Loop over pixels that need to be lit
            for i in range(packet_first_alive(&sp), packet_last_alive(&sp) + 1) @{
                let tri_id = hit_tri(h, i);
                frontfacing(i, packet_dir(&sp, i), || {
                    if tri_id >= 0 && hit_tri(&sh, i) < 0 @{
                        let t = hit_t(h, i);
                        let intr   = vec3_add(vec3_mulf(packet_dir(p, i), t), packet_org(p, i));
                        let intr_s = vec3_add(packet_dir(&sp, i), packet_org(&sp, i));
                        let intensity = evaluate_light(&scene.lights(j), intr_s, intr, normals(i));

                        let view = vec3_norm(packet_dir(p, i));
                        let reflect = vec3_reflect(vec3_norm(packet_dir(&sp, i)), normals(i));
                        let cos_view = -vec3_dot(view, reflect);
                        let ks = powf(maxf(0.0f, cos_view), shiny(i));

                        let brdf = vec3_add(diff(i), vec3_mulf(spec(i), ks));
                        accumulate(i, vec3_mul(intensity, vec3_mulf(brdf, f)));
                    }
                    continue()
                });
            }
        }
    }
}

