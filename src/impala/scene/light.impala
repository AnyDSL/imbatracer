static point_light = 0;    // Point light, defined by position only
static spot_light = 1;     // Spot light defined by position, direction, cutoff angle, penumbra angle
static sphere_light = 2;   // Area light with sphere shape, defined by position and radius

struct Light {
    light_type: int,   // Light type, see above
    intensity: Vec3,   // For point light, spot light and sphere light
    pos: Vec3,         // For point light, spot light and sphere light
    dir: Vec3,         // Spot light only
    max_cutoff: float, // Spot light only
    min_cutoff: float, // Spot light only
    penumbra: float,   // Spot light only
    radius: float      // Sphere light only
}

fn light_samples(light: &Light) -> int {
    let samples = [1, 1, 32];
    assert(|| {light.light_type >= 0 && light.light_type <= 2}, "light_samples : invalid light type");
    samples(light.light_type)
}

fn generate_sample(light: &Light, p: Vec3, rnd: fn () -> float) -> Vec3 @{
    if light.light_type == point_light ||
       light.light_type == spot_light @{
        light.pos
    } else @{
        assert(|| {light.light_type == sphere_light}, "generate_sample : invalid light type");
        let u1 = rnd();
        let u2 = rnd();
        let d = vec3_norm(vec3_sub(p, light.pos));
        let r = vec3_mulf(sample_hemisphere(d, u1, u2), light.radius);
        vec3_add(light.pos, r)
    }
}

fn light_packet(light: &Light,
                p: &Packet,
                h: &Hit,
                sp: &Packet,
                mut sh: &Hit,
                frontfacing: fn (int, Vec3, fn ()) -> (),
                rnd: fn() -> float) -> () @{
    *sh = empty_hit(sp, 0.99f);

    generate_packet(sp, |x, y, skip, ret| @{
        let id = packet_ray_id(p, x, y);

        if hit_tri(h, id) >= 0 {
            let t = hit_t(h, id);
            let p = vec3_add(vec3_mulf(packet_dir(p, id), t), packet_org(p, id));
            let d = vec3_sub(generate_sample(light, p, rnd), p);
            frontfacing(id, d, || {
                ret(ray(d, p))
            });
        }

        skip()
    });

    if light.light_type == point_light ||
       light.light_type == spot_light @{
        shadow_frustum(sp, light.pos);
    } else {
        bounding_frustum(sp, sh);
    }
}

fn evaluate_light(light: &Light, sample: Vec3, p: Vec3, n: Vec3) -> Vec3 {
    // Compute the incident light vector
    let d = vec3_sub(sample, p);

    // Compute attenuation at given point
    let dist = sqrtf(vec3_lensq(d));
    let k = dist * dist + 0.0001f;
    
    let cos_n = vec3_dot(n, d) / dist;
    let cos_d = vec3_dot(light.dir, d);

    let i = if cos_n > 0.0f { cos_n / k } else { 0.0f };

    // Check that the angle with the light direction is less than cutoff (spotlight)
    let min_d = dist * light.min_cutoff;
    let max_d = dist * light.max_cutoff;
    let s = if cos_d < max_d {
        // Check for penumbra angle
        if cos_d > min_d {
            let t = (cos_d - min_d) / (max_d - min_d);
            i * t * t
        } else {
            0.0f
        }
    } else {
        i
    };

    vec3_mulf(light.intensity, s)
}

