struct Camera {
    up : Vec3,
    right : Vec3,
    center : Vec3,
    eye : Vec3
}

fn camera_ray(cam: &Camera, d: Vec3, x: int, y: int, w: int, h: int) -> Ray {
    let kx = 2.0f * (x as float) / ((w - 1) as float) - 1.0f;
    let ky = 1.0f - 2.0f * (y as float) / ((h - 1) as float);

    let dir = vec3(d.values(0) + cam.right.values(0) * kx + cam.up.values(0) * ky,
                   d.values(1) + cam.right.values(1) * kx + cam.up.values(1) * ky,
                   d.values(2) + cam.right.values(2) * kx + cam.up.values(2) * ky);

    ray(dir, cam.eye)
}

fn render_gbuffer_bvh_scene(scene: &Scene, comp: &CompiledBvhScene, cam: &Camera, gbuffer: &GBuffer) -> () @{
    let d = vec3_sub(cam.center, cam.eye);

    // TODO : Do that in parallel
    for y in range_step(0, gbuffer.height, 8) @{
        for x in range_step(0, gbuffer.width, 8) @{
            let mut p : Packet;
            let mut hit : Hit = empty_hit(&p, flt_max);

            generate_packet(&p, |i, j, skip| camera_ray(cam, d, x + i, y + j, gbuffer.width, gbuffer.height));
            perspective_frustum(&p);
            closest_hit_bvh_scene(scene, comp, &p, &hit);

            for i in range(0, packet_height(&p)) @{
                for j in range(0, packet_width(&p)) @{
                    let k = packet_ray_id(&p, j, i);
                    
                    write_gbuffer(x + j, y + i, 0, gbuffer, GBufferPixel {
                        t: hit.t(k),
                        u: hit.u(k),
                        v: hit.v(k),
                        tri_id: hit.tri_id(k),
                        inst_id: hit.inst_id(k)
                    });
                }
            }
        }
    }
}

fn render_texture_bvh_scene(mut scene: &Scene, comp: &CompiledBvhScene, cam: &Camera, texture: &Texture) -> () @{
    let d = vec3_sub(cam.center, cam.eye);
    let max_transparency = 8;

    for yb in parallel(0, 0, texture.height / 8) @{
        let y = yb * 8;
        let mut rnd_state : RandomState;
        random_state(&rnd_state, (y * y) as u32);

        for x in range_step(0, texture.width, 8) @{
            let mut p : Packet;
            let mut h : Hit = empty_hit(&p, flt_max);

            // Generate primary rays
            generate_packet(&p, |i, j, skip| camera_ray(cam, d, x + i, y + j, texture.width, texture.height));
            perspective_frustum(&p);
            closest_hit_bvh_scene(scene, comp, &p, &h);
            packet_set_mask(&p, |i, m| hit_tri(&h, i) >= 0);

            // Initialize the image to zero
            for i in range(0, packet_height(&p)) @{
                for j in range(0, packet_width(&p)) @{
                    write_texture(x + j, y + i, 0, texture, TexturePixel{ r: 0.0f, g : 0.0f, b : 0.0f, a : 1.0f });
                }
            }

            // Compute the pixel color
            let mut retrace : [bool * 64];
            let mut needs_retrace = true;
            let mut n = 0;

            while needs_retrace @{
                let mut normals : [Vec3 * 64];
                let mut face_normals : [Vec3 * 64];
                let mut du : [Vec2 * 64];
                let mut dv : [Vec2 * 64];
                compute_normals_dudv(&p, &h, scene, &normals, &face_normals, &du, &dv);

                for i in range(0, 64) {
                    retrace(i) = false;
                }

                $evaluate_material_bvh(&p, &h, scene, comp, &normals, &face_normals, &du, &dv,
                |i, c| {
                    let py = i / packet_width(&p);
                    let px = i % packet_width(&p);
                    let mut pixel = read_texture(x + px, y + py, 0, texture);

                    retrace(i) = c.values(3) < 0.99f;
                    pixel.r += pixel.a * c.values(3) * c.values(0);
                    pixel.g += pixel.a * c.values(3) * c.values(1);
                    pixel.b += pixel.a * c.values(3) * c.values(2);
                    pixel.a *= 1.0f - c.values(3);

                    write_texture(x + px, y + py, 0, texture, pixel);
                }, || {
                    random_float(&rnd_state)
                });

                // Test if there is a need to continue rays (for transparency)
                needs_retrace = false;
                for i in range(0, packet_size(&p)) {
                    needs_retrace |= (p.mask(i) & retrace(i));
                }
                needs_retrace &= n < max_transparency;

                if needs_retrace {
                    continue_packet(&p, &h, &face_normals, flt_max, |i| retrace(i));
                    closest_hit_bvh_scene(scene, comp, &p, &h);
                    packet_set_mask(&p, |i, m| { m & (hit_tri(&h, i) >= 0) });
                    n++;
                }
            }

            // Add a final touch : background or cube map
            if scene.bg_type > 0 {
                if scene.bg_type == bg_cubemap {
                    for i in range(0, packet_height(&p)) {
                        for j in range(0, packet_width(&p)) @{
                            let id = packet_ray_id(&p, j, i);
                            if hit_tri(&h, id) < 0 @{
                                let pix = sample_cubemap(scene.textures, &scene.bg_texid, packet_dir(&p, id));
                                write_texture(x + j, y + i, 0, texture, pix)
                            }
                        }
                    }
                } else if scene.bg_type == bg_image {
                    for i in range(0, packet_height(&p)) {
                        for j in range(0, packet_width(&p)) @{
                            let id = packet_ray_id(&p, j, i);
                            if hit_tri(&h, id) < 0 {
                                let u = (x + j) as float / (texture.width  as float);
                                let v = 1.0f - (y + i) as float / (texture.height as float);
                                let pix = bilinear_interpolation(&scene.textures(scene.bg_texid(0)), 0, vec2(u, v), bh_clamp);
                                write_texture(x + j, y + i, 0, texture, pix)
                            }
                        }
                    }
                } else {
                    assert(||{ false }, "render_texture_bvh_scene : invalid background type");
                }
            }
        }
    }
}

