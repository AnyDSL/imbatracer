struct Camera {
    up : Vec3,
    right : Vec3,
    center : Vec3,
    eye : Vec3
}

fn camera_ray(cam: &Camera, d: Vec3, x: int, y: int, w: int, h: int) -> Ray {
    let kx = 2.0f * (x as float) / ((w - 1) as float) - 1.0f;
    let ky = 1.0f - 2.0f * (y as float) / ((h - 1) as float);

    let dir = vec3(d.values(0) + cam.right.values(0) * kx + cam.up.values(0) * ky,
                   d.values(1) + cam.right.values(1) * kx + cam.up.values(1) * ky,
                   d.values(2) + cam.right.values(2) * kx + cam.up.values(2) * ky);

    ray(dir, cam.eye)
}

fn render_gbuffer_bvh_scene(scene: &Scene, comp: &CompiledBvhScene, cam: &Camera, gbuffer: &GBuffer) -> () @{
    let d = vec3_sub(cam.center, cam.eye);

    // TODO : Do that in parallel
    for y in range_step(0, gbuffer.height, 8) @{
        for x in range_step(0, gbuffer.width, 8) @{
            let mut p : Packet;
            let mut hit : Hit = empty_hit(&p, flt_max);

            generate_packet(&p, |i, j| camera_ray(cam, d, x + i, y + j, gbuffer.width, gbuffer.height));
            perspective_frustum(&p);
            closest_hit_bvh_scene(scene, comp, &p, &hit);

            for i in range(0, packet_height(&p)) @{
                for j in range(0, packet_width(&p)) @{
                    let k = packet_ray_id(&p, j, i);
                    
                    write_gbuffer(x + j, y + i, gbuffer, gbuffer_pixel(hit.t(k), hit.u(k), hit.v(k), hit.tri_id(k), hit.inst_id(k)));
                }
            }
        }
    }
}

fn render_texture_bvh_scene(scene: &Scene, comp: &CompiledBvhScene, cam: &Camera, texture: &Texture) -> () @{
    let d = vec3_sub(cam.center, cam.eye);

    // TODO : Do that in parallel
    for yb in parallel(0, 0, texture.height / 8) @{
        let y = yb * 8;
        for x in range_step(0, texture.width, 8) @{
            let mut p : Packet;
            let mut hit : Hit = empty_hit(&p, flt_max);
            let mut color : [Vec3 * 64];

            generate_packet(&p, |i, j| camera_ray(cam, d, x + i, y + j, texture.width, texture.height));
            perspective_frustum(&p);
            closest_hit_bvh_scene(scene, comp, &p, &hit);

            for i in range(0, packet_size(&p)) {
                color(i) = vec3(0.0f, 0.0f, 0.0f);
            }

            evaluate_material_bvh(&p, &hit, scene, comp, |i, c| @{
                color(i) = vec3_add(color(i), c)
            });

            for i in range(0, packet_height(&p)) @{
                for j in range(0, packet_width(&p)) @{
                    let c = color(packet_ray_id(&p, j, i));
                    let cc = vec3_map(vec3_clamp(c, 0.0f, 1.0f), |x| x * 255.0f);
                    let pix = texture_pixel(cc.values(0) as u8, cc.values(1) as u8, cc.values(2) as u8, 255u8);
                    write_texture(x + j, y + i, texture, pix);
                }
            }
        }
    }
}

