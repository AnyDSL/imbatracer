// TODO : introduce a polymorphic image type
struct TexturePixel {
    r: float,
    g: float,
    b: float,
    a: float
}

struct Texture {
    width: int,
    height: int,
    stride: int,
    pixels: &[TexturePixel]
}

fn write_texture(x : int, y : int, tex: &Texture, pixel: TexturePixel) -> () {
    let p = tex.pixels as u64 + (y * tex.stride) as u64;
    let mut row = p as &[TexturePixel];
    row(x) = pixel;
}

fn read_texture(x : int, y : int, tex: &Texture) -> TexturePixel {
    let p = tex.pixels as u64 + (y * tex.stride) as u64;
    let row = p as &[TexturePixel];
    row(x)
}

struct GBufferPixel {
    t: float,
    u: float,
    v: float,
    tri_id: int,
    inst_id: int
}

struct GBuffer {
    width: int,
    height: int,
    stride: int,
    buffer: &[GBufferPixel]
}

fn write_gbuffer(x : int, y : int, buf: &GBuffer, pixel: GBufferPixel) -> () {
    let p = buf.buffer as u64 + (y * buf.stride) as u64;
    let mut row = p as &[GBufferPixel];
    row(x) = pixel;
}

fn read_gbuffer(x : int, y : int, buf: &GBuffer) -> GBufferPixel {
    let p = buf.buffer as u64 + (y * buf.stride) as u64;
    let row = p as &[GBufferPixel];
    row(x)
}

struct BoundaryHandling {
    top: fn (int, int) -> int,
    left: fn (int, int) -> int,
    bottom: fn (int, int) -> int,
    right: fn (int, int) -> int
}

static bh_repeat = BoundaryHandling {
    bottom: |y, h| { h + y % h },
    left:   |x, w| { w + x % w },
    top:    |y, h| { y % h },
    right:  |x, w| { x % w }
};

static bh_clamp = BoundaryHandling {
    bottom: |y, h| { 0 },
    left:   |x, w| { 0 },
    top:    |y, h| { h - 1 },
    right:  |x, w| { w - 1 }
};

// Bilinearly interpolates pixels on a texture (u, v in [0, 1], and (0,0) is bottom left corner)
fn bilinear_interpolation(tex: &Texture, uv: Vec2, bh: BoundaryHandling) -> TexturePixel @{
    let px = uv.values(0) * (tex.width  as float) - 0.5f;
    let py = (1.0f - uv.values(1)) * (tex.height as float) - 0.5f;

    let x0 = floorf(px) as int;
    let y0 = floorf(py) as int;
    let x1 = x0 + 1;
    let y1 = y0 + 1;

    fn pixel(x: int, y: int) -> TexturePixel {
        let mut bx = x;
        let mut by = y;

        if x < 0 { bx = bh.left(x, tex.width) }
        if y < 0 { by = bh.bottom(y, tex.height) }
        if x >= tex.width  { bx = bh.right(x, tex.width) }
        if y >= tex.height { by = bh.top(y, tex.height) }

        assert(|| {bx >= 0 && bx < tex.width && by >=0 && by < tex.height}, "bilinear_interpolation : invalid boundary handling");
        read_texture(bx, by, tex)
    }

    let c0 = pixel(x0, y0);
    let c1 = pixel(x1, y0);
    let c2 = pixel(x0, y1);
    let c3 = pixel(x1, y1);

    let kx = px - x0 as float;
    let ky = py - y0 as float;
    let ikx = 1.0f - kx;
    let iky = 1.0f - ky;

    TexturePixel {
        r: iky * (ikx * c0.r + kx * c1.r) +
           ky  * (ikx * c2.r + kx * c3.r),
        g: iky * (ikx * c0.g + kx * c1.g) +
           ky  * (ikx * c2.g + kx * c3.g),
        b: iky * (ikx * c0.b + kx * c1.b) +
           ky  * (ikx * c2.b + kx * c3.b),
        a: iky * (ikx * c0.a + kx * c1.a) +
           ky  * (ikx * c2.a + kx * c3.a)
    }
}

// Samples a cube map that from a direction vector. The cube map is given as an array of 6 texture indices.
fn sample_cubemap(mut textures: &[Texture], cube: &[int * 6], dir: Vec3) -> TexturePixel @{
    let abs = vec3_abs(dir);
    let mut max = 0;
    if abs.values(0) < abs.values(1) { max = 1 }
    if abs.values(max) < abs.values(2) { max = 2 }

    let sign = if dir.values(max) > 0.0f { 1 } else { 0 };
    let tex_id = cube(max * 2 + sign);

    let m2 = max % 2;
    let m3 = max % 3;

    // index: axis
    // axis_u = [2, 0, 0]
    // axis_v = [1, 2, 1]
    let axis_u = 2 - (m2 + m3);
    let axis_v = m2 + 1;

    // index: axis * 2 + sign
    // sign_u = [ 1, -1,  1,  1, -1,  1]
    // sign_v = [ 1,  1,  1, -1,  1,  1]
    let is = 1 - 2 * sign;
    let sign_u = (1 - m2) * (1 - max) * is + m2;
    let sign_v = m2 * is - (m2 - 1);

    assert(|| { fabsf(sign_u as float) == 1.0f }, "sample_cubemap : invalid value for u parameter");
    assert(|| { fabsf(sign_v as float) == 1.0f }, "sample_cubemap : invalid value for v parameter");

    let u = (dir.values(axis_u) * (sign_u as float) / abs.values(max) + 1.0f) * 0.5f;
    let v = (dir.values(axis_v) * (sign_v as float) / abs.values(max) + 1.0f) * 0.5f;

    bilinear_interpolation(&textures(tex_id), vec2(u, v), bh_clamp)
}

// Samples a mipmap with trilinear interpolation. The lod level is given as a floating point value between 0 and 1 
fn sample_mipmap(mut textures: &[Texture], base: int, n: int, d: float, uv: Vec2, bh: BoundaryHandling) -> TexturePixel @{
    assert(|| {fabsf(d) <= 1.0f}, "sample_mipmap : invalid lod level");

    let lod = d * ((n - 1) as float);
    let l0 = floorf(lod) as int;
    let l1 = if l0 >= (n - 1) { n - 1 } else { l0 + 1 };

    let c0 = bilinear_interpolation(&textures(base + l0), uv, bh);
    let c1 = bilinear_interpolation(&textures(base + l1), uv, bh);

    let k = lod - l0 as float;
    let ik = 1.0f - k;

    TexturePixel {
        r: ik * c0.r + k * c1.r,
        g: ik * c0.g + k * c1.g,
        b: ik * c0.b + k * c1.b,
        a: ik * c0.a + k * c1.a
    }
}

