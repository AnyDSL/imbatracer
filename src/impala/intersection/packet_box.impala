fn intersect_packet_box(p: &Packet, h: &Hit, b: Box, intr: fn () -> ()) -> () @{
    // Bounding frustum test
    intersect_frustum_box(p.frustum, b, || {
        // Individual ray test
        let upper_bound = p.last_alive + 1;
        let lower_bound = p.first_alive;
        let first = if lower_bound % 4 == 0 {lower_bound} else { lower_bound - lower_bound % 4 };
        let last  = if upper_bound % 4 == 0 {upper_bound} else { upper_bound + 4 - upper_bound % 4 };
        for i in range_step(first, last, 4) @{
            let mut hit = [false, ..4];

            for j in vrange4(0, 4) @{
                intersect_ray_box(packet_ray_inv(p, i + j), b, |t0, t1| @{
                    if t1 > 0.0f && t0 < hit_t(h, i + j) @{
                        hit(j) = true;
                    }
                })
            }

            hit(0) &= p.mask(i + 0);
            hit(1) &= p.mask(i + 1);
            hit(2) &= p.mask(i + 2);
            hit(3) &= p.mask(i + 3);

            if hit(0) || hit(1) || hit(2) || hit(3) @{
                intr();
                return()
            }
        }

        /*for i in range(0, packet_size(p)) @{
            intersect_ray_box(packet_ray_inv(p, i), b, |t0, t1| @{
                if t1 > 0.0f && t0 < hit_t(h, i) @{
                    intr();
                    return()
                }
            })
        }*/
    });
}

