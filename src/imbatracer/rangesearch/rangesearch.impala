extern "C" {
    fn rand() -> i32;
}

static mut TEST_CNT = 0;
static mut TEST_SUM = 0;

struct Float3 {
    x : f32,
    y : f32,
    z : f32
}

struct Integer2 {
    x : i32,
    y : i32
}

struct Vector3 {
    x : RS_Float,
    y : RS_Float,
    z : RS_Float
}

struct PhotonHashGrid {
    radius         : f32,
    radius_sqr     : f32,
    cell_size      : f32,
    inv_cell_size  : f32,
    photons_size   : i32,
    hashtable_size : i32, 
    bbox_min       : Float3,
    bbox_max       : Float3,
    
    indices        : &[i32],
    cnts           : &[i32], 
    photons        : &[f32],
    rands          : &[i64],

    indices_buf    : Buffer,
    cnts_buf       : Buffer,
    rands_buf      : Buffer,

    time_count     : i64,
}

struct QueryResult {
    size   : i32,
    data   : &[i32]
}

struct BatchQueryResult {
    indices : &[i32],
    rrw     : &[i32],
    indices_buf : Buffer,
    rrw_buf     : Buffer  
}

fn vector3(f3: Float3) -> Vector3 {
    Vector3 {
        x : get_rs_float(f3.x),
        y : get_rs_float(f3.y),
        z : get_rs_float(f3.z)
    }
}

fn has_negative(a: Float3) -> bool {
    if (a.x < 0.f) { return(true) }
    if (a.y < 0.f) { return(true) }
    if (a.z < 0.f) { return(true) }
    false
}

fn is_query_out_of_bbox(query_pos: Float3, bbox_min: Float3, bbox_max: Float3) -> bool {
    if (query_pos.x - bbox_min.x < 0.f) { return(true) }
    if (query_pos.y - bbox_min.y < 0.f) { return(true) }
    if (query_pos.z - bbox_min.z < 0.f) { return(true) }
    if (bbox_max.x - query_pos.x < 0.f) { return(true) }
    if (bbox_max.y - query_pos.y < 0.f) { return(true) }
    if (bbox_max.z - query_pos.z < 0.f) { return(true) }
    false
}

fn is_query_inside_bbox(query_pos: Vector3, bbox_min: Vector3, bbox_max: Vector3) -> RS_Mask {
    let z = get_rs_float(0.f);
    let a = greater_eq((query_pos.x - bbox_min.x), z);
    let b = greater_eq((query_pos.y - bbox_min.y), z);
    let c = greater_eq((query_pos.z - bbox_min.z), z);
    let d = greater_eq((bbox_max.x - query_pos.x), z);
    let e = greater_eq((bbox_max.y - query_pos.y), z);
    let f = greater_eq((bbox_max.z - query_pos.z), z);
    and(a, and(b, and(c, and(d, and(e, f)))))
} 

fn cell_range(cell_idx: i32, cell_ends: &[i32]) -> Integer2 {
    let mut interval = Integer2 {
        x : 0,
        y : cell_ends(cell_idx)
    };
    if (cell_idx > 0) {
        interval.x = cell_ends(cell_idx - 1);
    }

    interval
}

fn hash_func(x: u32, y: u32, z: u32, m: u32) -> i32 {
    let ret = ((x * 73856093u32) ^ (y * 19349663u32) ^ (z * 83492791u32)) % m;
    ret as i32
}

// TODO CLEAN UP!
fn hash_func_p(x: RS_Unsigned, y: RS_Unsigned, z: RS_Unsigned, m: RS_Unsigned) -> RS_Unsigned {
    let m2 = get_rs_unsigned(bitcast[u32]((1 << 20) - 1));
    let ret = ((x * get_rs_unsigned(73856093u32)) ^ (y * get_rs_unsigned(19349663u32)) ^ (z * get_rs_unsigned(83492791u32))) & m2;
    ret
    //convert_u2i(ret)
} 

fn cell_index(pos: Float3, bbox_min: Float3, inv_cell_size: f32, cell_ends_size: i32) -> i32 {
    let dist_min = sub(pos, bbox_min);
    let coord = Float3 {
        x : floorf32((inv_cell_size * dist_min.x)),
        y : floorf32((inv_cell_size * dist_min.y)),
        z : floorf32((inv_cell_size * dist_min.z))
    };
    hash_func(coord.x as u32, coord.y as u32, coord.z as u32, cell_ends_size as u32)
}

// TODO change to return hash value rather than xyz
fn iterate_covered_cells(query_pos: Float3, bbox_min: Float3, inv_cell_size: f32, body: fn(i32, i32, i32) -> ()) -> () {
    let cell_x = inv_cell_size * (query_pos.x - bbox_min.x);
    let cell_y = inv_cell_size * (query_pos.y - bbox_min.y);
    let cell_z = inv_cell_size * (query_pos.z - bbox_min.z);
    
    let px = floorf32(cell_x);
    let py = floorf32(cell_y);
    let pz = floorf32(cell_z);

    let frac_coord_x = cell_x - px;
    let frac_coord_y = cell_y - py;
    let frac_coord_z = cell_z - pz;

    let dx = if (frac_coord_x < 0.5f) { -1f } else { 1f };
    let dy = if (frac_coord_y < 0.5f) { -1f } else { 1f };
    let dz = if (frac_coord_z < 0.5f) { -1f } else { 1f };

    let pxo = px + dx;
    let pyo = py + dy;
    let pzo = pz + dz;

    for i in @unroll(0, 8) {
        let z = if ((i & 1) != 0) { pzo as i32 } else { pz as i32 };
        let y = if ((i & 2) != 0) { pyo as i32 } else { py as i32 };
        let x = if ((i & 4) != 0) { pxo as i32 } else { px as i32 };
        body(x, y, z);
    }
}

fn compute_hash_vals(query_pos: Vector3, bbox_min: Vector3, inv_cell_size: RS_Float, hashtable_size: RS_Unsigned, body: fn(RS_Unsigned, i32) -> ()) -> () {
    let cell_x = inv_cell_size * (query_pos.x - bbox_min.x);
    let cell_y = inv_cell_size * (query_pos.y - bbox_min.y);
    let cell_z = inv_cell_size * (query_pos.z - bbox_min.z);
    
    let px = truncate(cell_x);
    let py = truncate(cell_y);
    let pz = truncate(cell_z);

    let frac_coord_x = cell_x - px;
    let frac_coord_y = cell_y - py;
    let frac_coord_z = cell_z - pz;

    let a = get_rs_float(1f);
    let b = get_rs_float(-1f);
    let c = get_rs_float(0.5f);

    let dx = select_rs_float(greater_eq(frac_coord_x, c), a, b);
    let dy = select_rs_float(greater_eq(frac_coord_y, c), a, b);
    let dz = select_rs_float(greater_eq(frac_coord_z, c), a, b);

    let pxo = px + dx;
    let pyo = py + dy;
    let pzo = pz + dz;

    let u_px  = convert_f2u(px);
    let u_py  = convert_f2u(py);
    let u_pz  = convert_f2u(pz);
    let u_pxo = convert_f2u(pxo);
    let u_pyo = convert_f2u(pyo);
    let u_pzo = convert_f2u(pzo);

    //let mut hashes : [RS_Unsigned * 8];

    for i in @unroll(0, 8) {
        let z = if ((i & 1) != 0) { u_pzo } else { u_pz };
        let y = if ((i & 2) != 0) { u_pyo } else { u_py };
        let x = if ((i & 4) != 0) { u_pxo } else { u_px };
        //let hash = hash_func_p(x, y, z, hashtable_size);
        //for j in @unroll(0, 8) {
        //    hashes(j)(i) = hash(j);
        //}
        body(hash_func_p(x, y, z, hashtable_size), i);
    }
    //for i in @unroll(0, 8) {
    //    body(hashes(i));
    //}
}

// LCG: Xn+1 = (a * Xn + c) % m
static RAND_DENOMINATOR = 2147483648f32; // 2^31
static MODULO = 0x7fffffffi64; // actually modulo - 1 = 2^31 - 1
static MULTIP = 1103515245i64;
static INCREM = 12345i64;  
fn lcg(state: i64) -> i64 {
    (MULTIP * state + INCREM) & MODULO
} 

fn build(mut hg: &PhotonHashGrid, isFirstTime: bool) -> () {
let mut prev_time : i64;
let mut tmp_time : i64;

    let photons        = hg.photons;
    let mut indices    = hg.indices;
    let mut cnts       = hg.cnts;
    let mut rands      = hg.rands;
    let photons_size   = hg.photons_size;
    let hashtable_size = hg.hashtable_size;
    let inv_cell_size  = hg.inv_cell_size;
    
    let offset_buf = alloc_buf(hashtable_size * sizeof[i32]()); 
    let pos_buf    = alloc_buf(photons_size * sizeof[i32]()); 
    let hash_buf   = alloc_buf(photons_size * sizeof[i32]());
    let complete_indices_buf = alloc_buf(photons_size * sizeof[i32]());
    
    let offsets      = bitcast[&[i32]](offset_buf.data);
    let mut poses    = bitcast[&[i32]](pos_buf.data);
    let mut hashes   = bitcast[&[i32]](hash_buf.data);
    let mut cindices = bitcast[&[i32]](complete_indices_buf.data);

prev_time = thorin_get_micro_time();

    if (isFirstTime) {
        for i in iterate(0, hashtable_size) {
            indices(i) = -1;
            cnts(i) = 0;
            rands(i) = lcg(i as i64);
        }
    }
    else {
        for i in iterate(0, hashtable_size) {
            indices(i) = -1;
            cnts(i) = 0;
            rands(i) = lcg(rands(i));
        }
    }

    //let tmp_buf = alloc_cpu(hashtable_size * sizeof[i32]());
    //let mut tmp = bitcast[&[i32]](tmp_buf.data);
    //for i in range(0, hashtable_size) { tmp(i) = rand(); }
    //for i in iterate(0, hashtable_size) {
    //    indices(i) = -1;
    //    cnts(i) = 0;
    //}

tmp_time = thorin_get_micro_time();
print_int((tmp_time - prev_time) as i32);
print_char('/');
prev_time = tmp_time;

    for bbox_min, bbox_max in compute_bbox(photons, photons_size) {
        hg.bbox_min.x = bbox_min.x;
        hg.bbox_min.y = bbox_min.y;
        hg.bbox_min.z = bbox_min.z;
        hg.bbox_max.x = bbox_max.x;
        hg.bbox_max.y = bbox_max.y;
        hg.bbox_max.z = bbox_max.z;
    }  
    
tmp_time = thorin_get_micro_time();
print_int((tmp_time - prev_time) as i32);
print_char('/');
prev_time = tmp_time;
    
    let bbox_min = hg.bbox_min;

    for i in iterate(0, photons_size) {
        let pos = Float3 {
            x : photons(3 * i),
            y : photons(3 * i + 1),
            z : photons(3 * i + 2)
        };
        let hash  = cell_index(pos, bbox_min, inv_cell_size, hashtable_size);
        hashes(i) = hash;
        poses(i)  = atomic_add(&(cnts(hash)), 1);
    }

tmp_time = thorin_get_micro_time();
print_int((tmp_time - prev_time) as i32);
print_char('/');
prev_time = tmp_time;
    
    exclusive_prefix_sum(cnts, offsets, hashtable_size);
    
    for i in iterate(0, photons_size) {
        cindices(poses(i) + offsets(hashes(i))) = i;
    }
    
tmp_time = thorin_get_micro_time();
print_int((tmp_time - prev_time) as i32);
print_char('/');
prev_time = tmp_time;
    
//for rand_seq_buf in use_host_buf_as(tmp_buf, hashtable_size * sizeof[i32]()) {
//    let rand_seq = bitcast[&[i32]](rand_seq_buf.data);
    for i in iterate(0, hashtable_size) {
        let cnt = cnts(i);
        if (cnt != 0) {
            let r = (rands(i) as f32) / RAND_DENOMINATOR; // uniformly distributed prn between [0,1)
            let os = floorf32(r * (cnt as f32)) as i32;
            indices(i) = cindices(offsets(i) + os);
            //indices(i) = cindices(offsets(i) + (rand_seq(i) % cnt));
        }
    }
//}

tmp_time = thorin_get_micro_time();
print_int((tmp_time - prev_time) as i32);
    
    release(offset_buf);
    release(pos_buf);
    release(hash_buf);
    release(complete_indices_buf);
    //release(tmp_buf);
}

extern fn build_hashgrid(mut hg: &PhotonHashGrid, photon_poses: &[f32], photon_cnt: i32, hash_size: i32, rad: f32) -> &PhotonHashGrid {
print_string("Time to build the hashgrid: ");
let start_time = thorin_get_micro_time();
   
    let mut retval : &PhotonHashGrid;
    if (hg as u64 == 0u64) {
        let indices_buf   = alloc_buf(hash_size * sizeof[i32]());
        let cnts_buf      = alloc_buf(hash_size * sizeof[i32]());
        let rands_buf     = alloc_buf(hash_size * sizeof[i64]());

        retval = ~PhotonHashGrid {
            radius         : rad,
            radius_sqr     : rad * rad,
            cell_size      : rad * 2.f,
            inv_cell_size  : 1.f / (rad * 2.f),
            photons_size   : photon_cnt,
            hashtable_size : hash_size,
            bbox_min       : Float3 { x:1e36f,  y:1e36f,  z:1e36f },
            bbox_max       : Float3 { x:-1e36f, y:-1e36f, z:-1e36f },
            
            indices        : bitcast[&[i32]](indices_buf.data),
            cnts           : bitcast[&[i32]](cnts_buf.data),
            photons        : photon_poses,     
            rands          : bitcast[&[i64]](rands_buf.data),

            indices_buf    : indices_buf,
            cnts_buf       : cnts_buf,
            rands_buf      : rands_buf,
        
            time_count     : 0i64,
        };
        build(retval, true);
    }
    else {
        hg.radius         =  rad;
        hg.radius_sqr     =  rad * rad;
        hg.cell_size      =  rad * 2.f;
        hg.inv_cell_size  =  1.f / (rad * 2.f);
        hg.photons_size   =  photon_cnt;
        hg.hashtable_size =  hash_size;
        hg.bbox_min       =  Float3 { x:1e36f,  y:1e36f,  z:1e36f };
        hg.bbox_max       =  Float3 { x:-1e36f, y:-1e36f, z:-1e36f };
        hg.photons        =  photon_poses;
        hg.time_count     =  0i64;
        retval = hg;
        build(retval, false);
    }

print_string("->");
let tmp = thorin_get_micro_time() - start_time;
print_int(tmp as i32);
TEST_SUM += tmp as i32;
print_char('(');
print_int(TEST_SUM / ++TEST_CNT);
print_char(')');
print_string("\n");

    retval
}

// Query Abstraction: Ver.1 w/o vectorization
extern fn batch_query_hashgrid(mut hg: &PhotonHashGrid, query_poses: &[f32], size: i32) -> &BatchQueryResult {
let start_time = thorin_get_micro_time();
   
    let radius_sqr     = hg.radius_sqr;
    let hashtable_size = hg.hashtable_size;
    let inv_cell_size  = hg.inv_cell_size;
    let bbox_min       = hg.bbox_min;
    let bbox_max       = hg.bbox_max;
    let cnts           = hg.cnts; 
    let indices        = hg.indices; 
    let photons        = hg.photons; 
    
    let batch_buf  = alloc_buf(8 * size * sizeof[i32]());
    let rrw_buf    = alloc_buf(8 * size * sizeof[i32]());
    let mut rrw    = bitcast[&[i32]](rrw_buf.data);
    let mut batch  = bitcast[&[i32]](batch_buf.data);
   
    for i in iterate(0, size) @{
        let offset = i * 8;
        let query_pos = Float3 { x : query_poses(i * 3),
                                 y : query_poses(i * 3 + 1),
                                 z : query_poses(i * 3 + 2) };
        let mut stride = &(batch(offset)) as &simd[i32 * 8];
        *stride = simd[-1, -1, -1, -1, -1, -1, -1, -1]; 
        if (!is_query_out_of_bbox(query_pos, bbox_min, bbox_max)) {
            let mut cnt = 0;
            for x, y, z in iterate_covered_cells(query_pos, bbox_min, inv_cell_size) {
                let hash = hash_func(x as u32, y as u32, z as u32, hashtable_size as u32);
                let photon_idx = indices(hash);
                if (photon_idx != -1) {
                    let px = photons(photon_idx * 3); 
                    let py = photons(photon_idx * 3 + 1); 
                    let pz = photons(photon_idx * 3 + 2);
                    let dx = query_pos.x - px;
                    let dy = query_pos.y - py;
                    let dz = query_pos.z - pz;
                    let dist_sqr = dx * dx + dy * dy + dz * dz;
                    let idx = offset + cnt;
                    if (dist_sqr <= radius_sqr) {
                        batch(idx) = photon_idx;
                        rrw(idx) = cnts(hash);
                    }
                }
                cnt++;
            }
        }
    }

    let mut retval : &BatchQueryResult;

    for output_rrw_buf in output_as_host_buf(rrw_buf, 8 * size * sizeof[i32]()) {
        for output_indices_buf in output_as_host_buf(batch_buf, 8 * size * sizeof[i32]()) {         
            retval = ~BatchQueryResult {
                indices : bitcast[&[i32]](output_indices_buf.data),
                rrw     : bitcast[&[i32]](output_rrw_buf.data),
                indices_buf : output_indices_buf,
                rrw_buf     : output_rrw_buf
            };
        }
    }

hg.time_count += thorin_get_micro_time() - start_time;

    retval
} 

// Query Abstraction: Ver.2 with AVX
extern fn batch_query_hashgrid2(mut hg: &PhotonHashGrid, query_poses: &[f32], size: i32) -> &BatchQueryResult {
let start_time = thorin_get_micro_time();
    
    let radius_sqr     = hg.radius_sqr;
    let hashtable_size = get_rs_unsigned(hg.hashtable_size as u32);
    let inv_cell_size  = get_rs_float(hg.inv_cell_size);
    let bbox_min       = vector3(hg.bbox_min);
    let bbox_max       = vector3(hg.bbox_max);
    let cnts           = hg.cnts; 
    let indices        = hg.indices; 
    let photons        = hg.photons; 
    
    let batch_buf  = alloc_buf(8 * size * sizeof[i32]());
    let rrw_buf    = alloc_buf(8 * size * sizeof[i32]());
    let mut rrw    = bitcast[&[i32]](rrw_buf.data);
    let mut batch  = bitcast[&[i32]](batch_buf.data);

    for query_pos, cur_vec_size, out_idx_os in iterate_queries(query_poses, size) @{
        
        let masks = is_query_inside_bbox(query_pos, bbox_min, bbox_max);
       
        for hash_vals, neighbor_idx in compute_hash_vals(query_pos, bbox_min, inv_cell_size, hashtable_size) {
            
            for mask, hash_val, out_idx, pos in iterate_single_query(out_idx_os, neighbor_idx, cur_vec_size, query_pos, hash_vals, masks) {
                batch(out_idx) = -1;
                if (mask) {
                    let photon_idx = indices(hash_val);
                    if (photon_idx != -1) {
                        let px = photons(photon_idx * 3);
                        let py = photons(photon_idx * 3 + 1);
                        let pz = photons(photon_idx * 3 + 2);
                        let dx = pos.x - px;
                        let dy = pos.y - py;
                        let dz = pos.z - pz;
                        let dist_sqr = dx * dx + dy * dy + dz * dz;
                        if (dist_sqr <= radius_sqr) {
                            batch(out_idx) = photon_idx;
                            rrw(out_idx) = cnts(hash_val);
                        }
                    }
                }
            }
        }
    }

    let mut retval : &BatchQueryResult;

    for output_rrw_buf in output_as_host_buf(rrw_buf, 8 * size * sizeof[i32]()) {
        for output_indices_buf in output_as_host_buf(batch_buf, 8 * size * sizeof[i32]()) {         
            retval = ~BatchQueryResult {
                indices : bitcast[&[i32]](output_indices_buf.data),
                rrw     : bitcast[&[i32]](output_rrw_buf.data),
                indices_buf : output_indices_buf,
                rrw_buf     : output_rrw_buf
            };
        }
    }

hg.time_count += thorin_get_micro_time() - start_time;

    retval
}


extern fn destroy_hashgrid(hg: &PhotonHashGrid) -> () {
    release((*hg).indices_buf);
    release((*hg).cnts_buf);
    release((*hg).rands_buf);
}

extern fn release_query(arr: &QueryResult) -> () {
}

extern fn release_batch_query(query: &BatchQueryResult) -> () {
    release((*query).indices_buf);
    release((*query).rrw_buf);
}
