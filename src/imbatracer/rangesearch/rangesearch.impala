// HashGrid partial implementation in impala
// Try different array operations in impala 

struct Float3 {
    x : f32,
    y : f32,
    z : f32
}

struct Integer2 {
    x : i32,
    y : i32
}

struct HashGridInfo {
    radius         : f32,
    radius_sqr     : f32,
    cell_size      : f32,
    inv_cell_size  : f32,
    indices_size   : i32,
    cell_ends_size : i32,
    bbox_min       : Float3,
    bbox_max       : Float3,
    indices        : &[u64],
    cell_ends      : &[i32]
}

struct QueryResult {
    size : i32,
    capacity : i32,
    pointers : &[u64]
}

fn sub(a: Float3, b: Float3) -> Float3 {
    Float3 {
        x : a.x - b.x,
        y : a.y - b.y,
        z : a.z - b.z
    }
}

fn scalar(s: f32, v: Float3) -> Float3 {
    Float3 {
        x : s * v.x,
        y : s * v.y,
        z : s * v.z,
    }
}

fn dot(a: Float3, b: Float3) -> f32 {
    a.x * b.x +
    a.y * b.y +
    a.z * b.z
}

fn sqr(v: Float3) -> f32 {
    @dot(v, v)
}

fn has_negative(a: Float3) -> bool {
    if (a.x < 0.f) { return(true) }
    if (a.y < 0.f) { return(true) }
    if (a.z < 0.f) { return(true) }
    false
}

fn cell_range(cell_idx: i32, cell_ends: &[i32]) -> Integer2 {
    let mut interval = Integer2 {
        x : 0,
        y : cell_ends(cell_idx)
    };
    if (cell_idx > 0) {
        interval.x = cell_ends(cell_idx - 1);
    }
    interval
}

fn hash_func(x: u32, y: u32, z: u32, m: u32) -> i32 {
    let ret = ((x * 73856093u) ^ (y * 19349663u) ^ (z * 83492791u)) % m;
    ret as i32
}

fn cell_index(point: Float3, info: HashGridInfo) -> i32 {
    let dist_min = sub(point, info.bbox_min);
    let coord = Float3 {
        x : floorf32((info.inv_cell_size * dist_min.x)),
        y : floorf32((info.inv_cell_size * dist_min.y)),
        z : floorf32((info.inv_cell_size * dist_min.z))
    };
    hash_func(coord.x as u32, coord.y as u32, coord.z as u32, info.cell_ends_size as u32)
}

// TODO is this correct?
fn floorf32 (f : f32) -> f32 {
    let i = f as i32;
    i as f32
}

// Interfaces
extern fn hashgrid_query(mut output: &QueryResult, info: &HashGridInfo, query_pos: Float3) -> () {
    let dist_min = sub(query_pos, info.bbox_min);
    let dist_max = sub(info.bbox_max, query_pos);

    // dynamic allocate memory, free them in c++
    output = ~QueryResult {
        size : 0,
        capacity : info.indices_size,
        pointers : ~[info.indices_size: u64] // init an array 
    };
    
    if (has_negative(dist_min)) { return() }
    if (has_negative(dist_max)) { return() }    
    
    let cell = scalar(info.inv_cell_size, dist_min);

    let coord = Float3 {
        x : floorf32(cell.x),
        y : floorf32(cell.y),
        z : floorf32(cell.z)
    };

    let px = coord.x as i32;
    let py = coord.y as i32;
    let pz = coord.z as i32;

    let frac_coord = sub(cell, coord);
    
    let mut pxo = px;
    let mut pyo = py;
    let mut pzo = pz;

    fn neighbour(mut val: &i32, frac: f32) -> () {
        let mut i = 1;
        if (frac < 0.5f) {
            i = -1; 
        }
        *val += i;
    }

    neighbour(&pxo, frac_coord.x);
    neighbour(&pyo, frac_coord.y);
    neighbour(&pzo, frac_coord.z);


    for i in @unroll(0, 8) {
        let z = if ((i & 1) as bool) { pzo } else { pz };
        let y = if ((i & 2) as bool) { pyo } else { py };
        let x = if ((i & 4) as bool) { pxo } else { px };

        let interval = cell_range(hash_func(x as u32, y as u32, z as u32, info.cell_ends_size as u32), info.cell_ends);  
        let start = output.size;
        output.size += interval.y - interval.x;
        
        for j in range(interval.x, interval.y) {
            // TODO cannot filter distance against radius at here, no acces to c++ data
            // TODO add j into output
            output.pointers(start + j - interval.x) = info.indices(j);
        }
    }
}
