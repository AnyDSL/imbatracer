struct Float3 {
    x : f32,
    y : f32,
    z : f32
}

struct Integer2 {
    x : i32,
    y : i32
}

struct PhotonHashGrid {
    radius         : f32,
    radius_sqr     : f32,
    cell_size      : f32,
    inv_cell_size  : f32,
    photons_size   : i32,
    hashtable_size      : i32, 
    bbox_min       : Float3,
    bbox_max       : Float3,
    
    indices        : &[i32],
    cnts           : &[i32], 
    photons        : &[f32],

    photons_buf    : Buffer,
    indices_buf    : Buffer,
    cnts_buf       : Buffer,
}

struct RawDataInfo {
    begin  : &[f32],
    stride : i32
}

struct QueryResult {
    size   : i32,
    data   : &[i32]
}

struct BatchQueryResult {
    indices : &[i32],
    rrw     : &[i32],
    indices_buf : Buffer,
    rrw_buf     : Buffer  
}

fn has_negative(a: Float3) -> bool {
    if (a.x < 0.f) { return(true) }
    if (a.y < 0.f) { return(true) }
    if (a.z < 0.f) { return(true) }
    false
}

fn is_query_out_of_bbox(query_pos: Float3, bbox_min: Float3, bbox_max: Float3) -> bool {
    if (query_pos.x - bbox_min.x < 0.f) { return(true) }
    if (query_pos.y - bbox_min.y < 0.f) { return(true) }
    if (query_pos.z - bbox_min.z < 0.f) { return(true) }
    if (bbox_max.x - query_pos.x < 0.f) { return(true) }
    if (bbox_max.y - query_pos.y < 0.f) { return(true) }
    if (bbox_max.z - query_pos.z < 0.f) { return(true) }
    false
}

fn cell_range(cell_idx: i32, cell_ends: &[i32]) -> Integer2 {
    let mut interval = Integer2 {
        x : 0,
        y : cell_ends(cell_idx)
    };
    if (cell_idx > 0) {
        interval.x = cell_ends(cell_idx - 1);
    }

    interval
}

fn hash_func(x: u32, y: u32, z: u32, m: u32) -> i32 {
    let ret = ((x * 73856093u32) ^ (y * 19349663u32) ^ (z * 83492791u32)) % m;
    ret as i32
}

fn cell_index(pos: Float3, bbox_min: Float3, inv_cell_size: f32, cell_ends_size: i32) -> i32 {
    let dist_min = sub(pos, bbox_min);
    let coord = Float3 {
        x : floorf32((inv_cell_size * dist_min.x)),
        y : floorf32((inv_cell_size * dist_min.y)),
        z : floorf32((inv_cell_size * dist_min.z))
    };
    hash_func(coord.x as u32, coord.y as u32, coord.z as u32, cell_ends_size as u32)
}

fn iterate_covered_cells(query_pos: Float3, bbox_min: Float3, inv_cell_size: f32, body: fn(i32, i32, i32) -> ()) -> () {
    let cell_x = inv_cell_size * (query_pos.x - bbox_min.x);
    let cell_y = inv_cell_size * (query_pos.y - bbox_min.y);
    let cell_z = inv_cell_size * (query_pos.z - bbox_min.z);
    
    let px = floorf32(cell_x);
    let py = floorf32(cell_y);
    let pz = floorf32(cell_z);

    let frac_coord_x = cell_x - px;
    let frac_coord_y = cell_y - py;
    let frac_coord_z = cell_z - pz;

    let dx = if (frac_coord_x < 0.5f) { -1f } else { 1f };
    let dy = if (frac_coord_y < 0.5f) { -1f } else { 1f };
    let dz = if (frac_coord_z < 0.5f) { -1f } else { 1f };

    let pxo = px + dx;
    let pyo = py + dy;
    let pzo = pz + dz;

    for i in @unroll(0, 8) {
        let z = if ((i & 1) != 0) { pzo as i32 } else { pz as i32 };
        let y = if ((i & 2) != 0) { pyo as i32 } else { py as i32 };
        let x = if ((i & 4) != 0) { pxo as i32 } else { px as i32 };
        body(x, y, z);
    }
}

fn build(mut hg: &PhotonHashGrid) -> () {
    //let start_time = thorin_get_micro_time();
    
    let photons        = hg.photons;
    let mut indices    = hg.indices;
    let mut cnts       = hg.cnts;
    let photons_size   = hg.photons_size;
    let hashtable_size = hg.hashtable_size;
    let inv_cell_size  = hg.inv_cell_size;
    
    let offset_buf = alloc_buf(hashtable_size * sizeof[i32]()); 
    let pos_buf    = alloc_buf(photons_size * sizeof[i32]()); 
    let hash_buf   = alloc_buf(photons_size * sizeof[i32]());
    let rand_buf   = alloc_cpu(hashtable_size * sizeof[f32]()); 
    let complete_indices_buf = alloc_buf(photons_size * sizeof[i32]());
    
    let offsets      = bitcast[&[i32]](offset_buf.data);
    let mut poses    = bitcast[&[i32]](pos_buf.data);
    let mut hashes   = bitcast[&[i32]](hash_buf.data);
    let mut rands    = bitcast[&[f32]](rand_buf.data);
    let mut cindices = bitcast[&[i32]](complete_indices_buf.data);
    
    //thorin_random_seed(thorin_get_micro_time() as u32);
    for i in range(0, hashtable_size) {
        rands(i) = thorin_random_val();
    } 

    for bbox_min, bbox_max in compute_bbox(photons, photons_size) {
        hg.bbox_min.x = bbox_min.x;
        hg.bbox_min.y = bbox_min.y;
        hg.bbox_min.z = bbox_min.z;
        hg.bbox_max.x = bbox_max.x;
        hg.bbox_max.y = bbox_max.y;
        hg.bbox_max.z = bbox_max.z;
    }  

    for i in iterate(0, hashtable_size) {
        cnts(i) = 0;
        //indices(i) = -1;
    } 

    let bbox_min = hg.bbox_min;

    for i in iterate(0, photons_size) {
        let pos = Float3 {
            x : photons(3 * i),
            y : photons(3 * i + 1),
            z : photons(3 * i + 2)
        };
        let hash  = cell_index(pos, bbox_min, inv_cell_size, hashtable_size);
        hashes(i) = hash;
        poses(i)  = atomic_add(&(cnts(hash)), 1);
        // random writes version which is tested being not uniformly distributed
        //indices(hash) = i;
        //atomic_add(&(cnts(hash)), 1);
    }

    exclusive_prefix_sum(cnts, offsets, hashtable_size);

    for i in iterate(0, photons_size) {
        cindices(poses(i) + offsets(hashes(i))) = i;
    }

    for rand_seq_buf in use_host_buf_as(rand_buf, hashtable_size * sizeof[f32]()) {
        let rand_seq = bitcast[&[f32]](rand_seq_buf.data);
        for i in iterate(0, hashtable_size) {
            // use prn seq to choose only one photon for each hash bucket
            let cnt = cnts(i);
            if (cnt == 0) {
                indices(i) = -1;
            }
            else {
                indices(i) = cindices(offsets(i) + (floorf32(cnt as f32 * rand_seq(i)) as i32));
            }
        }
    }

    release(offset_buf);
    release(pos_buf);
    release(hash_buf);
    release(rand_buf);
    release(complete_indices_buf);

    //print_string("Time to build the hashgrid: ");
    //print_int((thorin_get_micro_time() - start_time) as i32);
    //print_string("\n");
}

fn batch_query(hg: &PhotonHashGrid, query_poses: &[f32], size: i32) -> &BatchQueryResult {
    //let start_time = thorin_get_micro_time();
    
    let radius_sqr     = hg.radius_sqr;
    let hashtable_size = hg.hashtable_size;
    let inv_cell_size  = hg.inv_cell_size;
    let bbox_min       = hg.bbox_min;
    let bbox_max       = hg.bbox_max;
    let cnts           = hg.cnts; 
    let indices        = hg.indices; 
    let photons        = hg.photons; 
    
    let batch_buf  = alloc_buf(8 * size * sizeof[i32]());
    let rrw_buf    = alloc_buf(8 * size * sizeof[i32]());
    let mut rrw    = bitcast[&[i32]](rrw_buf.data);
    let mut batch  = bitcast[&[i32]](batch_buf.data);
    
    for i in iterate(0, size) @{
        let offset = i * 8;
        let query_pos = Float3 { x : query_poses(i * 3),
                                 y : query_poses(i * 3 + 1),
                                 z : query_poses(i * 3 + 2) };
        let mut stride = &(batch(offset)) as &simd[i32 * 8];
        *stride = simd[-1, -1, -1, -1, -1, -1, -1, -1]; 
        if (!is_query_out_of_bbox(query_pos, bbox_min, bbox_max)) {
            let mut cnt = 0;
            for x, y, z in iterate_covered_cells(query_pos, bbox_min, inv_cell_size) {
                let hash = hash_func(x as u32, y as u32, z as u32, hashtable_size as u32);
                let photon_idx = indices(hash);
                if (photon_idx != -1) { 
                    let px = photons(photon_idx * 3); 
                    let py = photons(photon_idx * 3 + 1); 
                    let pz = photons(photon_idx * 3 + 2);
                    let dx = query_pos.x - px;
                    let dy = query_pos.y - py;
                    let dz = query_pos.z - pz;
                    let dist_sqr = dx * dx + dy * dy + dz * dz;
                    let idx = offset + cnt;
                    if (dist_sqr <= radius_sqr) {
                        batch(idx) = photon_idx;
                        rrw(idx) = cnts(hash);
                    }
                }
                cnt++;
            }
        }
    }

    let mut retval : &BatchQueryResult;

    for output_rrw_buf in output_as_host_buf(rrw_buf, 8 * size * sizeof[i32]()) {
        for output_indices_buf in output_as_host_buf(batch_buf, 8 * size * sizeof[i32]()) {         
            retval = ~BatchQueryResult {
                indices : bitcast[&[i32]](output_indices_buf.data),
                rrw     : bitcast[&[i32]](output_rrw_buf.data),
                indices_buf : output_indices_buf,
                rrw_buf     : output_rrw_buf
            };
        }
    }

    //print_string("Total time to batch query the hashgrid: ");
    //print_int((thorin_get_micro_time() - start_time) as i32);
    //print_string(" among ");
    //print_int(size);
    //print_string(" queries");
    //print_string("\n");
    
    retval
} 

extern fn destroy_hashgrid(hg: &PhotonHashGrid) -> () {
    release((*hg).photons_buf);
    release((*hg).indices_buf);
    release((*hg).cnts_buf);
}

extern fn release_query(arr: &QueryResult) -> () {
}

extern fn release_batch_query(query: &BatchQueryResult) -> () {
    release((*query).indices_buf);
    release((*query).rrw_buf);
}
