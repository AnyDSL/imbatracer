struct Float3 {
    x : f32,
    y : f32,
    z : f32
}

struct Integer2 {
    x : i32,
    y : i32
}

struct PhotonHashGrid {
    radius         : f32,
    radius_sqr     : f32,
    cell_size      : f32,
    inv_cell_size  : f32,
    photons_size   : i32,
    indices_size   : i32,
    cell_ends_size : i32,
    bbox_min       : Float3,
    bbox_max       : Float3,
    
    indices        : &[i32],
    cell_ends      : &[i32],
    photons        : &[f32],

    photons_buf    : Buffer,
    indices_buf    : Buffer,
    cell_ends_buf  : Buffer,
    result_buf     : Buffer,
}

struct RawDataInfo {
    begin  : &[f32],
    stride : i32
}

struct QueryResult {
    size   : i32,
    data   : &[i32],
}

struct BatchQueryResult {
    size : i32,           // size of indices
    indices : &[i32],
    offsets : &[i32],
    indices_buf : Buffer, // indices for all queried photons
    offsets_buf : Buffer  // prefix-sum of the number of queried photons for all query positions
}

fn has_negative(a: Float3) -> bool {
    if (a.x < 0.f) { return(true) }
    if (a.y < 0.f) { return(true) }
    if (a.z < 0.f) { return(true) }
    false
}

fn is_query_out_of_bbox(query_pos: Float3, bbox_min: Float3, bbox_max: Float3) -> bool {
    if (query_pos.x - bbox_min.x < 0.f) { return(true) }
    if (query_pos.y - bbox_min.y < 0.f) { return(true) }
    if (query_pos.z - bbox_min.z < 0.f) { return(true) }
    if (bbox_max.x - query_pos.x < 0.f) { return(true) }
    if (bbox_max.y - query_pos.y < 0.f) { return(true) }
    if (bbox_max.z - query_pos.z < 0.f) { return(true) }
    false
}

fn cell_range(cell_idx: i32, cell_ends: &[i32]) -> Integer2 {
    let mut interval = Integer2 {
        x : 0,
        y : cell_ends(cell_idx)
    };
    if (cell_idx > 0) {
        interval.x = cell_ends(cell_idx - 1);
    }

    interval
}

fn hash_func(x: u32, y: u32, z: u32, m: u32) -> i32 {
    let ret = ((x * 73856093u32) ^ (y * 19349663u32) ^ (z * 83492791u32)) % m;
    ret as i32
}

fn cell_index(pos: Float3, bbox_min: Float3, inv_cell_size: f32, cell_ends_size: i32) -> i32 {
    let dist_min = sub(pos, bbox_min);
    let coord = Float3 {
        x : floorf32((inv_cell_size * dist_min.x)),
        y : floorf32((inv_cell_size * dist_min.y)),
        z : floorf32((inv_cell_size * dist_min.z))
    };
    hash_func(coord.x as u32, coord.y as u32, coord.z as u32, cell_ends_size as u32)
}

fn iterate_neighbor_cells(query_pos: Float3, bbox_min: Float3, inv_cell_size: f32, body: fn(i32, i32, i32) -> ()) -> () {
    let cell_x = inv_cell_size * (query_pos.x - bbox_min.x);
    let cell_y = inv_cell_size * (query_pos.y - bbox_min.y);
    let cell_z = inv_cell_size * (query_pos.z - bbox_min.z);
    
    let px = floorf32(cell_x);
    let py = floorf32(cell_y);
    let pz = floorf32(cell_z);

    let frac_coord_x = cell_x - px;
    let frac_coord_y = cell_y - py;
    let frac_coord_z = cell_z - pz;

    let dx = if (frac_coord_x < 0.5f) { -1f } else { 1f };
    let dy = if (frac_coord_y < 0.5f) { -1f } else { 1f };
    let dz = if (frac_coord_z < 0.5f) { -1f } else { 1f };

    let pxo = px + dx;
    let pyo = py + dy;
    let pzo = pz + dz;

    for i in @unroll(0, 8) {
        let z = if ((i & 1) != 0) { pzo as i32 } else { pz as i32 };
        let y = if ((i & 2) != 0) { pyo as i32 } else { py as i32 };
        let x = if ((i & 4) != 0) { pxo as i32 } else { px as i32 };
        body(x, y, z);
    }
}

fn build(mut hg: &PhotonHashGrid) -> () {
    let cnt_buf  = alloc_buf(hg.cell_ends_size * sizeof[i32]()); 
    let pos_buf  = alloc_buf(hg.photons_size * sizeof[i32]()); 
    let hash_buf = alloc_buf(hg.photons_size * sizeof[i32]());
    let mut cnts   = bitcast[&[i32]](cnt_buf.data);
    let mut poses  = bitcast[&[i32]](pos_buf.data);
    let mut hashes = bitcast[&[i32]](hash_buf.data);
    
    let photons       = hg.photons;
    let mut indices   = hg.indices;
    let mut cell_ends = hg.cell_ends;

    let photons_size   = hg.photons_size;
    let cell_ends_size = hg.cell_ends_size;
    let inv_cell_size  = hg.inv_cell_size;
    
    for bbox_min, bbox_max in compute_bbox(photons, photons_size) {
        hg.bbox_min.x = bbox_min.x;
        hg.bbox_min.y = bbox_min.y;
        hg.bbox_min.z = bbox_min.z;
        hg.bbox_max.x = bbox_max.x;
        hg.bbox_max.y = bbox_max.y;
        hg.bbox_max.z = bbox_max.z;
    }  

    for i in iterate(0, cell_ends_size) {
        cnts(i) = 0;
    } 

    let bbox_min = hg.bbox_min;

    for i in iterate(0, photons_size) {
        let pos = Float3 {
            x : photons(3 * i),
            y : photons(3 * i + 1),
            z : photons(3 * i + 2)
        };
        let hash  = cell_index(pos, bbox_min, inv_cell_size, cell_ends_size);
        hashes(i) = hash;
        poses(i)  = atomic_add(&(cnts(hash)), 1);
    }

    exclusive_prefix_sum(cnts, cell_ends, cell_ends_size);

    for i in iterate(0, photons_size) {
        indices(poses(i) + cell_ends(hashes(i))) = i;
    }

    for i in iterate(0, cell_ends_size) {
        cell_ends(i) += cnts(i);
    }

    release(cnt_buf);
    release(pos_buf);
    release(hash_buf);
}

fn batch_query(hg: &PhotonHashGrid, query_poses: &[f32], size: i32) -> &BatchQueryResult {
    let radius_sqr     = hg.radius_sqr;
    let cell_ends_size = hg.cell_ends_size;
    let inv_cell_size  = hg.inv_cell_size;
    let bbox_min       = hg.bbox_min;
    let bbox_max       = hg.bbox_max;
    let cell_ends      = hg.cell_ends; 
    let indices        = hg.indices; 
    let photons        = hg.photons; 
    
    let MAX_SIZE = 1024; // max size of output photons of each query
    let batch_buf  = alloc_buf(MAX_SIZE * size * sizeof[i32]());
    let sizes_buf  = alloc_buf(size * sizeof[i32]());
    let mut sizes  = bitcast[&[i32]](sizes_buf.data);
    let mut batch  = bitcast[&[i32]](batch_buf.data);
    
    for i in iterate(0, size) {
        sizes(i) = 0;
        let offset = i * MAX_SIZE;
        let query_pos = Float3 { x : query_poses(i * 3),
                                 y : query_poses(i * 3 + 1),
                                 z : query_poses(i * 3 + 2) };
        if (!is_query_out_of_bbox(query_pos, bbox_min, bbox_max)) {
            for x, y, z in iterate_neighbor_cells(query_pos, bbox_min, inv_cell_size) {
                let cell_idx = hash_func(x as u32, y as u32, z as u32, cell_ends_size as u32);
                let mut start = 0;
                let end = cell_ends(cell_idx);
                if ( cell_idx > 0) {
                    start = cell_ends(cell_idx - 1);
                }
                for j in range(start, end) {
                    let photon_idx = indices(j);
                    let px = photons(photon_idx * 3); 
                    let py = photons(photon_idx * 3 + 1); 
                    let pz = photons(photon_idx * 3 + 2);
                    let dx = query_pos.x - px;
                    let dy = query_pos.y - py;
                    let dz = query_pos.z - pz;
                    let dist_sqr = dx * dx + dy * dy + dz * dz;
                    if (dist_sqr <= radius_sqr) {
                        if (sizes(i) < MAX_SIZE) {
                            batch(offset + (sizes(i)++)) = photon_idx;
                        } 
                    }                   
                }
            }
        }
    }

    let offsets_buf = alloc_buf(size * sizeof[i32]());
    let offsets     = bitcast[&[i32]](offsets_buf.data);
//print_string("before_scan\n");
    exclusive_prefix_sum(sizes, offsets, size);
//print_string("after_scan\n");

    let mut retval : &BatchQueryResult;

    for host_sizes_buf in use_buf_on_cpu(sizes_buf, size * sizeof[i32]()) {
        let output_offsets_buf = alloc_cpu(size * sizeof[i32]());

        copy(offsets_buf, output_offsets_buf, size * sizeof[i32]());
        
        let output_size = bitcast[&[i32]](host_sizes_buf.data)(size - 1) + bitcast[&[i32]](output_offsets_buf.data)(size - 1);
        
        let output_indices_buf = alloc_cpu(output_size * sizeof[i32]());

        let output_offsets = bitcast[&[i32]](output_offsets_buf.data);
        let host_sizes     = bitcast[&[i32]](host_sizes_buf.data);
        for i in range(0, size) {
            if (host_sizes(i) > 0) {
                copy_offset(batch_buf, i * MAX_SIZE * sizeof[i32](), output_indices_buf, output_offsets(i) * sizeof[i32](), host_sizes(i) * sizeof[i32]());
            }
            //if (host_sizes(i) >= 1024) { abort(); }
        }         

        retval = ~BatchQueryResult {
            size : output_size,
            indices : bitcast[&[i32]](output_indices_buf.data),
            offsets : bitcast[&[i32]](output_offsets_buf.data),
            indices_buf : output_indices_buf,
            offsets_buf : output_offsets_buf
        }
    }

    //
    release(sizes_buf);
    release(offsets_buf);
    release(batch_buf);

    retval
} 

extern fn destroy_hashgrid(hg: &PhotonHashGrid) -> () {
    release((*hg).photons_buf);
    release((*hg).indices_buf);
    release((*hg).cell_ends_buf);
    release((*hg).result_buf);
}

extern fn release_query(arr: &QueryResult) -> () {
}

extern fn release_batch_query(query: &BatchQueryResult) -> () {
    release((*query).indices_buf);
    release((*query).offsets_buf);
}
