// HashGrid partial implementation in impala
// Try different array operations in impala 

extern "C" {
    fn abort() -> ();
}


fn compute_bbox(photons: &[f32], size: i32, body: fn(Float3, Float3)->()) -> () {
    let mut bbox_min = Float3 { x : 1e36f,  y : 1e36f,  z : 1e36f };
    let mut bbox_max = Float3 { x : -1e36f, y : -1e36f, z : -1e36f };
    for i in range(0, size) {
        let x = photons(3 * i);
        let y = photons(3 * i + 1);
        let z = photons(3 * i + 2);
        bbox_max.x = max(bbox_max.x, x);
        bbox_max.y = max(bbox_max.y, y);
        bbox_max.z = max(bbox_max.z, z);
        bbox_min.x = min(bbox_min.x, x);
        bbox_min.y = min(bbox_min.y, y);
        bbox_min.z = min(bbox_min.z, z);
    }

    body(bbox_min, bbox_max)
}

// Interfaces
//extern fn query_hashgrid(mut hg: &PhotonHashGrid, x: f32, y: f32, z: f32) -> &QueryResult {
//    let size = (*hg).photons_size;
//    
//    let query_pos = Float3 {
//        x : x,
//        y : y,
//        z : z
//    };
//   
//    let mut arr = ~QueryResult {
//                      size   : 0,
//                      data   : bitcast[&[i32]]((*hg).host_result_buf.data)
//                  };
//
//    let dist_min = sub(query_pos, (*hg).bbox_min);
//    let dist_max = sub((*hg).bbox_max, query_pos);
//
//    if (has_negative(dist_min) || has_negative(dist_max)) { 
//        return (arr)
//    }
//    
//    let cell = scalar((*hg).inv_cell_size, dist_min);
//
//    let coord = Float3 {
//        x : floorf32(cell.x),
//        y : floorf32(cell.y),
//        z : floorf32(cell.z)
//    };
//
//    let px = coord.x as i32;
//    let py = coord.y as i32;
//    let pz = coord.z as i32;
//
//    let frac_coord = sub(cell, coord);
//
//    let dx = if (frac_coord.x < 0.5f) { -1 } else { 1 };
//    let dy = if (frac_coord.y < 0.5f) { -1 } else { 1 };
//    let dz = if (frac_coord.z < 0.5f) { -1 } else { 1 };
//
//    let pxo = px + dx;
//    let pyo = py + dy;
//    let pzo = pz + dz;
//
//    for i in @unroll(0, 8) {
//        let z = if ((i & 1) != 0) { pzo } else { pz };
//        let y = if ((i & 2) != 0) { pyo } else { py };
//        let x = if ((i & 4) != 0) { pxo } else { px };
//
//        let interval = cell_range(hash_func(x as u32, y as u32, z as u32, (*hg).cell_ends_size as u32), (*hg).cell_ends);  
//        let start = arr.size;
//        let mut curCnt = 0;
//
//        for j in $range(interval.x, interval.y) {
//            let idx = (*hg).indices(j);
//            let pos = toFloat3(hg, idx);
//            let distSqr = sqr(sub(query_pos, pos));
//            if (distSqr <= (*hg).radius_sqr) {
//                arr.data(start + curCnt) = idx;
//                curCnt++;
//            }
//        }
//
//        arr.size += curCnt;
//    }
//
//    arr
//}

