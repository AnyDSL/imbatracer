struct BvhNode {
    bounds: Box,          // The bounds of this node
    child_first: int,    // Left child index or first primitive index
    prim_count: int      // Primitive count in this node
}

struct BvhBin {
    bounds: Box,
    prim_count: int
}

struct Bvh {
    nodes: ~[BvhNode],
    prim_ids: ~[int]
}

fn bvh(nodes: ~[BvhNode], prim_ids: ~[int]) -> Bvh {
    Bvh {
        nodes: nodes,
        prim_ids: prim_ids
    }
}

fn bvh_bin(bounds: Box, count: int) -> BvhBin {
    BvhBin {
        bounds: bounds,
        prim_count: count
    }
}

fn empty_bvh_bin() -> BvhBin {
    BvhBin {
        bounds: @empty_box(),
        prim_count: 0
    }
}

fn evaluate_partitions(bins: &[BvhBin],
                       num_bins: int,
                       prim_count: int,
                       cannot_split: fn (),
                       can_split: fn (int)) {
    let mut left_area = [num_bins: float];
    let mut left_count = [num_bins: int];
    
    // Sweep from the left while counting the primitives and computing the area
    let mut cur_box = bins(0).bounds;
    left_area(0) = box_area(cur_box);
    left_count(0) = bins(0).prim_count;

    for i in range(1, num_bins - 2) {
        cur_box = box_union(cur_box, bins(i).bounds);
        left_area(i) = left_area(i - 1) + box_area(cur_box);
        left_count(i) = left_count(i - 1) + bins(i).prim_count;
    }

    // Sweep from the right and determine where to split
    let mut min_idx = num_bins - 1;
    let mut right_count = bins(num_bins - 1).prim_count;
    let mut min_cost = (left_count(num_bins - 2) as float) * left_area(num_bins - 2) +
                       (right_count as float) * box_area(bins(num_bins - 1).bounds);

    cur_box = bins(num_bins - 1).bounds;

    for i in range(2, num_bins - 1) {
        let j = num_bins - i;

        cur_box = box_union(cur_box, bins(j).bounds);
        right_count += bins(j).prim_count;

        let cost = (right_count as float) * box_area(cur_box) +
                   (left_count(j - 1) as float) * left_area(j - 1);
        if cost < min_cost {
            min_cost = cost;
            min_idx = j;
        }
    }

    // If the number of primitives in any of the two sets is zero,
    // we cannot split this node
    let num_left = left_count(min_idx - 1);
    if num_left == 0 || num_left == prim_count {
        @cannot_split()
    } else {
        @can_split(min_idx)
    }
}

fn build_bvh(boxes: &[Box],
             centers: &[Vec3],
             prim_count: int) -> Bvh {
    // Allocate & initialize the primitive permutation array
    let mut prim_ids = ~[prim_count: int];
    for i in range(0, prim_count) {
        prim_ids(i) = i;
    }

    // Preallocate the BVH nodes (upper bound)
    let mut nodes = ~[(2 * prim_count + 1): BvhNode];
    nodes(0).prim_count = prim_count;
    nodes(0).child_first = 0;

    // Start construction
    $build_bvh_node(nodes, 0, 1, prim_ids, boxes, centers);

    bvh(nodes, prim_ids)
}

fn build_bvh_node(mut nodes: &[BvhNode],
                  cur_node: int,
                  next_free: int,
                  mut prim_ids: &[int],
                  boxes: &[Box],
                  centers: &[Vec3]) -> int {
    let mut node = &(nodes(cur_node));

    // Compute the node bounds
    node.bounds = empty_box();
    let mut center_box = empty_box();

    for i in range(0, node.prim_count) {
        let id = prim_ids(node.child_first + i);
        node.bounds = box_union(node.bounds, boxes(id));
        center_box = box_expand(center_box, centers(id));
    }

    // Find longuest axis
    let extents = @box_extents(center_box);
    let mut axis = 0;
    if extents.values(0) < extents.values(1) {
        axis = 1;    
    }
    if extents.values(axis) < extents.values(2) {
        axis = 2;
    }

    // Build the bins
    let num_bins = 16;
    let mut bins : [BvhBin * 16];

    for i in range(0, num_bins) {
        bins(i) = @empty_bvh_bin();
    }

    // Put the primitives in the bins
    let sah_epsilon = 0.0001f;
    let sah_factor = (num_bins as float) * (1.0f - sah_epsilon) /
                     (center_box.max.values(axis) - center_box.min.values(axis) + sah_epsilon);
    let sah_offset = center_box.min.values(axis);
    for i in range(0, node.prim_count) {
        let id = prim_ids(node.child_first + i);
        let bin_id = sah_factor * (centers(id).values(axis) - sah_offset) as int;
        bins(bin_id).bounds = box_union(bins(bin_id).bounds, boxes(id));
        bins(bin_id).prim_count += 1;
    }
    
    let end = return;

    // Find the best split position and then build the children
    @evaluate_partitions(&bins, num_bins, node.prim_count, || {end(next_free)}, |min_id| {
        // Split the primitives in two sets
        let mut a = node.child_first;
        let mut b = node.child_first + node.prim_count - 1;

        while a <= b {
            let bin_id = sah_factor * (centers(prim_ids(a)).values(axis) - sah_offset) as int;

            if bin_id >= min_id {
                prim_ids(a) ^= prim_ids(b);
                prim_ids(b) ^= prim_ids(a);
                prim_ids(a) ^= prim_ids(b);
                b -= 1;
            } else {
                a += 1;
            }
        }

        // Build the two children recursively
        let free_left  = $build_bvh_node(nodes, next_free, next_free + 2, prim_ids, boxes, centers);
        let free_right = $build_bvh_node(nodes, next_free + 1, free_left, prim_ids, boxes, centers);
        end(free_right)
    })
}

