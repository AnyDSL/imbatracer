struct BvhNode {
    bounds: Box,         // The bounds of this node
    child_first: int,    // Left child index or first primitive index
    prim_count: i16,     // Primitive count in this node
    axis: i16            // Splitting axis
}

struct BvhBin {
    bounds: Box,
    prim_count: int
}

struct Bvh {
    nodes: ~[BvhNode],
    node_count: int,
    prim_ids: ~[int]
}

fn bvh(nodes: ~[BvhNode], node_count: int, prim_ids: ~[int]) -> Bvh {
    Bvh {
        nodes: nodes,
        node_count: node_count,
        prim_ids: prim_ids
    }
}

fn bvh_bin(bounds: Box, count: int) -> BvhBin {
    BvhBin {
        bounds: bounds,
        prim_count: count
    }
}

fn empty_bvh_bin() -> BvhBin {
    BvhBin {
        bounds: empty_box(),
        prim_count: 0
    }
}

fn evaluate_partitions(bins: &[BvhBin],
                       num_bins: int,
                       prim_count: int,
                       max_cost: float,
                       cannot_split: fn (),
                       can_split: fn (int)) @{
    assert(|| { num_bins == 16 }, "evaluate_partitions : number of bins doesn't match");
    let mut left_area : [float * 16];
    let mut left_count : [int * 16];
    
    // Sweep from the left while counting the primitives and computing the area
    let mut cur_box = bins(0).bounds;
    left_area(0) = box_half_area(cur_box);
    left_count(0) = bins(0).prim_count;

    for i in range(1, num_bins - 1) @{
        cur_box = box_union(cur_box, bins(i).bounds);
        left_area(i) = box_half_area(cur_box);
        left_count(i) = left_count(i - 1) + bins(i).prim_count;
    }

    // Sweep from the right and determine where to split
    let mut min_idx = num_bins - 1;
    let mut right_count = bins(num_bins - 1).prim_count;
    let mut min_cost = (left_count(num_bins - 2) as float) * left_area(num_bins - 2) +
                       (right_count as float) * box_half_area(bins(num_bins - 1).bounds);

    cur_box = bins(num_bins - 1).bounds;
    for i in range(2, num_bins - 1) @{
        let j = num_bins - i;

        cur_box = box_union(cur_box, bins(j).bounds);
        right_count += bins(j).prim_count;

        assert(|| { right_count + left_count(j - 1) == prim_count }, "evaluate_partitions : number of primitives is incorrect");

        let cost = (right_count as float) * box_half_area(cur_box) +
                   (left_count(j - 1) as float) * left_area(j - 1);
        if cost < min_cost {
            min_cost = cost;
            min_idx = j;
        }
    }

    // If the number of primitives in any of the two sets is zero,
    // we cannot split this node
    let num_left = left_count(min_idx - 1);
    if num_left == 0 || num_left == prim_count || min_cost >= max_cost {
        @cannot_split()
    } else {
        @can_split(min_idx)
    }
}

fn build_bvh_node(mut nodes: &[BvhNode],
                  next_free: int,
                  push_node: fn((int, int, int, int)) -> (),
                  pop_node: fn() -> (int, int, int, int),
                  must_stop: fn(int, int) -> bool,
                  compute_bounds: fn(int, int) -> Box,
                  decide_split: fn(int, int, Box, fn (), fn (i16, int))) -> int @{
    // Pop a node from the stack
    let stack_top = pop_node();
    let cur_node = stack_top(0);
    let first_prim = stack_top(1);
    let last_prim = stack_top(2);
    let depth = stack_top(3);

    let prim_count = last_prim - first_prim;

    nodes(cur_node).bounds = compute_bounds(first_prim, last_prim);

    // Stop when the number of primitives is too small
    if must_stop(prim_count, depth) {
        nodes(cur_node).child_first = first_prim;
        nodes(cur_node).prim_count = prim_count as i16;
        return(next_free)
    }

    // Compute the node bounds
    decide_split(first_prim, last_prim, nodes(cur_node).bounds,
        || @{
            assert(|| { prim_count < 16384 },
                   "build_bvh_node: cannot have more than 16384 primitives per leaf");
            nodes(cur_node).child_first = first_prim;
            nodes(cur_node).prim_count = prim_count as i16;
            return(next_free)
        },
        |axis, split_pos| @{
            assert(|| { split_pos - first_prim > 0 && last_prim - split_pos > 0 },
                   "build_bvh_node: node split with no primitive inside one children");

            nodes(cur_node).axis = axis;
            nodes(cur_node).prim_count = 0i16;
            nodes(cur_node).child_first = next_free;

            // Build the two children recursively
            push_node((next_free, first_prim, split_pos, depth + 1));
            push_node((next_free + 1, split_pos, last_prim, depth + 1));
            
            return(next_free + 2)
        })
}

fn build_bvh(boxes: fn (int) -> Box,
             centers: fn (int) -> Vec3,
             prim_count: int) -> Bvh {
    // TODO : do not allocate intermediate arrays when impala is able to compile this.
    let mut boxes2 = ~[prim_count: Box];
    let mut centers2 = ~[prim_count: Vec3];
    for i in range(0, prim_count) @{
        boxes2(i) = boxes(i);
        centers2(i) = centers(i);
    }

    let bvh2 = build_bvh2(boxes2, centers2, prim_count);

    thorin_free(boxes2 as &[u8]);
    thorin_free(centers2 as &[u8]);
    
    bvh2
}

fn build_bvh2(boxes: &[Box],
              centers: &[Vec3],
              prim_count: int) -> Bvh {
    // Allocate & initialize the primitive permutation array
    let mut prim_ids = ~[prim_count: int];
    for i in range(0, prim_count) {
        prim_ids(i) = i;
    }

    // Preallocate the BVH nodes (upper bound)
    let nodes = ~[(2 * prim_count + 1): BvhNode];

    fn ilog2(i: int) -> int {
        let mut p = 1;
        let mut q = 0;
        while p < i {
            p *= 2;
            q += 1
        }
        q
    }

    let max_depth = ilog2(prim_count) + 2;

    // Functions that define the build process
    fn must_stop(prim_count: int, depth: int) -> bool @{
        prim_count < 4 || depth >= max_depth
    }

    fn compute_bounds(first: int, last: int) -> Box @{
        let mut bounds = empty_box();

        for i in range(first, last) @{
            let id = prim_ids(i);
            bounds = box_union(bounds, boxes(id));
        }

        bounds
    }

    fn decide_split(first: int, last: int, node_bounds: Box,
                    make_leaf: fn(), make_node: fn (i16, int)) @{
        // Compute the bounding box of the triangle centers
        let mut center_box = empty_box();
        for i in range(first, last) @{
            let id = prim_ids(i);
            center_box = box_expand(center_box, centers(id));
        }

        // Find longuest axis on that box
        let extents = box_extents(center_box);
        let mut axis = 0i16;
        if extents.values(0) < extents.values(1) {
            axis = 1i16;    
        }
        if extents.values(axis) < extents.values(2) {
            axis = 2i16;
        }

        // Build the bins
        let num_bins = 16;
        let mut bins : [BvhBin * 16];

        for i in range(0, num_bins) @{
            bins(i) = empty_bvh_bin();
        }

        // Put the primitives in the bins
        let sah_epsilon = 0.0001f;
        let sah_factor = (num_bins as float) * (1.0f - sah_epsilon) /
                         (center_box.max.values(axis) - center_box.min.values(axis) + sah_epsilon);
        let sah_offset = center_box.min.values(axis);

        fn compute_bin_id(center: Vec3) -> int @{
            sah_factor * (center.values(axis) - sah_offset) as int
        }

        for i in range(first, last) @{
            let id = prim_ids(i);
            let bin_id = compute_bin_id(centers(id));

            bins(bin_id).bounds = box_union(bins(bin_id).bounds, boxes(id));
            bins(bin_id).prim_count += 1;
        }

        // Find the best split position and then build the children
        let max_cost = (prim_count as float) * box_half_area(node_bounds);

        @evaluate_partitions(&bins, num_bins, last - first, max_cost,
            make_leaf,
            |min_id| @{
                // Split the primitives in two sets
                let mut a = first;
                let mut b = last - 1;

                while a <= b @{
                    let bin_id = compute_bin_id(centers(prim_ids(a)));

                    if bin_id >= min_id @{
                        let tmp = prim_ids(a);
                        prim_ids(a) = prim_ids(b);
                        prim_ids(b) = tmp;
                        b -= 1;
                    } else @{
                        a += 1;
                    }
                }

                make_node(axis, a)
            })
    }  

    // A stack of 32 elements is enough since we limit the depth to log2(prim_count)
    let mut stack: [(int, int, int, int) * 32];
    let mut node_count = 1;
    let mut stack_idx = 0;

    fn push_node(node: (int, int, int, int)) -> () {
        stack(stack_idx) = node;
        stack_idx += 1;
    }

    fn pop_node() -> (int, int, int, int) {
        stack_idx -= 1;
        stack(stack_idx)
    }

    push_node((0, 0, prim_count, 0));

    while stack_idx > 0 @{
        node_count = build_bvh_node(nodes, node_count, push_node, pop_node,
                                    must_stop, compute_bounds, decide_split);

    }

    bvh(nodes, node_count, prim_ids)
}

fn refit_bvh(mut bvh: &Bvh, boxes: fn (int) -> Box) -> () @{
    /*let mut stack: [int * 32];
    let mut stack_idx = 1;

    fn push_node(node: int) -> () @{
        stack(stack_idx) = node;
        stack_idx += 1;
    }

    fn pop_node() -> int @{
        stack_idx -= 1;
        stack(stack_idx)
    }

    while stack_idx > 0 {
        
    }*/
}

fn traverse_bvh(bvh: Bvh, at_leaf: fn (Box, int, i16) -> (), at_node: fn (Box, i16, fn (int) -> ()) -> ()) -> () @{
    let mut stack: [int * 32];
    let mut stack_idx = 1;

    fn push_node(node: int) -> () @{
        stack(stack_idx) = node;
        stack_idx += 1;
    }

    fn pop_node() -> int @{
        stack_idx -= 1;
        stack(stack_idx)
    }

    // Traversal loop iteration
    fn traverse(end: fn()) @{
        // If stack is empty, then exit
        if stack_idx <= 0 @{
            end()
        }

        assert(|| { stack_idx < 32 }, "traverse_bvh : stack too small to traverse bvh");

        let node_id = pop_node();
        let cur_node = bvh.nodes(node_id);

        if cur_node.prim_count == 0i16 {
            // If the node is an internal node
            @assert(|| { cur_node.child_first > node_id }, "traverse_bvh : invalid bvh (internal node pointing to parent)");

            @at_node(cur_node.bounds, cur_node.axis,
                |child_id| @{
                    assert(|| { child_id == 0 || child_id == 1 }, "traverse_bvh : recursion returns invalid child index");
                    push_node(cur_node.child_first + (1 - child_id));
                    push_node(cur_node.child_first + child_id);
                });

            $traverse(end)
        } else @{
            // If the node is a leaf
            @assert(|| { cur_node.prim_count > 0i16 }, "traverse_bvh : invalid bvh (leaf with no primitive)");

            at_leaf(cur_node.bounds, cur_node.child_first, cur_node.prim_count);
            $traverse(end)
        }
    }

    stack(0) = 0;
    $traverse(return)

    /* TODO : test this code after the merge with new_master

    while stack_idx > 0 @{
        assert(|| { stack_idx < 32 }, "traverse_bvh : stack too small to traverse bvh");

        let node_id = pop_node();
        let cur_node = bvh.nodes(node_id);

        if cur_node.prim_count == 0i16 {
            // If the node is an internal node
            @assert(|| { cur_node.child_first > node_id }, "traverse_bvh : invalid bvh (internal node pointing to parent)");

            @at_node(cur_node.bounds, cur_node.axis,
                |child_id| @{
                    assert(|| { child_id == 0 || child_id == 1 }, "traverse_bvh : recursion returns invalid child index");
                    push_node(cur_node.child_first + (1 - child_id));
                    push_node(cur_node.child_first + child_id);
                });
        } else @{
            // If the node is a leaf
            @assert(|| { cur_node.prim_count > 0i16 }, "traverse_bvh : invalid bvh (leaf with no primitive)");

            at_leaf(cur_node.bounds, cur_node.child_first, cur_node.prim_count);
        }
    }*/
}

