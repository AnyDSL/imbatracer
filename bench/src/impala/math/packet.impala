// TODO : Transform this struct into traits (when polymorphism works), 
// so that we can have different packet sizes (even a packet of size 1)
struct Packet {
    org_x : [float * 64],
    org_y : [float * 64],
    org_z : [float * 64],

    dir_x : [float * 64],
    dir_y : [float * 64],
    dir_z : [float * 64],

    inv_x : [float * 64],
    inv_y : [float * 64],
    inv_z : [float * 64],

    frustum : Frustum,

    sign : [int * 3],
    first_alive : int,
    last_alive: int
}

struct Hit {
    t : [float * 64],
    u : [float * 64],
    v : [float * 64],
    inst_id : [int * 64],
    tri_id : [int * 64],
}

fn packet_width(p: &Packet) -> int {
    8
}

fn packet_height(p: &Packet) -> int {
    8
}

fn packet_size(p: &Packet) -> int {
    packet_width(p) * packet_height(p)
}

fn packet_ray_id(p: &Packet, x: int, y: int) -> int {
    y * packet_width(p) + x
}

fn packet_org(p: &Packet, i: int) -> Vec3 {
    vec3(p.org_x(i), p.org_y(i), p.org_z(i))
}

fn packet_dir(p: &Packet, i: int) -> Vec3 {
    vec3(p.dir_x(i), p.dir_y(i), p.dir_z(i))
}

fn packet_inv(p: &Packet, i: int) -> Vec3 {
    vec3(p.inv_x(i), p.inv_y(i), p.inv_z(i))
}

fn packet_ray(p: &Packet, i: int) -> Ray {
    ray(packet_dir(p, i), packet_org(p, i))
}

fn packet_ray_inv(p: &Packet, i: int) -> RayInv {
    ray_inv(packet_inv(p, i), packet_org(p, i))
}

fn packet_sign(p: &Packet, i: int) -> int {
    p.sign(i)
}

fn packet_first_alive(p: &Packet) -> int {
    p.first_alive
}

fn packet_last_alive(p: &Packet) -> int {
    p.last_alive
}

fn packet_alive(p: &Packet) -> bool {
    p.first_alive <= p.last_alive
}

fn compute_alive(mut p: &Packet, h: &Hit) -> () {
    while p.first_alive <= p.last_alive && hit_tri(h, p.first_alive) > 0 {
        p.first_alive++;
    }

    while p.last_alive >= p.first_alive && hit_tri(h, p.last_alive) > 0 {
        p.last_alive--;
    }
}

fn generate_packet(mut p: &Packet, generate_ray: fn (int, int) -> Ray) -> () @{
    let mut ray_sign = [0, 0, 0];

    for i in range(0, packet_height(p)) @{
        for j in range(0, packet_width(p)) @{
            let k = i * packet_width(p) + j;
            let ray = generate_ray(j, i);

            ray_sign(0) += if ray.dir.values(0) > 0.0f {1} else {-1};
            ray_sign(1) += if ray.dir.values(1) > 0.0f {1} else {-1};
            ray_sign(2) += if ray.dir.values(2) > 0.0f {1} else {-1};

            p.dir_x(k) = ray.dir.values(0);
            p.dir_y(k) = ray.dir.values(1);
            p.dir_z(k) = ray.dir.values(2);

            p.inv_x(k) = 1.0f / ray.dir.values(0);
            p.inv_y(k) = 1.0f / ray.dir.values(1);
            p.inv_z(k) = 1.0f / ray.dir.values(2);

            p.org_x(k) = ray.org.values(0);
            p.org_y(k) = ray.org.values(1);
            p.org_z(k) = ray.org.values(2);
        }
    }

    p.sign(0) = if ray_sign(0) < 0 {1} else {0};
    p.sign(1) = if ray_sign(1) < 0 {1} else {0};
    p.sign(2) = if ray_sign(2) < 0 {1} else {0};

    p.first_alive = 0;
    p.last_alive = packet_size(p) - 1;
}

fn first_active(p: &Packet, h: &Hit, b: Box) -> int {
    let mut i = p.first_alive;
    while i <= p.last_alive @{
        intersect_ray_box(packet_ray_inv(p, i), b, |t0, t1| {
            if t1 > 0.0f && t0 < hit_t(h, i) @{
                return(i)
            }
        });
        i += 1;
    }
    packet_size(p)
}

fn last_active(p: &Packet, h: &Hit, b: Box, first: int) -> int @{
    let mut i = p.last_alive;
    while i > first @{
        intersect_ray_box(packet_ray_inv(p, i), b, |t0, t1| @{
            if t1 > 0.0f && t0 < hit_t(h, i) @{
                return(i + 1)
            }
        });
        i -= 1;
    }
    first + 1
}

fn perspective_frustum(mut p: &Packet) -> () @{
    let w = packet_width(p);
    let h = packet_height(p);

    let r0 = packet_ray(p, 0);
    let r1 = packet_ray(p, w - 1);
    let r2 = packet_ray(p, w * (h - 1));
    let r3 = packet_ray(p, w * h - 1);

    fn ray_plane(a: Ray, b: Ray) -> Vec4 {
        let n = vec3_cross(a.dir, b.dir);
        let d = -vec3_dot(n, a.org);
        vec4_from_vec3(n, d)
    }

    // Left & Right
    p.frustum.planes(0) = ray_plane(r0, r2);
    p.frustum.planes(1) = ray_plane(r3, r1);

    // Top & Bottom
    p.frustum.planes(2) = ray_plane(r1, r0);
    p.frustum.planes(3) = ray_plane(r2, r3);
}

fn shadow_frustum(mut p: &Packet, light_pos: Vec3, mask: fn (int) -> bool) -> () {
    let mut min = light_pos;
    let mut max = light_pos;

    for i in range(0, packet_size(p)) {
        if mask(i) {
            let org = packet_org(p, i);
            min = vec3_min(min, org);
            max = vec3_max(max, org);
        }
    }

    let extents = vec3_sub(max, min);
    let mut axis = 0;
    if extents.values(1) < extents.values(0) { axis = 1 }
    if extents.values(2) < extents.values(axis) { axis = 2 }

    let u = (axis + 1) % 3;
    let v = (axis + 2) % 3;

    // Bounds on axis U
    p.frustum.planes(0) = vec4(0.0f, 0.0f, 0.0f, -max.values(u));
    p.frustum.planes(0).values(u) = 1.0f;
    p.frustum.planes(1) = vec4(0.0f, 0.0f, 0.0f, min.values(u));
    p.frustum.planes(1).values(u) = -1.0f;

    // Bounds on axis V
    p.frustum.planes(2) = vec4(0.0f, 0.0f, 0.0f, -max.values(v));
    p.frustum.planes(2).values(v) = 1.0f;
    p.frustum.planes(3) = vec4(0.0f, 0.0f, 0.0f, min.values(v));
    p.frustum.planes(3).values(v) = -1.0f;
}

fn bounding_frustum(mut p: &Packet, h: &Hit, mask: fn (int) -> bool) -> () {
    let mut min = vec3(flt_max, flt_max, flt_max);
    let mut max = vec3(-flt_max, -flt_max, -flt_max);

    for i in range(0, packet_size(p)) @{
        if mask(i) {
            let org = packet_org(p, i);
            let end = vec3_add(org, vec3_map(packet_dir(p, i), |x| x * hit_t(h, i)));
            min = vec3_min(min, org);
            min = vec3_min(min, end);
            max = vec3_max(max, org);
            max = vec3_max(max, end);
        }
    }

    let extents = vec3_sub(max, min);
    let mut axis = 0;
    if extents.values(1) < extents.values(0) { axis = 1 }
    if extents.values(2) < extents.values(axis) { axis = 2 }

    let u = (axis + 1) % 3;
    let v = (axis + 2) % 3;

    // Bounds on axis U
    p.frustum.planes(0) = vec4(0.0f, 0.0f, 0.0f, -max.values(u));
    p.frustum.planes(0).values(u) = 1.0f;
    p.frustum.planes(1) = vec4(0.0f, 0.0f, 0.0f, min.values(u));
    p.frustum.planes(1).values(u) = -1.0f;

    // Bounds on axis V
    p.frustum.planes(2) = vec4(0.0f, 0.0f, 0.0f, -max.values(v));
    p.frustum.planes(2).values(v) = 1.0f;
    p.frustum.planes(3) = vec4(0.0f, 0.0f, 0.0f, min.values(v));
    p.frustum.planes(3).values(v) = -1.0f;
}

fn transform_packet(p: &Packet, mut tp: &Packet, mat: &Mat4, inv_mat: &Mat4) -> () @{
    let mut ray_sign = [0, 0, 0];

    for i in range(p.first_alive, p.last_alive + 1) @{
        tp.org_x(i) = mat.c0.values(0) * p.org_x(i) + mat.c1.values(0) * p.org_y(i) + mat.c2.values(0) * p.org_z(i) + mat.c3.values(0);
        tp.org_y(i) = mat.c0.values(1) * p.org_x(i) + mat.c1.values(1) * p.org_y(i) + mat.c2.values(1) * p.org_z(i) + mat.c3.values(1);
        tp.org_z(i) = mat.c0.values(2) * p.org_x(i) + mat.c1.values(2) * p.org_y(i) + mat.c2.values(2) * p.org_z(i) + mat.c3.values(2);

        tp.dir_x(i) = mat.c0.values(0) * p.dir_x(i) + mat.c1.values(0) * p.dir_y(i) + mat.c2.values(0) * p.dir_z(i);
        tp.dir_y(i) = mat.c0.values(1) * p.dir_x(i) + mat.c1.values(1) * p.dir_y(i) + mat.c2.values(1) * p.dir_z(i);
        tp.dir_z(i) = mat.c0.values(2) * p.dir_x(i) + mat.c1.values(2) * p.dir_y(i) + mat.c2.values(2) * p.dir_z(i);

        tp.inv_x(i) = 1.0f / tp.dir_x(i);
        tp.inv_y(i) = 1.0f / tp.dir_y(i);
        tp.inv_z(i) = 1.0f / tp.dir_z(i);

        ray_sign(0) += if tp.dir_x(i) > 0.0f {1} else {-1};
        ray_sign(1) += if tp.dir_y(i) > 0.0f {1} else {-1};
        ray_sign(2) += if tp.dir_z(i) > 0.0f {1} else {-1};
    }

    tp.sign(0) = if ray_sign(0) < 0 {1} else {0};
    tp.sign(1) = if ray_sign(1) < 0 {1} else {0};
    tp.sign(2) = if ray_sign(2) < 0 {1} else {0};

    tp.first_alive = p.first_alive;
    tp.last_alive = p.last_alive;

    let mut tinv_mat = mat4_transpose(inv_mat);

    for i in range(0, 4) @{
        // Multiply by transpose of inverse to get the new plane normal (Xt (MX) = (MtX)t X)
        tp.frustum.planes(i) = mat4_mul_vec4(&tinv_mat, p.frustum.planes(i));
    }
}

fn record_hit(mut h: &Hit, i: int, t: float, u: float, v: float, inst_id: int, tri_id: int) -> () {
    h.t(i) = t;
    h.u(i) = u;
    h.v(i) = v;
    h.inst_id(i) = inst_id;
    h.tri_id(i) = tri_id
}

fn hit_t(h: &Hit, i: int) -> float {
    h.t(i)
}

fn hit_u(h: &Hit, i: int) -> float {
    h.u(i)
}

fn hit_v(h: &Hit, i: int) -> float {
    h.v(i)
}

fn hit_tri(h: &Hit, i: int) -> int {
    h.tri_id(i)
}

fn hit_inst(h: &Hit, i: int) -> int {
    h.inst_id(i)
}

fn empty_hit(p: &Packet, tmax: float) -> Hit {
    Hit {
        t : [tmax, ..64],
        u : [0.0f, ..64],
        v : [0.0f, ..64],
        inst_id : [-1, ..64],
        tri_id : [-1, ..64],
    }
}

