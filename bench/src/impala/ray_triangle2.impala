
fn v3sub(v1 : [float * 3], v2 : [float * 3]) -> [float * 3] {
    [v1(0) - v2(0),
     v1(1) - v2(1),
     v1(2) - v2(2)]
}

fn v3cross(v1 : [float * 3], v2 : [float * 3]) -> [float * 3] {
    [v1(1) * v2(2) - v1(2) * v2(1),
     v1(2) * v2(0) - v1(0) * v2(2),
     v1(0) * v2(1) - v1(1) * v2(0)]
}

fn v3dot(v1 : [float * 3], v2 : [float * 3]) -> float {
    v1(0)*v2(0) + v1(1) * v2(1) + v1(2) * v2(2)
}


fn intersect_ray_tri(org: [float * 3],
                     dir: [float * 3],
                     v0: [float * 3],
                     v1: [float * 3],
                     v2: [float * 3],
                     intr: fn (float, float, float) -> (),
                     nointr: fn () -> ()) -> () {
    let e0 = @v3sub(v1, v0);
    let e1 = @v3sub(v2, v0);

    let pvec = @v3cross(dir, e1);
    let det = @v3dot(e0, pvec);

    let epsilon = 0.0001f;

    if det > -epsilon && det < epsilon {
        @nointr();
        return()
    }

    let inv_det = 1.0f / det;

    let tvec = @v3sub(org, v0);
    let u = @v3dot(tvec, pvec) * inv_det;

    if u < 0.0f || u > 1.0f {
        @nointr();
        return()
    }

    let qvec = @v3cross(tvec, e0);
    let v = @v3dot(dir, qvec) * inv_det;

    if v < 0.0f || u + v > 1.0f {
        @nointr();
        return()
    }

    let t = @v3dot(e1, qvec) * inv_det;

    @intr(t, u, v)
}

