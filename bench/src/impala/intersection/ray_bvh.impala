fn intersect_ray_bvh(r: Ray, mut tmin: float, bvh: &Bvh, intr: fn (int, float) -> float) -> () {
    let ri = ray_inv_from_ray(r);

    let mut cur_node = 0;
    let mut stack : [int * 32];
    let mut stack_id = -1;

    fn pop_node() -> int {
        let node = stack(stack_id);
        stack_id -= 1;
        node
    }

    fn push_node(node: int) -> () {
        stack(stack_id) = node;
        stack_id += 1;
    }

    for ever() {
        let end_traversal = break;
        let next_iteration = continue;

        fn fetch_next_node() {
            // Fetch the next node from the stack or end traversal if the stack is empty
            if stack_id > 0 {
                cur_node = @pop_node();
                next_iteration()
            } else {
                end_traversal()
            }
        }

        // Intersect the ray with the current node
        intersect_ray_box(ri, bvh.nodes(cur_node).bounds, |t0, t1| @{
            // If an intersection was found, check that it is within the ray t bounds
            if t0 <= tmin @{
                if bvh.nodes(cur_node).prim_count > 0i16 @{
                    let order = (r.dir.values(bvh.nodes(cur_node).axis) > 0.0f) as int;

                    // If dir > 0 then traverse first left and then right
                    // Otherwise traverse right first and then left
                    push_node(bvh.nodes(cur_node).child_first + order ^ 1);
                    cur_node = bvh.nodes(cur_node).child_first + order;
                    next_iteration()
                } else @{
                    let first = bvh.nodes(cur_node).child_first;
                    let last = first + (bvh.nodes(cur_node).prim_count as i32);
                    for i in range(first, last) @{
                        tmin = intr(i, tmin)
                    }
                }
            }
        });
        fetch_next_node()
    }
}

