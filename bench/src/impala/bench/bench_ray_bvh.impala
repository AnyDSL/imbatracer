struct BenchRayBvhResult {
    intr_count: int,
    tmin: float,
    tmax: float
}

extern "C" {
    fn put_float(float) -> ();
    fn put_int(int) -> ();
    fn puts(&[u8]) -> ();
}

extern fn bench_ray4_bvh(nray4s: int, bvh: &Bvh, vertices: &[Vec3], indices: &[int], mut result: &BenchRayBvhResult) -> () @{
    fn generate_ray(i: int) -> Ray {
        let theta = ((i % 1000) as float) * flt_pi / 1000.0f;
        let phi = (i as float) * 2.0f * flt_pi / 1000.0f;

        let sin_theta = sinf(theta);

        ray(vec3(sin_theta * cosf(phi), sin_theta * sinf(phi), cosf(theta)),
            vec3(0.3f, -0.1f, 0.2f))
    }

    fn vrange(a: int, b: int, yield: fn(int, fn())) -> () {
        for vectorize(4, a, b) {
           let x = wfv_get_tid();
           yield(x);
        }
    }

    result.tmax = -flt_max;
    result.tmin = flt_max;
    result.intr_count = 0;

    for i in range(0, nray4s) @{
        let mut rays : [Ray * 4];
        let mut inv_dirs : [Vec3 * 4];
        let mut tray = [flt_max,  .. 4];
        let mut intr = [0, .. 4];

        for j in range(0, 4) {
            rays(j) = generate_ray(i * 4 + j);
            inv_dirs(j) = vec3_map(rays(j).dir, |x| 1.0f / x);
        }

        fn at_leaf(box: Box, first: int, count: i16) -> () @{
            for j in range(0, 4) @{
                // First intersect the rays with the current node
                @intersect_ray_box(@ray_inv(inv_dirs(j), rays(j).org), box, |t0, t1| @{
                    // If the rays hit the box, intersect triangles too
                    if t1 > 0.0f && t0 < tray(j) @{
                        for k in range(first, first + count as int) @{
                            let id = bvh.prim_ids(k);
                            let prim = tri(vertices(indices(id * 3 + 0)),
                                           vertices(indices(id * 3 + 1)),
                                           vertices(indices(id * 3 + 2)));

                            @intersect_ray_tri(rays(j), prim,
                                |t, u, v| @{
                                    if t > 0.0f && t < tray(j) @{
                                        intr(j) = 1;
                                        tray(j) = t;
                                    }
                                })
                        }
                    }
                })
            }
        }

        fn at_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
            let mut signs = [0, .. 4];

            for j in range(0, 4) @{
                @intersect_ray_box(@ray_inv(inv_dirs(j), rays(j).org), box, |t0, t1| @{
                    if t1 > 0.0f && t0 < tray(j) @{
                        signs(j) = if inv_dirs(j).values(axis) > 0.0f {1} else {-1};
                    }
                })
            }

            let hit = signs(0) | signs(1) | signs(2) | signs(3);

            // If any ray touches the node, traverse down the tree
            if hit != 0 @{
                let sum = signs(0) + signs(1) + signs(2) + signs(3);
                push(if sum > 0 {0} else {1})
            }
        }

        traverse_bvh(*bvh, at_leaf, at_node);

        for j in range(0, 4) @{
            result.intr_count += intr(j);
            if intr(j) != 0 {
                if result.tmax < tray(j) { result.tmax = tray(j); }
                if result.tmin > tray(j) { result.tmin = tray(j); }
            }
        }
    }
}

extern fn bench_ray_bvh(nrays: int, bvh: &Bvh, vertices: &[Vec3], indices: &[int], mut result: &BenchRayBvhResult) -> () @{
    fn generate_ray(i: int) -> Ray {
        let theta = ((i % 1000) as float) * flt_pi / 1000.0f;
        let phi = (i as float) * 2.0f * flt_pi / 1000.0f;

        let sin_theta = sinf(theta);

        ray(vec3(sin_theta * cosf(phi), sin_theta * sinf(phi), cosf(theta)),
            vec3(0.3f, -0.1f, 0.2f))
    }

    result.tmax = -flt_max;
    result.tmin = flt_max;
    result.intr_count = 0;

    for i in range(0, nrays) @{
        let r = generate_ray(i);
        let rinv = ray_inv_from_ray(r);
        let mut tray = flt_max;
        let mut intr = 0;

        fn at_leaf(box: Box, first: int, count: i16) -> () @{
            // First intersect the ray with the current node
            intersect_ray_box(rinv, box, |t0, t1| @{
                // If the ray hits the box, intersect triangles too
                if t1 > 0.0f && t0 < tray @{
                    for k in range(first, first + count as int) @{

                        let id = bvh.prim_ids(k);
                        let prim = tri(vertices(indices(id * 3 + 0)),
                                       vertices(indices(id * 3 + 1)),
                                       vertices(indices(id * 3 + 2)));

                        intersect_ray_tri(r, prim,
                            |t, u, v| {
                                if t > 0.0f && t < tray @{
                                    intr = 1;
                                    tray = t;
                                }
                            })
                    }
                }
            })
        }

        fn at_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
            intersect_ray_box(rinv, box, |t0, t1| @{
                if t1 > 0.0f && t0 < tray @{
                    push(if rinv.inv_dir.values(axis) > 0.0f {0} else {1})
                }
            })
        }

        traverse_bvh(*bvh, at_leaf, at_node);

        result.intr_count += intr;
        if intr != 0 {
            if result.tmax < tray { result.tmax = tray; }
            if result.tmin > tray { result.tmin = tray; }
        }
    }
}

