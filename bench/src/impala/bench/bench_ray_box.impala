struct BenchRayBoxResult {
    intr_count: int,
    tmin: float,
    tmax: float
}

extern fn bench_ray4_box(nray4s: int,
                         box_min: &[float * 3],
                         box_max: &[float * 3]) -> ~BenchRayBoxResult @{
    let box = Box {
        min : vec3(box_min(0), box_min(1), box_min(2)),
        max : vec3(box_max(0), box_max(1), box_max(2))
    };

    fn generate_ray(i: int) -> RayInv {
        let f = i % 1000 as float;

       ray_inv_from_ray(ray(vec3(1.0f + f * 0.00001f, 0.00001f * f, 0.00001f * f),
                            vec3(-1.0f + 0.00001f * f, 0.001f + f * 0.001f, 0.001f + f * 0.001f)))
    }

    fn vrange(a: int, b: int, yield: fn(int, fn())) -> () {
        for vectorize(4, a, b) {
           let x = wfv_get_tid();
           yield(x);
        }
    }

    let mut result = ~BenchRayBoxResult {
        intr_count: 0,
        tmin: -flt_max,
        tmax: flt_max
    };

    for i in range(0, nray4s) {
        let mut tmin : [float * 4];
        let mut tmax : [float * 4];
        let mut intr : [int * 4];

        for i in range(0, 4) @{
            tmin(i) = result.tmin;
            tmax(i) = result.tmax;
            intr(i) = 0;
        }

        for j in vrange(0, 4) @{
            let ray = generate_ray(i);
            let next = continue;
            intersect_ray_box(ray, box,
                |t0, t1| {
                    intr(j) = 1;
                    tmin(j) = t0;
                    tmax(j) = t1;
                    next()
                },
                next)
        }

        for i in range(0, 4) @{
            result.intr_count += intr(i);
            if result.tmax > tmax(i) { result.tmax = tmax(i); };
            if result.tmin < tmin(i) { result.tmin = tmin(i); };
        }
    }

    result
}

extern fn bench_ray_box(nrays: int,
                        box_min: &[float * 3],
                        box_max: &[float * 3]) -> ~BenchRayBoxResult @{
    let box = box(vec3(box_max(0), box_max(1), box_max(2)),
                  vec3(box_min(0), box_min(1), box_min(2)));

    fn generate_ray(i: int) -> RayInv {
        let f = (i % 1000) as float;

       ray_inv_from_ray(ray(vec3(1.0f + f * 0.00001f, 0.00001f * f, 0.00001f * f),
                            vec3(-1.0f + 0.00001f * f, 0.001f + f * 0.001f, 0.001f + f * 0.001f)))
    }

    let mut result = ~BenchRayBoxResult {
        intr_count: 0,
        tmin: -flt_max,
        tmax: flt_max
    };

    for i in range(0, nrays) @{
        let ray = generate_ray(i);
        let next = continue;
        intersect_ray_box(ray, box,
            |t0, t1| {
                result.intr_count = result.intr_count + 1;
                if result.tmax > t1 { result.tmax = t1; };
                if result.tmin < t0 { result.tmin = t0; };
                next()
            },
            next)
    }

    result
}

