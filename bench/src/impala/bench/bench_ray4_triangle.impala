struct BenchRay4TriangleResult {
    intr_count: int,
    tmin: float
}

extern "C" {
    fn wfv_get_tid() -> int;
}

extern fn bench_ray_triangle(nrays: int,
                             v0: &[float * 3],
                             v1: &[float * 3],
                             v2: &[float * 3]) -> ~BenchRay4TriangleResult {
    ~BenchRay4TriangleResult {
        intr_count: 0,
        tmin: 100000.0f
    }
}

extern fn bench_ray4_triangle(nray4s: int,
                              v0: &[float * 3],
                              v1: &[float * 3],
                              v2: &[float * 3]) -> ~BenchRay4TriangleResult {
    let tri = Tri {
        v0 : @vec3(v0(0), v0(1), v0(2)),
        v1 : @vec3(v1(0), v1(1), v1(2)),
        v2 : @vec3(v2(0), v2(1), v2(2))
    };

    fn generateRay(i: int) -> Ray {
        let f = i % 1000 as float;

        @ray(@vec3(1.0f, 0.0f, 0.0f), vec3(-1.0f, 0.001f + f * 0.001f, 0.001f + f * 0.001f))
    }

    fn vrange(a: int, b: int, yield: fn(int, fn())) -> () {
        for vectorize(8, a, b) {
           let x = wfv_get_tid();
           @yield(x);
        }
    }

    let mut result = ~BenchRay4TriangleResult {
        intr_count: 0,
        tmin: 100000.0f
    };

    for i in vrange(0, nray4s * 4) {
        let ray = @generateRay(i);
        let next = continue;
        @intersect_ray_tri(ray, tri,
            |t, u, v| {
                result.intr_count = result.intr_count + 1;
                if result.tmin > t { result.tmin = t; };
                next()
            },
            next)
    }

    result
}

