struct BenchRayTriangleResult {
    intr_count: int,
    tmin: float
}

extern "C" {
    fn wfv_get_tid() -> int;
}

extern fn bench_ray4_triangle(nray4s: int,
                                v0: &[float * 3],
                                v1: &[float * 3],
                                v2: &[float * 3]) -> ~BenchRayTriangleResult @{
    let tri = tri(vec3(v0(0), v0(1), v0(2)),
                  vec3(v1(0), v1(1), v1(2)),
                  vec3(v2(0), v2(1), v2(2)));

    fn generate_ray(i: int) -> Ray {
        let f = i % 1000 as float;

        ray(vec3(1.0f, 0.0f, 0.0f), vec3(-1.0f, 0.001f + f * 0.001f, 0.001f + f * 0.001f))
    }

    fn vrange(a: int, b: int, yield: fn(int, fn())) -> () {
        for vectorize(4, a, b) {
           let x = wfv_get_tid();
           yield(x);
        }
    }

    let mut result = ~BenchRayTriangleResult {
        intr_count: 0,
        tmin: flt_max
    };

    for i in range(0, nray4s) @{
        let mut tmin : [float * 4];
        let mut intr : [int * 4];

        for i in vrange(0, 4) @{
            tmin(i) = result.tmin;
            intr(i) = 0;
        }

        for j in vrange(0, 4) @{
            let ray = generate_ray(i + j);
            let next = continue;
            intersect_ray_tri(ray, tri,
                |t, u, v| {
                    intr(j) = 1;
                    tmin(j) = t;
                    next()
                },
                next)
        }

        for i in range(0, 4) @{
            if result.tmin > tmin(i) { result.tmin = tmin(i); }
            result.intr_count += intr(i);
        }
    }

    result
}

extern fn bench_ray_triangle(nrays: int,
                             v0: &[float * 3],
                             v1: &[float * 3],
                             v2: &[float * 3]) -> ~BenchRayTriangleResult @{
    let tri = Tri {
        v0 : vec3(v0(0), v0(1), v0(2)),
        v1 : vec3(v1(0), v1(1), v1(2)),
        v2 : vec3(v2(0), v2(1), v2(2))
    };

    fn generateRay(i: int) -> Ray {
        let f = i % 1000 as float;

        ray(vec3(1.0f, 0.0f, 0.0f), vec3(-1.0f, 0.001f + f * 0.001f, 0.001f + f * 0.001f))
    }

    let mut result = ~BenchRayTriangleResult {
        intr_count: 0,
        tmin: flt_max
    };

    for i in range(0, nrays) @{
        let ray = generateRay(i);
        let next = continue;
        intersect_ray_tri(ray, tri,
            |t, u, v| {
                result.intr_count += 1;
                if result.tmin > t { result.tmin = t; };
                next()
            },
            next)
    }

    result
}

