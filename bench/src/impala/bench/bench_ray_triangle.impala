struct BenchRayTriangleResult {
    intr_count: int,
    tmin: float
}

extern fn bench_ray4_triangle(nrays: int,
                              v0: &[float * 3],
                              v1: &[float * 3],
                              v2: &[float * 3]) -> ~BenchRayTriangleResult {
    ~BenchRayTriangleResult {
        intr_count: 0,
        tmin: 100000.0f
    }
}

extern fn bench_ray_triangle(nrays: int,
                             v0: &[float * 3],
                             v1: &[float * 3],
                             v2: &[float * 3]) -> ~BenchRayTriangleResult {
    let tri = Tri {
        v0 : @vec3(v0(0), v0(1), v0(2)),
        v1 : @vec3(v1(0), v1(1), v1(2)),
        v2 : @vec3(v2(0), v2(1), v2(2))
    };

    fn generateRay(i: int) -> Ray {
        let f = i % 1000 as float;

        @ray(@vec3(1.0f, 0.0f, 0.0f), vec3(-1.0f, 0.001f + f * 0.001f, 0.001f + f * 0.001f))
    }

    fn range(mut a: int, b: int, body: fn (int) -> ()) -> () {
        while a < b {
            body(a);
            a = a + 1
        }
    }

    let mut result = ~BenchRayTriangleResult {
        intr_count: 0,
        tmin: 100000.0f
    };

    for i in range(0, nrays) {
        let ray = @generateRay(i);
        let next = continue;
        @intersect_ray_tri(ray, tri,
            |t, u, v| {
                result.intr_count = result.intr_count + 1;
                if result.tmin > t { result.tmin = t; };
                next()
            },
            next)
    }

    result
}

