fn range(a: int, b: int, yield: fn(int) -> ()) -> () {
    if a < b {
        yield(a);
        range(a + 1, b, yield, return)
    }
}

fn urange(a: uint, b: uint, yield: fn(uint) -> ()) -> () {
    if a < b {
        yield(a);
        urange(a + 1u, b, yield, return)
    }
}

fn range_step(a: int, b: int, c: int, yield: fn(int) -> ()) -> () {
    if a < b {
        yield(a);
        range_step(a + c, b, c, yield, return)
    }
}

fn urange_step(a: uint, b: uint, c: uint, yield: fn(uint) -> ()) -> () {
    if a < b {
        yield(a);
        urange_step(a + c, b, c, yield, return)
    }
}

fn brange(a: int, b: int, yield: fn(int) -> ()) -> () {
    if a > b {
        yield(a);
        range(a - 1, b, yield, return)
    }
}

fn ubrange(a: uint, b: uint, yield: fn(uint) -> ()) -> () {
    if a > b {
        yield(a);
        urange(a - 1u, b, yield, return)
    }
}

fn brange_step(a: int, b: int, c: int, yield: fn(int) -> ()) -> () {
    if a > b {
        yield(a);
        range_step(a - c, b, c, yield, return)
    }
}

fn ubrange_step(a: uint, b: uint, c: uint, yield: fn(uint) -> ()) -> () {
    if a > b {
        yield(a);
        urange_step(a - c, b, c, yield, return)
    }
}

fn ever(yield: fn () -> ()) -> () {
    yield();
    ever(yield, return)
}

