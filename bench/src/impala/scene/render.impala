struct Camera {
    up : Vec3,
    right : Vec3,
    center : Vec3,
    eye : Vec3
}

fn write_gbuffer(x : int, y : int, buf: &GBuffer, pixel: GBufferPixel) -> () {
    let p = buf.buffer as u64 + (y * buf.stride) as u64;
    let mut row = p as &[GBufferPixel];
    row(x) = pixel;
}

extern fn render_gbuffer(scene: &Scene, comp: &CompiledScene, cam: &Camera, gbuffer: &GBuffer) -> () @{
    // TODO : Do that in parallel
    let d = vec3_sub(cam.center, cam.eye);

    fn xf(x : int) -> float @{
        2.0f * (x as float) / ((gbuffer.width - 1) as float) - 1.0f
    }

    fn yf(y : int) -> float @{
        2.0f * (y as float) / ((gbuffer.height - 1) as float) - 1.0f
    }

    for y in range_step(0, gbuffer.height, 2) @{
        for x in range_step(0, gbuffer.width, 2) @{
            let mut p : Packet;

            for i in range(0, packet_size(p)) @{
                let kx = @xf(x + (i % 2));
                let ky = @yf(y + (i / 2));
                p.dir_x(i) = d.values(0) + cam.right.values(0) * kx + cam.up.values(0) * ky;
                p.dir_y(i) = d.values(1) + cam.right.values(1) * kx + cam.up.values(1) * ky;
                p.dir_z(i) = d.values(2) + cam.right.values(2) * kx + cam.up.values(2) * ky;

                p.inv_x(i) = 1.0f / p.dir_x(i);
                p.inv_y(i) = 1.0f / p.dir_y(i);
                p.inv_z(i) = 1.0f / p.dir_z(i);

                p.org_x(i) = cam.eye.values(0);
                p.org_y(i) = cam.eye.values(1);
                p.org_z(i) = cam.eye.values(2);
            }

            let hit = @closest_hit(scene, comp, p);

            for i in range(0, packet_size(p)) @{
                write_gbuffer(x + (i % 2), y + (i / 2), gbuffer,
                              gbuffer_pixel(hit.t(i), hit.u(i), hit.v(i), hit.tri_id(i)));
            }
        }
    }
}


