struct Camera {
    up : Vec3,
    right : Vec3,
    center : Vec3,
    eye : Vec3
}

fn write_gbuffer(x : int, y : int, buf: &GBuffer, pixel: GBufferPixel) -> () {
    let p = buf.buffer as u64 + (y * buf.stride) as u64;
    let mut row = p as &[GBufferPixel];
    row(x) = pixel;
}

extern fn render_gbuffer(scene: &Scene, comp: &CompiledScene, cam: &Camera, gbuffer: &GBuffer) -> () @{
    // TODO : Do that in parallel
    let d = vec3_sub(cam.center, cam.eye);

    fn generate_ray(x: int, y: int) -> Ray {
        let kx = 2.0f * (x as float) / ((gbuffer.width - 1) as float) - 1.0f;
        let ky = 1.0f - 2.0f * (y as float) / ((gbuffer.height - 1) as float);

        let dir = vec3(d.values(0) + cam.right.values(0) * kx + cam.up.values(0) * ky,
                       d.values(1) + cam.right.values(1) * kx + cam.up.values(1) * ky,
                       d.values(2) + cam.right.values(2) * kx + cam.up.values(2) * ky);

        ray(dir, cam.eye)
    }

    for y in range_step(0, gbuffer.height, 8) @{
        for x in range_step(0, gbuffer.width, 8) @{
            let mut p : Packet;
            let mut hit : Hit = empty_hit(&p);

            generate_packet(&p, x, y, generate_ray);
            perspective_frustum(&p);
            closest_hit(scene, comp, &p, &hit);

            for i in range(0, packet_height(&p)) @{
                for j in range(0, packet_width(&p)) @{
                    let k = packet_ray_id(&p, j, i);
                    
                    write_gbuffer(x + j, y + i, gbuffer, gbuffer_pixel(hit.t(k), hit.u(k), hit.v(k), hit.tri_id(k)));
                }
            }
        }
    }
}


