struct Material {
    ka: Vec3,
    kd: Vec3,
    ks: Vec3,
    exp: float,
    tex_id: int
}

// TODO : replace materials by shader system in the future
fn evaluate_material(p: &Packet, h: &Hit, mut scene: &Scene, comp: &CompiledScene, accumulate: fn (int, Vec3) -> ()) -> () {
    let mut normals : [Vec3 * 64];

    // Compute normals
    for i in range(0, packet_size(p)) @{
        let mesh_id = scene.instances(hit_inst(h, i)).mesh_id;
        let mesh = scene.meshes(mesh_id);

        let tri_id = hit_tri(h, i);
        if tri_id >= 0 @{
            let u = hit_u(h, i);
            let v = hit_v(h, i);
            let w = 1.0f - u - v;
            let t = hit_t(h, i);

            // Compute normal
            let n0 = vec3_map(mesh.normals(mesh.indices(tri_id * 3 + 0)), |x| x * w);
            let n1 = vec3_map(mesh.normals(mesh.indices(tri_id * 3 + 1)), |x| x * u);
            let n2 = vec3_map(mesh.normals(mesh.indices(tri_id * 3 + 2)), |x| x * v);
            let n = vec3_norm(vec3_add(n0, vec3_add(n1, n2)));

            normals(i) = n;
        } else @{
            normals(i) = vec3(0.0f, 0.0f, 0.0f);
        }
    }

    // Ambient light contribution
    for i in range(0, packet_size(p)) @{
        let tri_id = hit_tri(h, i);
        if tri_id >= 0 @{
            let mesh_id = scene.instances(hit_inst(h, i)).mesh_id;
            let mesh = scene.meshes(mesh_id);
            let mat_id = mesh.materials(tri_id);
            let mat = scene.materials(mat_id);
            accumulate(i, mat.ka);
        }
    }

    for j in range(0, scene.num_lights) @{
        let mut sp : Packet;
        let mut sh : Hit;

        if scene.lights(j).pos_dir.values(3) != 0.0f @{
            sh = empty_hit(&sp, 1.0f);
            generate_packet(&sp, |x, y| @{
                let id = packet_ray_id(p, x, y);
                if hit_tri(h, id) >= 0 {
                    let t = hit_t(h, id);
                    let p = vec3_add(vec3_map(packet_dir(p, id), |x| x * t), packet_org(p, id));
                    let d = vec3_sub(vec3_from_vec4(scene.lights(j).pos_dir), p);
                    ray(d, vec3_add(p, vec3_map(d, |x| x * 0.01f)))
                } else {
                    ray(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f))
                }
            });
            shadow_frustum(&sp, vec3_from_vec4(scene.lights(j).pos_dir), |i| hit_tri(h, i) >= 0);
        } else @{
            sh = empty_hit(&sp, flt_max);
            generate_packet(&sp, |x, y| @{
                let id = packet_ray_id(p, x, y);
                if hit_tri(h, id) >= 0 {
                    let t = hit_t(h, id);
                    let p = vec3_add(vec3_map(packet_dir(p, id), |x| x * t), packet_org(p, id));
                    let d = vec3_map(vec3_from_vec4(scene.lights(j).pos_dir), |x| -x);
                    ray(d, vec3_add(p, vec3_map(d, |x| x * 0.01f)))
                } else {
                    ray(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f))
                }
            });
            bounding_frustum(&sp, &sh, |i| hit_tri(h, i) >= 0);
        }
        
        first_hit(scene, comp, &sp, &sh);

        // Compute light contribution
        for i in range(0, packet_size(p)) @{
            let tri_id = hit_tri(h, i);
            if tri_id >= 0 && hit_tri(&sh, i) < 0 @{
                let mesh_id = scene.instances(hit_inst(h, i)).mesh_id;
                let mesh = scene.meshes(mesh_id);
                let mat_id = mesh.materials(tri_id);
                let mat = scene.materials(mat_id);
                let t = hit_t(h, i);
                let p = vec3_add(vec3_map(packet_dir(p, i), |x| x * t), packet_org(p, i));
                accumulate(i, vec3_mul(mat.kd, evaluate_light(&scene.lights(j), p, normals(i))));
            }
        }
    }
}

