struct Scene {
    instances:     &[MeshInstance],
    num_instances: int,
    meshes:        &[Mesh],
    num_meshes:    int,
    textures:      &[Texture],
    num_textures:  int
}

// TODO : introduce a polymorphic compiled scene type (this is currently designed only for BVHs)
// this also implies that we modify the impala cgen so that you can generate void* pointers
// for pointers to structures that you want to hide.
struct CompiledScene {
    mesh_bvhs: ~[Bvh],
    scene_bvh: Bvh,
}

extern fn compile_scene(mut scene: &Scene) -> ~CompiledScene {
    // TODO : implement instances
    // Build a BVH for each mesh
    let mut mesh_bvhs = ~[scene.num_meshes: Bvh];    
    for i in range(0, scene.num_meshes) @{
        mesh_bvhs(i) = build_mesh_bvh(&scene.meshes(i));
    }

    // Build an outer BVH that encloses the scene
    let outer_bvh = build_bvh(|i| mesh_bvhs(i).nodes(0).bounds,
                              |i| box_center(mesh_bvhs(i).nodes(0).bounds),
                              scene.num_meshes);

    ~CompiledScene {
        mesh_bvhs : mesh_bvhs,
        scene_bvh : outer_bvh
    }
}

extern fn destroy_scene(scene: &Scene, comp: &CompiledScene) -> () {
    // TODO : change this when impala supports auto pointers
    thorin_free(comp.scene_bvh.nodes as &[u8]);
    thorin_free(comp.scene_bvh.prim_ids as &[u8]);

    for i in range(0, scene.num_meshes) @{
        thorin_free(comp.mesh_bvhs(i).nodes as &[u8]);
        thorin_free(comp.mesh_bvhs(i).prim_ids as &[u8]);
    }

    thorin_free(comp.mesh_bvhs as &[u8])
}

extern fn update_scene(scene: &Scene, mut comp: &CompiledScene) -> () {
    // TODO : Real update (more meshes -> more bvhs and more nodes in the scene bvh,
    // connectivity changed -> more nodes in mesh bvh)

    // Refit the BVH of each mesh
    // TODO : Do this in parallel
    for i in range(0, scene.num_meshes) @{
        refit_bvh(&comp.mesh_bvhs(i), |j| @{
            let v0 = scene.meshes(i).vertices(scene.meshes(i).indices(j * 3 + 0));
            let v1 = scene.meshes(i).vertices(scene.meshes(i).indices(j * 3 + 1));
            let v2 = scene.meshes(i).vertices(scene.meshes(i).indices(j * 3 + 2));

            box(vec3_min(v0, vec3_min(v1, v2)),
                vec3_max(v0, vec3_max(v1, v2)))
        });
    }

    // TODO : remove this when impala supports auto pointers
    thorin_free(comp.scene_bvh.nodes as &[u8]);
    thorin_free(comp.scene_bvh.prim_ids as &[u8]);

    // Rebuild the outer BVH
    // TODO : reuse memory whenever possible
    comp.scene_bvh = build_bvh(|i| comp.mesh_bvhs(i).nodes(0).bounds,
                               |i| box_center(comp.mesh_bvhs(i).nodes(0).bounds),
                               scene.num_meshes);
}

fn closest_hit_mesh(mesh: Mesh, mesh_bvh: Bvh, mesh_id: int, p: Packet, prev_h: Hit) -> Hit @{
    let mut hit = prev_h;

    // TODO : ranged traversal + active ray test (for single ray case : std traversal)
    fn mesh_leaf(box: Box, first: int, count: i16) -> () @{
        intersect_packet_box(p, hit, box, || {
            for i in range(first, first + count as int) {
               let id = mesh_bvh.prim_ids(i);
               let t = tri(mesh.vertices(mesh.indices(id * 3 + 0)),
                           mesh.vertices(mesh.indices(id * 3 + 1)),
                           mesh.vertices(mesh.indices(id * 3 + 2)));
               @assert(|| in_box(t.v0, box) && in_box(t.v1, box) && in_box(t.v2, box), "closest_hit_mesh : node bounds too small");
               hit = intersect_packet_tri(p, hit, t, mesh_id, i);
            }
        })
    }

    fn mesh_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
        intersect_packet_box(p, hit, box, || @{
            push(if packet_sign(p, axis as int) > 0 {0} else {1})
        })
    }

    traverse_bvh(mesh_bvh, mesh_leaf, mesh_node);

    hit
}

fn closest_hit(scene: &Scene, comp: &CompiledScene, p: Packet) -> Hit @{
    /*let mut hit = empty_hit();

    fn scene_leaf(box: Box, first: int, count: i16) -> () @{
        for i in range(first, first + count as int) @{
            hit = closest_hit_mesh(scene.meshes(i), comp.mesh_bvhs(i), i, p, hit)
        }
    }

    fn scene_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
        intersect_packet_box(p, hit, box, || @{
            push(if packet_sign(p, axis as int) > 0 {0} else {1})
        })
    }

    // Intersect the scene BVH and then each relevant mesh BVH
    traverse_bvh(comp.scene_bvh, scene_leaf, scene_node);

    hit
    */

    closest_hit_mesh(scene.meshes(0), comp.mesh_bvhs(0), 0, p, empty_hit())
}

