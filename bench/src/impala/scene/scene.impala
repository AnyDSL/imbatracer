struct Scene {
    instances:     &[MeshInstance],
    num_instances: int,
    meshes:        &[Mesh],
    num_meshes:    int,
    textures:      &[Texture],
    num_textures:  int
}

struct SceneUpdate {
    mesh_refit: &[int],
    num_refit: int,
    mesh_rebuild: &[int],
    num_rebuild: int,
    inst_new: int,
    mesh_new: int
}

// TODO : introduce a polymorphic compiled scene type (this is currently designed only for BVHs)
// this also implies that we modify the impala cgen so that you can generate void* pointers
// for pointers to structures that you want to hide.
struct CompiledScene {
    mesh_bvhs: ~[Bvh],
    inst_bounds: ~[Box],
    inst_centers: ~[Vec3],
    scene_bvh: Bvh,
}

extern fn compile_scene(mut scene: &Scene) -> ~CompiledScene @{
    // Build a BVH for each mesh
    let mut mesh_bvhs = ~[scene.num_meshes: Bvh];    
    for i in range(0, scene.num_meshes) @{
        mesh_bvhs(i) = build_mesh_bvh(&scene.meshes(i));
    }

    // Compute instances bounding boxes
    let mut inst_bounds = ~[scene.num_instances: Box];
    let mut inst_centers = ~[scene.num_instances: Vec3];
    for i in range(0, scene.num_instances) @{
        let mesh_id = scene.instances(i).mesh_id;
        inst_bounds(i) = transform_box(mesh_bvhs(mesh_id).nodes(0).bounds, &scene.instances(i).mat);
        inst_centers(i) = box_center(inst_bounds(i));
    }

    // Build an outer BVH that encloses the scene
    let mut outer_bvh = create_bvh(scene.num_instances);
    outer_bvh = build_bvh(outer_bvh, |i| inst_bounds(i), |i| inst_centers(i), scene.num_instances);

    ~CompiledScene {
        mesh_bvhs : mesh_bvhs,
        inst_bounds : inst_bounds,
        inst_centers : inst_centers,
        scene_bvh : outer_bvh
    }
}

extern fn destroy_scene(scene: &Scene, comp: &CompiledScene) -> () @{
    // TODO : change this when impala supports auto pointers
    thorin_free(comp.inst_bounds as &[u8]);
    thorin_free(comp.inst_centers as &[u8]);

    destroy_bvh(comp.scene_bvh);

    for i in range(0, scene.num_meshes) @{
        destroy_bvh(comp.mesh_bvhs(i));
    }

    thorin_free(comp.mesh_bvhs as &[u8])
}

extern fn update_scene(mut scene: &Scene, update: &SceneUpdate, mut comp: &CompiledScene) -> () {
    // Create new BVHs
    if (update.mesh_new > 0) @{
        let mut copy = ~[scene.num_meshes: Bvh];

        // Copy the old ones
        for i in range(0, scene.num_meshes - update.mesh_new) @{
            copy(i) = comp.mesh_bvhs(i);
        }

        // Create the new ones
        for i in range(scene.num_meshes - update.mesh_new, scene.num_meshes) @{
            copy(i) = build_mesh_bvh(&scene.meshes(i));
        }

        thorin_free(comp.mesh_bvhs as &[u8]);
        comp.mesh_bvhs = copy;
    }

    // Refit the BVHs that need it
    for i in range(0, update.num_refit) @{
        let id = update.mesh_refit(i);

        refit_bvh(comp.mesh_bvhs(id), |j| @{
            let v0 = scene.meshes(id).vertices(scene.meshes(id).indices(j * 3 + 0));
            let v1 = scene.meshes(id).vertices(scene.meshes(id).indices(j * 3 + 1));
            let v2 = scene.meshes(id).vertices(scene.meshes(id).indices(j * 3 + 2));

            box(vec3_min(v0, vec3_min(v1, v2)),
                vec3_max(v0, vec3_max(v1, v2)))
        });
    }

    // Rebuild some other BVHs
    for i in range(0, update.num_rebuild) @{
        let id = update.mesh_rebuild(i);
        comp.mesh_bvhs(id) = rebuild_mesh_bvh(&scene.meshes(id), comp.mesh_bvhs(id));
    }

    // Add new instances
    if (scene.num_instances > comp.scene_bvh.max_prims) {
        thorin_free(comp.inst_bounds as &[u8]);
        thorin_free(comp.inst_centers as &[u8]);
        comp.inst_bounds = ~[scene.num_instances: Box];
        comp.inst_centers = ~[scene.num_instances: Vec3];
    }


    // Rebuild scene BVH
    for i in range(0, scene.num_instances) @{
        let mesh_id = scene.instances(i).mesh_id;
        comp.inst_bounds(i) = transform_box(comp.mesh_bvhs(mesh_id).nodes(0).bounds,
                                            &scene.instances(i).mat);
        comp.inst_centers(i) = box_center(comp.inst_bounds(i));
    }

    if scene.num_instances > comp.scene_bvh.max_prims {
        destroy_bvh(comp.scene_bvh);
        comp.scene_bvh = create_bvh(scene.num_instances);
    }
    
    comp.scene_bvh = build_bvh(comp.scene_bvh,
                               |i| comp.inst_bounds(i),
                               |i| comp.inst_centers(i),
                               scene.num_instances);
}

fn closest_hit_mesh(mesh: Mesh, mesh_bvh: Bvh, mesh_id: int, p: &Packet, hit: &Hit) -> () @{
    fn mesh_leaf(box: Box, first: int, count: i16) -> () @{
        // Ranged traversal of the mesh bvh
        let first_ray = first_active(p, hit, box);
        if (first_ray < packet_size(p)) @{
            let last_ray  = last_active(p, hit, box, first_ray);

            for i in range(first, first + count as int) @{
               let id = mesh_bvh.prim_ids(i);
               let t = tri(mesh.vertices(mesh.indices(id * 3 + 0)),
                           mesh.vertices(mesh.indices(id * 3 + 1)),
                           mesh.vertices(mesh.indices(id * 3 + 2)));
               @assert(|| in_box(t.v0, box) && in_box(t.v1, box) && in_box(t.v2, box), "closest_hit_mesh : node bounds too small");
               intersect_packet_tri(p, hit, first_ray, last_ray, t, mesh_id, id);
            }
        }
    }

    fn mesh_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
        intersect_packet_box(p, hit, box, || @{
            push(packet_sign(p, axis as int))
        })
    }

    traverse_bvh(mesh_bvh, mesh_leaf, mesh_node);
}

fn closest_hit(mut scene: &Scene, comp: &CompiledScene, p: &Packet, hit: &Hit) -> () @{
    let mut tp : Packet;

    fn scene_leaf(box: Box, first: int, count: i16) -> () @{
        intersect_packet_box(p, hit, box, || @{
            for i in range(first, first + count as int) @{
                let inst_id = comp.scene_bvh.prim_ids(i);
                let mesh_id = scene.instances(inst_id).mesh_id;

                transform_packet(p, &tp, &scene.instances(inst_id).inv_mat, &scene.instances(inst_id).mat);
                closest_hit_mesh(scene.meshes(mesh_id), comp.mesh_bvhs(mesh_id), i, &tp, hit)
            }
        })
    }

    fn scene_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
        intersect_packet_box(p, hit, box, || @{
            push(packet_sign(p, axis as int))
        })
    }

    // Intersect the scene BVH and then each relevant mesh BVH
    traverse_bvh(comp.scene_bvh, scene_leaf, scene_node);
}

