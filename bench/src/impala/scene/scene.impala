struct Scene {
    instances:     &[MeshInstance],
    num_instances: int,
    meshes:        &[Mesh],
    num_meshes:    int,
    textures:      &[Texture],
    num_textures:  int
}

// TODO : introduce a polymorphic compiled scene type (this is currently designed only for BVHs)
// this also implies that we modify the impala cgen so that you can generate void* pointers
// for pointers to structures that you want to hide.
struct CompiledScene {
    mesh_bvhs: ~[Bvh],
    scene_bvh: Bvh,
}

extern fn compile_scene(mut scene: &Scene) -> ~CompiledScene {
    // Build a BVH for each mesh
    let mut mesh_bvhs = ~[scene.num_meshes: Bvh];    
    for i in range(0, scene.num_meshes) @{
        mesh_bvhs(i) = build_mesh_bvh(&scene.meshes(i));
    }

    // Build an outer BVH that encloses the scene
    let outer_bvh = build_bvh(|i| mesh_bvhs(i).nodes(0).bounds,
                              |i| box_center(mesh_bvhs(i).nodes(0).bounds),
                              scene.num_meshes);

    ~CompiledScene {
        mesh_bvhs : mesh_bvhs,
        scene_bvh : outer_bvh
    }
}

extern fn update_scene(scene: &Scene, mut comp: &CompiledScene) -> () {
    // TODO : Check that the number of textures & meshes has not changed

    // Refit the BVH of each mesh
    // TODO : Do this in parallel
    for i in range(0, scene.num_meshes) @{
        refit_bvh(&comp.mesh_bvhs(i), |j| @{
            let v0 = scene.meshes(i).vertices(scene.meshes(i).indices(j * 3 + 0));
            let v1 = scene.meshes(i).vertices(scene.meshes(i).indices(j * 3 + 1));
            let v2 = scene.meshes(i).vertices(scene.meshes(i).indices(j * 3 + 2));

            box(vec3_min(v0, vec3_min(v1, v2)),
                vec3_max(v0, vec3_max(v1, v2)))
        });
    }

    // TODO: remove this when impala supports auto pointers
    thorin_free(comp.scene_bvh.nodes as &[u8]);
    thorin_free(comp.scene_bvh.prim_ids as &[u8]);

    // Rebuild the outer BVH
    // TODO : reuse memory whenever possible
    comp.scene_bvh = build_bvh(|i| comp.mesh_bvhs(i).nodes(0).bounds,
                               |i| box_center(comp.mesh_bvhs(i).nodes(0).bounds),
                               scene.num_meshes);
}

fn closest_hit_mesh(mesh: &Mesh, mesh_bvh: &Bvh, mesh_id: int, p: Packet, mut hit: &Hit) -> () {
    // TODO : ranged traversal + active ray test (for single ray case : std traversal)
    fn mesh_leaf(box: Box, first: int, count: i16) -> () @{
        intersect_packet_box(p, *hit, box, || {
            for i in range(first, first + count as int) {
               let t = tri(mesh.vertices(mesh.indices(i * 3 + 0)),
                           mesh.vertices(mesh.indices(i * 3 + 1)),
                           mesh.vertices(mesh.indices(i * 3 + 2)));
               *hit = intersect_packet_tri(p, *hit, t, mesh_id, i);
            }
        })
    }

    fn mesh_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
        intersect_packet_box(p, *hit, box, || @{
            push(if packet_sign(p, axis as int) > 0 {0} else {1})
        })
    }

    traverse_bvh(*mesh_bvh, mesh_leaf, mesh_node)
}

fn closest_hit(mut scene: &Scene, mut comp: &CompiledScene, p: Packet) -> Hit {
    let mut hit = empty_hit();

    fn scene_leaf(box: Box, first: int, count: i16) -> () @{
        for i in range(first, first + count as int) @{
            closest_hit_mesh(&scene.meshes(i), &comp.mesh_bvhs(i), i, p, &hit)
        }
    }

    fn scene_node(box: Box, axis: i16, push: fn (int) -> ()) -> () @{
        intersect_packet_box(p, hit, box, || @{
            push(if packet_sign(p, axis as int) > 0 {0} else {1})
        })
    }

    // Intersect the scene BVH and then each relevant mesh BVH
    traverse_bvh(comp.scene_bvh, scene_leaf, scene_node);

    hit
}

